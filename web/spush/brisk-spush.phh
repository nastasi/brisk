<?php
/*
 *  brisk - spush/brisk-spush.phh
 *
 *  Copyright (C) 2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */

$DOCUMENT_ROOT="";
$HTTP_HOST="dodo.birds.lan";
define('USOCK_PATH', "/tmp/brisk.sock");

class PageFlush {

  var $socket; // socket handler of page stream
  var $kalive; // if no message are sent after RD_KEEPALIVE_TOUT secs we send a keepalive from server
  var $msg;    // place where store failed fwrite data
  var $msg_sz; // size of content

  function PageFlush($socket, $enc, $curtime, $kalive, $header_out, $body)
  {
      printf("TRY FLUSH CREATE\n");
      $body_out = ZLibStream::compress($enc, $body);
      if ($enc != 'plain')
          $header_out['Content-Encoding'] = $enc;
      $body_out_sz = mb_strlen($body_out, "ASCII");
      $hea = headers_render($header_out, $body_out_sz);
      $hea_sz = mb_strlen($hea, "ASCII");

      $this->socket = $socket;
      $this->kalive = $curtime + $kalive;
      $this->msg    = $hea.$body_out;
      $this->msg_sz = $hea_sz + $body_out_sz;
  }

  /* return TRUE if is removable from it's list */
  function try_flush($curtime)
  {
      printf("TRY FLUSH IN\n");
      if ($this->kalive < $curtime) {
          printf("TRY FLUSH CLOSE 1\n");
          fclose($this->socket);
          return TRUE;
      }   

      $wret = @fwrite($this->socket, $this->msg);
      if ($wret == FALSE && $wret !== FALSE) {
          printf("TRY FLUSH PageFlush::try_flush: wret 0 but not FALSE\n");
      }
      if ($wret == $this->msg_sz) {
          printf("TRY FLUSH CLOSE 2\n");
          fclose($this->socket);
          return TRUE;
      }
      $this->msg_sz -= $wret;
      $this->msg    = mb_substr($this->msg, $wret, $this->msg_sz, "ASCII");

      printf("TRY FLUSH RETURN FALSE\n");

      return FALSE;
  }

}

?>
