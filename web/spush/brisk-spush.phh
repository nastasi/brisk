<?php
/*
 *  brisk - spush/brisk-spush.phh
 *
 *  Copyright (C) 2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */

$DOCUMENT_ROOT="";
$HTTP_HOST="dodo.birds.lan";

class PageFlush {

  var $socket; // socket handler of page stream
  var $kalive; // if no message are sent after RD_KEEPALIVE_TOUT secs we send a keepalive from server
  var $msg;    // place where store failed fwrite data
  var $msg_sz; // size of content

  function PageFlush($socket, $curtime, $kalive, $header_out, $body)
  {
      // $body_sz = mb_strlen($body, "ASCII");
      // add length to header_out 
      $hea = headers_render($header_out, 0);

      $this->socket = $socket;
      $this->kalive = $curtime + $kalive;
      $this->msg    = $hea.$body;
      $this->msg_sz = mb_strlen($this->msg, "ASCII");
  }

  /* return TRUE if is removable from it's list */
  function try_flush($curtime)
  {
      if ($this->kalive < $curtime) {
          fclose($this->socket);
          return TRUE;
      }   

      $wret = @fwrite($this->socket, $this->msg);
      if ($wret == FALSE && $wret !== FALSE) {
          printf("PageFlush::try_flush: wret 0 but not FALSE\n");
      }
      if ($wret == $this->msg_sz) {
          fclose($this->socket);
          return TRUE;
      }
      $this->msg_sz -= $wret;
      $this->msg    = mb_substr($this->msg, $wret, $this->msg_sz, "ASCII");

      return FALSE;
  }

}

?>
