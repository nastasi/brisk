<?php
/*
 *  brisk - spush/brisk-spush.phh
 *
 *  Copyright (C) 2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */

$DOCUMENT_ROOT="";
$HTTP_HOST="dodo.birds.lan";
define('USOCK_PATH', "/tmp/brisk.sock");

define('PENDINGPAGE_WAITDATA', 0);
define('PENDINGPAGE_FLUSH', 1);

class PendingPage {

  var $socket; // socket handler of page stream
  var $status; // status can be 0: waiting for data, 1: flush phase

  var $kalive; // if no message are sent after RD_KEEPALIVE_TOUT secs we send a keepalive from server
  var $msg;    // place where store failed fwrite data
  var $msg_sz; // size of content

  var $method; // method used to request the page
  var $header; // array of header fields
  var $get;    // array of get args
  var $post;   // array of post args
  var $cookie; // array of cookie args
  var $path;   // requested path
  var $addr;   // source address
  var $contsz; // expected content size
  var $rest;   // number of missing bytest

  function PendingPage($socket, $curtime, $kalive)
  {
      $this->socket = $socket;
      $this->kalive = $curtime + $kalive;
  }

  static function pendingpage_waiting($socket, $curtime, $kalive, $method, $header,
                                      $get, $post, $cookie, $path, $addr, $rest)
  {
      $thiz = new PendingPage($socket, $curtime, $kalive);
      $thiz->status = PENDINGPAGE_WAITDATA;

      $thiz->method = $method;
      $thiz->header = $header;
      $thiz->get    = $get;
      $thiz->post   = $post;
      $thiz->cookie = $cookie;
      $thiz->path   = $path;
      $thiz->addr   = $addr;
      $thiz->contsz = $header['Content-Length'];
      $thiz->rest   = $rest;

      return ($thiz);
  }

  function try_wait($curtime)
  {
      // if completed return TRUE to allow data to be processed, 
      // if timeout or max content dimension is exceeded move to flushing
  }

  static function pendingpage_flushing($socket, $curtime, $kalive, $enc, $header_out, $body)
  {
      $thiz = new PendingPage($socket, $curtime, $kalive);

      $thiz->to_flushing($enc, $header_out, $body);

      return ($thiz);
  }

  function to_flushing($enc, &$header_out, $body)
  {
      printf("TRY FLUSH CREATE\n");
      $body_out = ZLibStream::compress($enc, $body);
      if ($enc != 'plain')
          $header_out['Content-Encoding'] = $enc;
      $body_out_sz = mb_strlen($body_out, "ASCII");
      $hea = headers_render($header_out, $body_out_sz);
      $hea_sz = mb_strlen($hea, "ASCII");

      $this->status = PENDINGPAGE_FLUSH;
      $this->msg    = $hea.$body_out;
      $this->msg_sz = $hea_sz + $body_out_sz;
  }

  /* return TRUE if is removable from it's list */
  function try_flush($curtime)
  {
      if ($this->status != PENDINGPAGE_FLUSH)
          return (FALSE);

      printf("TRY FLUSH IN\n");
      if ($this->kalive < $curtime) {
          printf("TRY FLUSH CLOSE 1\n");
          fclose($this->socket);
          return TRUE;
      }   

      $wret = @fwrite($this->socket, $this->msg);
      if ($wret == FALSE && $wret !== FALSE) {
          printf("TRY FLUSH PendingPage::try_flush: wret 0 but not FALSE\n");
      }
      if ($wret == $this->msg_sz) {
          printf("TRY FLUSH CLOSE 2\n");
          fclose($this->socket);
          return TRUE;
      }
      $this->msg_sz -= $wret;
      $this->msg    = mb_substr($this->msg, $wret, $this->msg_sz, "ASCII");

      printf("TRY FLUSH RETURN FALSE\n");

      return FALSE;
  }

}

?>
