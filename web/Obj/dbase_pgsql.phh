<?php
  /*
   *  brisk - dbase_pgsql.phh
   *
   *  Copyright (C) 2006-2012 Matteo Nastasi
   *                          mailto: nastasi@alternativeoutput.it
   *                                  matteo.nastasi@milug.org
   *                          web: http://www.alternativeoutput.it
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation; either version 2 of the License, or
   * (at your option) any later version.
   *
   * This program is distributed in the hope that it will be useful, but
   * WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   * General Public License for more details. You should have received a
   * copy of the GNU General Public License along with this program; if
   * not, write to the Free Software Foundation, Inc, 59 Temple Place -
   * Suite 330, Boston, MA 02111-1307, USA.
   *
   */

require_once("${G_base}Obj/dbase_base.phh");

$escsql_from = array( "\\",   "'"   );
$escsql_to   = array( "\\\\", "\\'" );

function escsql($s)
{
    GLOBAL $escsql_from, $escsql_to;

    return str_replace($escsql_from, $escsql_to, $s);
}

class DBConn
{
    static $dbcnnx = FALSE;
    var $db = FALSE;

    function DBConn()
    {
        $this->db = DBConn::$dbcnnx;
    }

    static function create()
    {
        GLOBAL $G_dbauth;

        if (DBConn::$dbcnnx == FALSE) {
            if (!(DBConn::$dbcnnx = @pg_connect ($G_dbauth, PGSQL_CONNECT_FORCE_NEW))) {
                return (FALSE);
            }
        }

        $out = new DBConn();

        return $out;
    }

    static function destroy()
    {
        if (DBConn::$dbcnnx != FALSE) {
            DBConn::$dbcnnx = FALSE;
            return (pg_close(DBConn::$dbcnnx));
        }
        return TRUE;
    }

    static function recover()
    {
        self::destroy();
        return (self::create());
    }

    function db()
    {
        return ($this->db);
    }
}

class BriskDB
{
    var $dbconn;
    var $item;
    var $item_n;

    function BriskDB($dbconn)
    {
        $this->dbconn = $dbconn;
    }

    static function create()
    {
        GLOBAL $DOCUMENT_ROOT, $G_dbpfx;

        $ret = FALSE;

        log_main("BriskDB create:start");

        do {
            if (($dbconn = DBConn::create()) == FALSE) {
                break;
            }

            $ret = new BriskDB($dbconn);
        } while (0);

        return ($ret);
    }

    function query($sql)
    {
        if (($res = pg_query($this->dbconn->db(), $sql)) == FALSE) {
            // try to recover the connection
            if (($this->dbconn = DBConn::recover()) == FALSE)
                return FALSE;
            return (pg_query($this->dbconn->db(), $sql));
        }

        return ($res);
    }

    function users_load()
    {
    }

    function login_exists($login)
    {
        GLOBAL $G_dbpfx;

        /* check the existence of the nick in the BriskDB */
        log_main("login_exists: ".$login);

        $user_sql = sprintf("SELECT * FROM %susers WHERE login = lower('%s') AND (type & CAST (X'%08x' as integer)) = 0;",
                            $G_dbpfx, escsql($login), USER_FLAG_TY_DISABLE);
        if (($user_pg = $this->query($user_sql)) != FALSE)
            if (pg_numrows($user_pg) == 1)
                return TRUE;

        return FALSE;
    }

    function getrecord_bylogin($login) {
        GLOBAL $G_dbpfx;

        $user_sql = sprintf("SELECT * FROM %susers WHERE login = lower('%s') AND (type & CAST (X'%08x' as integer)) = 0;",  $G_dbpfx, escsql($login), USER_FLAG_TY_DISABLE);
        if (($user_pg  = $this->query($user_sql)) == FALSE) {
            return FALSE;
        }
        if (pg_numrows($user_pg) != 1)
            return FALSE;

        $user_obj = pg_fetch_object($user_pg, 0);

        return ($user_obj);
    }

    function user_update_login_time($code, $lintm)
    {
        GLOBAL $G_dbpfx;

        $user_sql = sprintf("UPDATE %susers SET (lintm) = (date 'epoch' + %d * INTERVAL '1 second') WHERE code = %d;", $G_dbpfx, $lintm, $code);

        // $user_pg = $this->query($user_sql);
        // $row_n = pg_affected_rows($user_pg);
        // fprintf(STDERR, "query: %s   NUM: %d\n", ($user_pg == FALSE ? "FALSE" : "TRUE"), $row_n);
        if ( ! (($user_pg  = $this->query($user_sql)) != FALSE && pg_affected_rows($user_pg) == 1) ) {
             return FALSE;
        }

        return TRUE;
    }

    function user_prefs_update($code, $flags, $supp_comp)
    {
        GLOBAL $G_dbpfx;

        $user_sql = sprintf("UPDATE %susers SET (type, supp_comp) = (%d, '%s') WHERE code = %d;",
                            $G_dbpfx, $flags, $supp_comp, $code);
        fprintf(STDERR, "REQUEST [%s]\n", $user_sql);
        if ( ! (($user_pg  = $this->query($user_sql)) != FALSE && pg_affected_rows($user_pg) == 1) ) {
             return FALSE;
        }
        fprintf(STDERR, "REQUEST GOOD [%s]\n", $user_sql);

        return TRUE;
    }

    /*
      if success return a LoginDBItem object
     */
    function login_verify($login, $pass)
    {
        GLOBAL $G_dbpfx;

        $ret = FALSE;

        log_main("login_verify: ".$login);

        //O /* check the existence of the nick in the BriskDB */
        //O for ($i = 0 ; $i < $this->item_n ; $i++) {
        //O log_main("login_verify: BEGIN");

        if (($user_obj = $this->getrecord_bylogin($login)) == FALSE) {
            return FALSE;
        }

        log_main("login[".$user_obj->code."]: ".$user_obj->login);

        /* if it exists check for a valid challenge */
        if (($a_sem = Challenges::lock_data(TRUE)) != FALSE) {
            if (($chals = &Challenges::load_data()) != FALSE) {
                for ($e = 0 ; $e < $chals->item_n ; $e++) {
                    log_main("challenge[".$e."]: ".$chals->item[$e]->login);
                    if (strcmp($login, $chals->item[$e]->login) == 0) {
                        log_main("login_verify [".$pass."] with [".md5($chals->item[$e]->token.$user_obj->pass)."]");

                        if (strcmp($pass, md5($chals->item[$e]->token.$user_obj->pass)) == 0) {
                            log_main("login_verify SUCCESS for ".$login);

                            $chals->rem($login);
                            $this->user_update_login_time($user_obj->code, time());
                            $ret = LoginDBItem::LoginDBItemFromRecord($user_obj);
                            break;
                        }
                    }
                } // end for ($e = 0 ...
            }

            if ($chals->ismod()) {
                Challenges::save_data(&$chals);
            }

            Challenges::unlock_data($a_sem);
        }
        //O break;
        // O } //  if (strcasecmp($this->item[$i]->login, ...
        //O }

        return ($ret);
    }

    function getitem_bylogin($login, &$id) {
        $ret = FALSE;
        $id = -1;

        log_main("getitem_bylogin: ".$login);

        if (($user_obj = $this->getrecord_bylogin($login)) == FALSE)
            return $ret;

        $id = $user_obj->code;
        return (LoginDBItem::LoginDBItemFromRecord($user_obj));
    }

    // TODO FOR DB
    function getmail($login)
    {
        log_main("getmail");

        if (($ret = $this->getrecord_bylogin($login)) == FALSE)
            return FALSE;

        return ($ret->email);
    }

    function addusers_from_olddb($olddb, &$cont)
    {
        GLOBAL $G_dbpfx;

        for ($i = 0 ; $i < $olddb->count() ; $i++) {
            $user_sql = sprintf("INSERT INTO %susers ( login, pass, email, type) VALUES ('%s', '%s', '%s', %d);",
                                $G_dbpfx, escsql(strtolower($olddb->item[$i]->login)), escsql($olddb->item[$i]->pass),
                                escsql($olddb->item[$i]->email), $olddb->item[$i]->type & USER_FLAG_TY_ALL);

            if ( ! (($user_pg  = $this->query($user_sql)) != FALSE && pg_affected_rows($user_pg) == 1) ) {
                $cont .= sprintf("ERROR IN LINE: %s\n", eschtml($user_sql));

                return FALSE;
            }
        }
        return TRUE;
    }

    function getdbconn()
    {
        return ($this->dbconn);
    }

    //   ttok   text UNIQUE,
    //   tidx
    function bin5_points_save($date, $table, $tidx, $action, $ucodes, $pts)
    {
        GLOBAL $G_dbpfx;
        $sql_ttok = escsql($table->table_token);

        $is_trans = FALSE;
        $ret = FALSE;

        $n = count($ucodes);
        /* check the existence of the nick in the BriskDB */
        log_main("bin5_points_save: ");

        do {
            if ($this->query("BEGIN") == FALSE) {
                break;
            }
            $is_trans = TRUE;

            /*
             * matches management
             */
            $mtc_sql = sprintf("UPDATE %sbin5_matches SET (mazzo_next, mult_next) = (%d, %d) WHERE ttok = '%s' RETURNING *;",
                               $G_dbpfx, $table->mazzo, $table->mult, $sql_ttok);
            if (($mtc_pg  = $this->query($mtc_sql)) == FALSE || pg_numrows($mtc_pg) != 1) {

                // match not exists, insert it
                $mtc_sql = sprintf("INSERT INTO %sbin5_matches (ttok, tidx, mazzo_next, mult_next) VALUES ('%s', %d, %d, %d) RETURNING *;",
                                   $G_dbpfx, $sql_ttok, $tidx, $table->mazzo, $table->mult);
                if (($mtc_pg  = $this->query($mtc_sql)) == FALSE || pg_affected_rows($mtc_pg) != 1) {
                    log_crit(sprintf("bin5_points_save: failed at insert match [%s]", $mtc_sql));
                    break;
                }
                $mtc_obj = pg_fetch_object($mtc_pg,0);

                for ($i = 0 ; $i < $n ; $i++) {
                    $ord_sql = sprintf("INSERT INTO %sbin5_table_orders (mcode, ucode, pos) VALUES (%d, %d, %d);",
                                       $G_dbpfx, $mtc_obj->code, $ucodes[$i], $i);
                    if (($ord_pg = $this->query($ord_sql)) == FALSE || pg_affected_rows($ord_pg) != 1 ) {
                        log_crit(sprintf("bin5_points_save: failed at insert table order [%s]", $ord_sql));
                        break;
                    }
                }
                if ($i < $n)
                    break;
            }
            else {
                $mtc_obj = pg_fetch_object($mtc_pg,0);
            }

            /*
             * games management
             */
            $gam_sql = sprintf("INSERT INTO %sbin5_games (mcode, tstamp, act, asta_pnt, pnt, asta_win, friend, mazzo, mult)
                                               VALUES (%d, to_timestamp(%d), %d, %d, %d, %d, %d, %d, %d) RETURNING *;",
                               $G_dbpfx, $mtc_obj->code, $date, $action,
                               $table->old_asta_pnt, $table->old_pnt,
                               $table->old_asta_win,
                               $table->old_friend,
                               $table->old_mazzo, $table->old_mult);
            if (($gam_pg  = $this->query($gam_sql)) == FALSE || pg_affected_rows($gam_pg) != 1) {
                log_crit(sprintf("bin5_points_save: failed at insert game [%s]", $gam_sql));
                break;
            }

            $gam_obj = pg_fetch_object($gam_pg,0);

            /*
             * points management
             */
            for ($i = 0 ; $i < $n ; $i++) {
                /* put points */
                $pts_sql = sprintf("INSERT INTO %sbin5_points (gcode, ucode, pts)
                                               VALUES (%d, %d, %d);",
                                   $G_dbpfx, $gam_obj->code, $ucodes[$i], $pts[$i]);
                if (($pts_pg  = $this->query($pts_sql)) == FALSE || pg_affected_rows($pts_pg) != 1) {
                    log_crit(sprintf("bin5_points_save: failed at insert point [%s]", $pts_sql));
                    break;
                }
            }
            if ($i < $n)
                break;

            if ($this->query("COMMIT") == FALSE) {
                break;
            }

            $is_trans = FALSE;

            $ret =  TRUE;
        } while (0);

        if ($is_trans)
            $this->query("ROLLBACK");

        return $ret;
    }

} // End class BriskDB

class LoginDBOld
{
    var $item;
    var $item_n;

    function LoginDBOld($filename)
    {
        GLOBAL $DOCUMENT_ROOT;
        log_main("LoginDBOld create:start");

        if (file_exists("$DOCUMENT_ROOT/Etc/".$filename)) {
            require("$DOCUMENT_ROOT/Etc/".$filename);
        }
        else {
            return (FALSE);
        }
        $this->item_n = count($this->item);
        log_main("LoginDBOld create:end");
    }

    function count()
    {
        return ($this->item_n);
    }

} // End class LoginDBOld

?>
