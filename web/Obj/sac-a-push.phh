<?php
/*
 *  brisk - spush/sac-a-push.phh
 *
 *  Copyright (C) 2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */

define('SITE_PREFIX', '/brisk/');
define('SITE_PREFIX_LEN', 7);

function spu_process_info($stream_info, $method, &$header, &$get, &$post, &$cookie)
{
    $check_post = FALSE;
    $header = array();
    $get = array();
    $post = array();
    foreach(preg_split("/(\r?\n)/", $stream_info) as $line) {
        // printf("LINE: [%s]\n", $line);
        if ($check_post) {
            if (!isset($header['The-Request'])) {
                return FALSE;
            }
            $req = explode(" ", $header['The-Request']);
            $method = $req[0];

            if (isset($header['Cookie'])) {
                $cookies = explode(";", $header['Cookie']);
                for ($i = 0 ; $i < count($cookies) ; $i++) {
                    $nameval = explode("=", trim($cookies[$i]));
                    if (count($nameval) != 2) {
                        printf("WARNING: malformat cookie element [%s]\n", $cookies[$i]);
                        continue;
                    }
                    $cookie[$nameval[0]] = urldecode($nameval[1]);
                }
            }
            // GET params management
            $get_vars = explode('?', $req[1], 2);
            $path =   $get_vars[0];
            if (count($get_vars) > 1) {
                $a = explode('&', $get_vars[1]);
                printf("A COUNT: [%s] %d\n", $a[0], count($a));
                for ($i = 0 ; $i < count($a) ; $i++) {
                    $b = explode('=', $a[$i]);
                    $get[$b[0]] = urldecode($b[1]);
                }
            }
            // POST params management
            if ($req[0] == 'POST') {
                if ($header['Content-Type'] != 'application/x-www-form-urlencoded' 
                    || !isset($header['Content-Length'])) {
                    return FALSE;
                }
                $post_len = mb_strlen($line, "latin1");
                $a = explode('&', $line);
                for ($i = 0 ; $i < count($a) ; $i++) {
                    $b = explode('=', $a[$i]);
                    $post[$b[0]] = urldecode($b[1]);
                }
                printf("INFO: postlen: %d\n", $post_len);
            }
            break;
        }
        if ($line == "") {
            $check_post = TRUE;
            continue;
        }
        $split = explode(":", $line, 2);
        $header[$split[0]] = $split[1];        
    }
    return $path;
}

function gpcs_var($name, $get, $post, $cookie)
{
    if (isset($GLOBALS[$name])) 
        return FALSE;
    else if (isset($cookie[$name])) 
        return ($cookie[$name]);
    else if (isset($post[$name])) 
        return ($post[$name]);
    else if (isset($get[$name])) 
        return ($get[$name]);

    return FALSE;
}

function headers_render($header, $len)
{
    $cookies = "";

    if (isset($header['cookies'])) {
        $cookies = $header['cookies']->render();
        unset($header['cookies']);
    }
    if (isset($header['Location'])) {
        $s = sprintf("HTTP/1.1 302 OK\r\n%sLocation: %s\r\n", $cookies, $header['Location']);
    }
    else {
        $s = "HTTP/1.1 200 OK\r\n";

        if (!isset($header['Date']))
            $s .= sprintf("Date: %s\r\n", date(DATE_RFC822));
        if (!isset($header['Connection']))
            $s .= "Connection: close\r\n";
        if (!isset($header['Content-Type']))
            $s .= "Content-Type: text/html\r\n";
        foreach($header as $key => $value) {
            $s .= sprintf("%s: %s\r\n", $key, $value);
        }
        if ($len >= 0) {
            $s .= sprintf("Content-Length: %d\r\n", $len);
        }
        else {
            $s .= "Cache-Control: no-cache, must-revalidate\r\n";
            $s .= "Expires: Mon, 26 Jul 1997 05:00:00 GMT\r\n";
            if (!isset($header['Content-Encoding'])) {
                $s .= "Content-Encoding: chunked\r\n";
            }
            $s .= "Transfer-Encoding: chunked\r\n";
        }
        $s .= $cookies;
    }
    $s .= "\r\n";

    return ($s);
}

/*
 *  Caching system using ob php system to cache old style pages
 *  to a var and than send it with more calm
 */

function shutta()
{
  log_rd2("SHUTTA [".connection_status()."] !");
}

register_shutdown_function('shutta');

/*
 *  MAIN
 */

function chunked_content($zls, $content)
{
    if ($zls) {
        $cont_comp = $zls->compress_chunk($content);
    }
    else {
        $cont_comp = $content;
    }
    $cont_comp_l = mb_strlen($cont_comp, "ASCII");
    printf("CHUNK: [%s]\n", $content);

    return (sprintf("%X\r\n", $cont_comp_l).$cont_comp."\r\n");
}

function chunked_fini()
{
    return sprintf("0\r\n");
}

function get_encoding($header)
{
    $enc = "plain";
    if (isset($header['Accept-Encoding'])) {
        $acc = explode(',', $header['Accept-Encoding']);

        if (array_search('gzip', $acc) !== FALSE) {
            $enc = 'gzip';
        }
        else if (array_search('deflate', $acc) !== FALSE) {
            $enc = 'deflate';
        }
    }

    return ($enc);
}

class Cookie {
    var $attr;
    // Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01-Jan-1970 00:00:01 GMT; Path=/; Domain=.foo.com; HttpOnly
    // string $name  [, string $value  [, int $expire = 0  [, string $path  [, string $domain  [, bool $secure = false  [, bool $httponly = false  ]]]]]] )
    function Cookie()
    {
        $this->attr = array();
    }

    static function create($name)
    {
        $thiz = new Cookie();

        $thiz->attr[$name] = "";

        $argc = func_num_args();
        for ($i = 1 ; $i < $argc ; $i++) {
            $arg = func_get_arg($i);
            switch ($i) {
            case 1:
                $thiz->attr[$name] = urlencode($arg);
                break;
            case 2:
                $thiz->attr['Expires'] = gmdate('D, d M Y H:i:s \G\M\T', $arg); // RFC 1211 format
                break;
            case 3:
                $thiz->attr['Path'] = $arg;
                break;
            case 4:
                $thiz->attr['Domain'] = $arg;
                break;
            case 5:
                if ($arg == TRUE) {
                    $thiz->attr['Secure'] = NULL;
                }
                break;
            case 6:
                if ($arg == TRUE) {
                    $thiz->attr['HttpOnly'] = NULL;
                }
                break;
            default:
                return FALSE;
            }
        }

        return $thiz;
    }

    function render()
    {
        $r = "Set-Cookie: ";
        $isfirst = TRUE;

        foreach ($this->attr as $k => $v) {
            if ($v == NULL) {
                $r .= sprintf("%s%s", ($isfirst ? "" : "; "), $k);
            }
            else {
                $r .= sprintf("%s%s=%s", ($isfirst ? "" : "; "), $k, $v);
            }
            $isfirst = FALSE;
        }
        $r .= "\r\n";

        return $r;
    }
}

class Cookies {
    var $cookies;

    function Cookies()
    {
        $this->cookies = array();
    }

    function add($name)
    {
        if (($cookie = call_user_func_array("Cookie::create", func_get_args())) == FALSE)
            return (FALSE);

        array_push($this->cookies, $cookie);

        return (TRUE);
    }

    function render()
    {
        $r = "";
        foreach ($this->cookies as $cookie) {
            $r .= $cookie->render();
        }

        return ($r);
    }
}


class Sac_a_push {
    static $fixed_fd = 2;
    
    var $file_socket;
    var $unix_socket;
    var $socks;
    var $s2u;
    var $pages_flush;

    var $list;
    var $in;

    var $debug;
    var $blocking_mode;

    var $app;

    var $curtime;

    var $rndstr;
    var $main_loop;

    function Sac_a_push()
    {
    }

    // Sac_a_push::create("/tmp/brisk.sock", 0, 0

    static function create(&$app, $sockname, $debug, $blocking_mode)
    {        
        $thiz = new Sac_a_push();
        
        $thiz->app = $app;
        $thiz->file_socket = $sockname;
        $thiz->unix_socket = "unix://$sockname";
        $thiz->debug = $debug;
        $thiz->socks = array();
        $thiz->s2u  = array();
        $thiz->pages_flush = array();

        $thiz->blocking_mode = 0; // 0 for non-blocking

        $thiz->rndstr = "";
        for ($i = 0 ; $i < 4096 ; $i++) {
            if (($i % 128) == 0)
                $thiz->rndstr .= "\n";
            else
                $thiz->rndstr .= chr(mt_rand(65, 90));
        }
        
        if (file_exists($thiz->file_socket)) {
            unlink($thiz->file_socket);
        }
    
        $old_umask = umask(0);
        if (($thiz->list = stream_socket_server($thiz->unix_socket, $err, $errs)) === FALSE) {
            return (FALSE);
        }
        umask($old_umask);
        stream_set_blocking($thiz->list, $thiz->blocking_mode); # Set the stream to non-blocking

        if (($thiz->in = fopen("php://stdin", "r")) === FALSE) {
            return(FALSE);
        }

        $thiz->main_loop = FALSE;

        return ($thiz);
    }

    function socks_set($sock, $user)
    {
        $id = intval($sock);

        $this->s2u[$id]   = $user;
        $this->socks[$id] = $sock;
    }

    function socks_unset($sock)
    {
        $id = intval($sock);

        unset($this->s2u[$id]);
        unset($this->socks[$id]);
    }

    function pgflush_try_add($enc, &$new_socket, $tout, $header_out, $content)
    {
        $pgflush = new PageFlush($new_socket, $enc, $this->curtime, $tout, $header_out, $content);

        if ($pgflush->try_flush($this->curtime) == FALSE) {
            // Add $pgflush to the pgflush array
            $this->pgflush_add($pgflush);
        }
    }

    function pgflush_add($pgflush)
    {
        array_push($this->pages_flush, $pgflush);
    }

    function garbage_manager($force)
    {
        $this->app->garbage_manager($force);

        foreach ($this->socks as $k => $sock) {
            if ($this->s2u[intval($sock)]->sess == '') {
                if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                    $this->s2u[intval($sock)]->rd_socket_set(NULL);
                }
                unset($this->socks[intval($sock)]);
                unset($this->s2u[intval($sock)]);
                fclose($sock);
                printf("CLOSE ON GARBAGE MANAGER\n");
            }
        }
    }

    function run()
    {
        GLOBAL $DOCUMENT_ROOT, $HTTP_HOST, $G_with_splash;

        if ($this->main_loop) {
            return (FALSE);
        }
        
        $this->main_loop = TRUE;
        
        while ($this->main_loop) {
            $this->curtime = time();
            printf("IN LOOP: Current opened: %d  pages_flush: %d - ", count($this->socks), count($this->pages_flush));
            
            /* Prepare the read array */
            /* // when we manage it ... */
            /* if ($shutdown)  */
            /*     $read   = array_merge(array("$in" => $in), $socks); */
            /* else */
            $read   = array_merge(array(intval($this->list) => $this->list, intval($this->in) => $this->in),
                                  $this->socks);
            
            if ($this->debug > 1) {
                printf("PRE_SELECT\n");
                print_r($read);
            }
            $write  = NULL;
            $except = NULL;
            $num_changed_sockets = stream_select($read, $write, $except, 0, 500000);
        
            if ($num_changed_sockets == 0) {
                printf(" no data in 5 secs, splash [%d]\n", $G_with_splash);
            } 
            else if ($num_changed_sockets > 0) {
                printf("num sock %d num_of_socket: %d\n", $num_changed_sockets, count($read));
                if ($this->debug > 1) {
                    print_r($read);
                }
                /* At least at one of the sockets something interesting happened */
                foreach ($read as $i => $sock) {
                    /* is_resource check is required because there is the possibility that
                       during new request an old connection is closed */
                    if (!is_resource($sock)) {
                        continue;
                    }
                    if ($sock === $this->list) {
                        printf("NUOVA CONNEX\n");
                        if (($new_unix = stream_socket_accept($this->list)) == FALSE) {
                            printf("SOCKET_ACCEPT FAILED\n");
                            continue;
                        }
                        $stream_info = "";
                        $method      = "";
                        $get         = array();
                        $post        = array();
                        $cookie      = array();
                        if (($new_socket = ancillary_getstream($new_unix, $stream_info)) !== FALSE) {
                            printf("NEW_SOCKET: %d\n", intval($new_socket));
                            stream_set_blocking($new_socket, $this->blocking_mode); // Set the stream to non-blocking
                            printf("RECEIVED HEADER:\n%s", $stream_info);
                            $path = spu_process_info($stream_info, $method, $header, $get, $post, $cookie);
                            printf("PATH: [%s]\n", $path);
                            printf("M: %s\nHEADER:\n", $method);
                            print_r($header);
                            printf("GET:\n");
                            print_r($get);
                            printf("POST:\n");
                            print_r($post);
                            printf("COOKIE:\n");
                            print_r($cookie);
                            $addr = stream_socket_get_name($new_socket, TRUE);
                            $header_out = array();

                            $subs = SITE_PREFIX."briskin5/";
                            $subs_l = strlen($subs);
                            $rret = FALSE;
                            if (!strncmp($path, SITE_PREFIX, SITE_PREFIX_LEN)) {
                                $rret = $this->app->request_mgr($this, $header, $header_out, $new_socket, substr($path, SITE_PREFIX_LEN), $addr, $get, $post, $cookie);
                            }
                            if ($rret == FALSE) { 
                                // FIXME: manage 404 !!!
                                printf("TODO: fix unknown page\n");
                            }
                            printf("number of sockets after %d\n", count($this->socks));
                        }
                        else {
                            printf("WARNING: ancillary_getstream failed\n");
                        }
                    }
                    else {
                        $buf = fread($sock, 512);
                        // if socket is closed
                        if ($buf == FALSE || strlen($buf) == 0) {
                            if ($buf == FALSE) {
                                printf("ERROR READING\n");
                            }
                            if ($sock === $this->list) {
                                printf("Arrivati %d bytes da list\n", strlen($buf));
                                exit(21);
                            }
                            else if ($sock === $this->in) {
                                printf("Arrivati %d bytes da stdin\n", strlen($buf));
                                exit(22);
                            }
                            else {
                                // $user_a[$s2u[intval($sock)]]->disable();
                                if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                                    $this->s2u[intval($sock)]->rd_socket_set(NULL);
                                }
                                unset($this->socks[intval($sock)]);
                                unset($this->s2u[intval($sock)]);
                            }
                            fclose($sock);
                            printf("CLOSE ON READ\n");

                            if ($this->debug > 1) {
                                printf("post unset\n");
                                print_r($this->socks);
                            }
                        }
                        else {
                            if ($this->debug > 1) {
                                print_r($read);
                            }
                            if ($sock === $this->list) {
                                printf("Arrivati %d bytes da list\n", strlen($buf));
                            }
                            else if ($sock === $this->in) {
                                printf("Arrivati %d bytes da stdin\n", strlen($buf));
                                $line = trim($buf);
                                if ($line == "reload") {
                                    require("$DOCUMENT_ROOT/Etc/".BRISK_CONF);
                                }
                                else if ($line == "shutdown") {
                                    if ($this->app->dump_data()) {
                                        exit(0);
                                    }
                                    else {
                                        exit(1);
                                    }
                                }
                            }
                            else {
                                $key = array_search("$sock", $this->socks);
                                printf("Arrivati %d bytes dalla socket n. %d\n", strlen($buf), $key);
                            }
                        }
                    }
                }
            }

            $this->garbage_manager(FALSE);

            /* manage unfinished pages */
            foreach ($this->pages_flush as $k => $pgflush) {
                if ($pgflush->try_flush($this->curtime) == TRUE) {
                    unset($this->pages_flush[$k]);
                }
            }
            
            /*
               $response:                        raw stream data not sent
               $content:                         html consistent data (<script bla bla>)
               $user->stream_keepalive($w_ping)  ping srv->cli OR srv->cli + cli->srv if $w_ping == TRUE
            */

            /* manage open streaming */
            foreach ($this->socks as $k => $sock) {
                if (isset($this->s2u[intval($sock)])) {
                    $user = $this->s2u[intval($sock)];
                    $response = $user->rd_cache_get();
                    $do_ping = FALSE;
                    if (($this->curtime - $user->lacc) > (EXPIRE_TIME_RD / 3)) {
                        $do_ping = TRUE;
                    }
                    else {
                        $user->ping_req = FALSE;
                    }

                    if ($response == "") {
                        $content = "";
                        $user->stream_main($content, $get, $post, $cookie);
                        printf("[%s] [%d] [%d]\n", $user->name, $user->lacc, $this->curtime);
                        if ($do_ping && $user->ping_req == FALSE) {
                            $content .= $user->stream_keepalive(TRUE);
                            $user->ping_req = TRUE;
                        }
                        else if ($content == "" && $user->rd_kalive_is_expired($this->curtime)) {
                            $content = $user->stream_keepalive(FALSE);
                        }
                        if ($content != "") {
                            $response = chunked_content($user->rd_zls_get(), $content);
                        }
                    }
                    
                    if ($response != "") {
                        // echo "SPIA: [".substr($response, 0, 60)."...]\n";
                        echo "SPIA: [".$response."]\n";
                        $response_l = mb_strlen($response, "ASCII");
                        $wret = @fwrite($sock, $response);
                        if ($wret < $response_l) {
                            printf("TROUBLE WITH FWRITE: %d\n", $wret);
                            $user->rd_cache_set(mb_substr($response, $wret, $response_l - $wret, "ASCII"));
                        }
                        else {
                            $user->rd_cache_set("");
                        }
                        fflush($sock);
                        $user->rd_kalive_reset($this->curtime);
                    }
                    
                    // close socket after a while to prevent client memory consumption
                    if ($user->rd_endtime_is_expired($this->curtime)) {
                        if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                            $this->s2u[intval($sock)]->rd_socket_set(NULL);
                        }
                        unset($this->socks[intval($sock)]);
                        unset($this->s2u[intval($sock)]);
                        fclose($sock);
                        printf("CLOSE ON LOOP\n");
                    }
                }
            }  // foreach ($this->socks...
            printf("\n");
        }  // while (...
    }  // function run(...
}

?>
