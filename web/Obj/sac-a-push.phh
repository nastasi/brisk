<?php
/*
 *  brisk - Obj/sac-a-push.phh
 *
 *  Copyright (C) 2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */

define('SITE_PREFIX', '/brisk/');
define('SITE_PREFIX_LEN', 7);

declare(ticks = 1);

function global_dump()
{
    GLOBAL $G_alarm_passwd, $G_black_list, $G_btrace_pref_sub, $G_dbauth;
    GLOBAL $G_dbpfx, $G_donors_all, $G_donors_cur, $G_is_local, $G_lang;
    GLOBAL $G_poll_entries, $G_poll_name, $G_poll_title, $G_proxy_white_list;
    GLOBAL $G_room_roadmap, $G_shutdown, $G_sidebanner, $G_sidebanner2;
    GLOBAL $G_splash_content, $G_splash_contents, $G_splash_cont_idx;
    GLOBAL $G_splash_h, $G_splash_idx, $G_splash_interval, $G_splash_timeout;
    GLOBAL $G_splash_w, $G_topbanner, $G_with_donors, $G_with_poll;
    GLOBAL $G_with_sidebanner, $G_with_sidebanner2, $G_with_splash;
    GLOBAL $G_with_topbanner;

    fprintf(STDERR, "G_alarm_passwd = [%s]\n", print_r($G_alarm_passwd, TRUE));
    fprintf(STDERR, "G_black_list = [%s]\n", print_r($G_black_list, TRUE));
    fprintf(STDERR, "G_btrace_pref_sub = [%s]\n", print_r($G_btrace_pref_sub, TRUE));
    fprintf(STDERR, "G_dbauth = [%s]\n", print_r($G_dbauth, TRUE));
    fprintf(STDERR, "G_dbpfx = [%s]\n", print_r($G_dbpfx, TRUE));
    fprintf(STDERR, "G_donors_all = [%s]\n", print_r($G_donors_all, TRUE));
    fprintf(STDERR, "G_donors_cur = [%s]\n", print_r($G_donors_cur, TRUE));
    fprintf(STDERR, "G_is_local = [%s]\n", print_r($G_is_local, TRUE));
    fprintf(STDERR, "G_lang = [%s]\n", print_r($G_lang, TRUE));
    fprintf(STDERR, "G_poll_entries = [%s]\n", print_r($G_poll_entries, TRUE));
    fprintf(STDERR, "G_poll_name = [%s]\n", print_r($G_poll_name, TRUE));
    fprintf(STDERR, "G_poll_title = [%s]\n", print_r($G_poll_title, TRUE));
    fprintf(STDERR, "G_proxy_white_list = [%s]\n", print_r($G_proxy_white_list, TRUE));
    fprintf(STDERR, "G_room_roadmap = [%s]\n", print_r($G_room_roadmap, TRUE));
    fprintf(STDERR, "G_shutdown = [%s]\n", print_r($G_shutdown, TRUE));
    fprintf(STDERR, "G_sidebanner = [%s]\n", print_r($G_sidebanner, TRUE));
    fprintf(STDERR, "G_sidebanner2 = [%s]\n", print_r($G_sidebanner2, TRUE));
    fprintf(STDERR, "G_splash_content = [%s]\n", print_r($G_splash_content, TRUE));
    fprintf(STDERR, "G_splash_contents = [%s]\n", print_r($G_splash_contents, TRUE));
    fprintf(STDERR, "G_splash_cont_idx = [%s]\n", print_r($G_splash_cont_idx, TRUE));
    fprintf(STDERR, "G_splash_h = [%s]\n", print_r($G_splash_h, TRUE));
    fprintf(STDERR, "G_splash_idx = [%s]\n", print_r($G_splash_idx, TRUE));
    fprintf(STDERR, "G_splash_interval = [%s]\n", print_r($G_splash_interval, TRUE));
    fprintf(STDERR, "G_splash_timeout = [%s]\n", print_r($G_splash_timeout, TRUE));
    fprintf(STDERR, "G_splash_w = [%s]\n", print_r($G_splash_w, TRUE));
    fprintf(STDERR, "G_topbanner = [%s]\n", print_r($G_topbanner, TRUE));
    fprintf(STDERR, "G_with_donors = [%s]\n", print_r($G_with_donors, TRUE));
    fprintf(STDERR, "G_with_poll = [%s]\n", print_r($G_with_poll, TRUE));
    fprintf(STDERR, "G_with_sidebanner = [%s]\n", print_r($G_with_sidebanner, TRUE));
    fprintf(STDERR, "G_with_sidebanner2 = [%s]\n", print_r($G_with_sidebanner2, TRUE));
    fprintf(STDERR, "G_with_splash = [%s]\n", print_r($G_with_splash, TRUE));
    fprintf(STDERR, "G_with_topbanner = [%s]\n", print_r($G_with_topbanner, TRUE));
}

function pid_save()
{
    $pid = getmypid();
    $fname = LEGAL_PATH."/brisk.pid";

    if (file_exists($fname)) {
        log_crit("WARN: brisk.pid already exists");
    }
    file_put_contents($fname, sprintf("%d\n", $pid));
}

function pid_remove()
{
    $fname = LEGAL_PATH."/brisk.pid";

    if (file_exists($fname)) {
        unlink($fname);
    }
}

function spu_process_info($stream_info, $method, &$header, &$get, &$post, &$cookie)
{
    $check_post = FALSE;
    $header = array();
    $get = array();
    $post = array();
    foreach(preg_split("/(\r?\n)/", $stream_info) as $line) {
        // printf("LINE: [%s]\n", $line);
        if ($check_post) {
            if (!isset($header['The-Request'])) {
                return FALSE;
            }
            $req = explode(" ", $header['The-Request']);
            $method = $req[0];

            if (isset($header['Cookie'])) {
                $cookies = explode(";", $header['Cookie']);
                for ($i = 0 ; $i < count($cookies) ; $i++) {
                    $nameval = explode("=", trim($cookies[$i]));
                    if (count($nameval) != 2) {
                        printf("WARNING: malformat cookie element [%s]\n", $cookies[$i]);
                        continue;
                    }
                    $cookie[$nameval[0]] = urldecode($nameval[1]);
                }
            }
            // GET params management
            $get_vars = explode('?', $req[1], 2);
            $path = $get_vars[0];
            if (count($get_vars) > 1) {
                $a = explode('&', $get_vars[1]);
                printf("A COUNT: [%s] %d\n", $a[0], count($a));
                for ($i = 0 ; $i < count($a) ; $i++) {
                    $b = explode('=', $a[$i]);
                    $get[$b[0]] = urldecode($b[1]);
                }
            }
            // POST params management
            if ($req[0] == 'POST') {
                $conttype_all = explode(";", $header['Content-Type']);
                $header['Content-Type'] = $conttype_all[0];
                // $path_all[1-] other things like charset and so on

                if ($header['Content-Type'] != 'application/x-www-form-urlencoded' 
                    || !isset($header['Content-Length'])) {
                    return FALSE;
                }
                $post_len = mb_strlen($line, "ASCII");
                $a = explode('&', $line);
                for ($i = 0 ; $i < count($a) ; $i++) {
                    $b = explode('=', $a[$i]);
                    $post[$b[0]] = urldecode($b[1]);
                }
                printf("INFO: postlen: %d\n", $post_len);
            }
            break;
        }
        if ($line == "") {
            $check_post = TRUE;
            continue;
        }
        $split = explode(":", $line, 2);
        $header[$split[0]] = $split[1];        
    }
    return $path;
}

function gpcs_var($name, $get, $post, $cookie)
{
    if (isset($GLOBALS[$name])) 
        return FALSE;
    else if (isset($cookie[$name])) 
        return ($cookie[$name]);
    else if (isset($post[$name])) 
        return ($post[$name]);
    else if (isset($get[$name])) 
        return ($get[$name]);

    return FALSE;
}

function headers_render($header, $len)
{
    $cookies = "";

    if (isset($header['cookies'])) {
        $cookies = $header['cookies']->render();
        unset($header['cookies']);
    }
    if (isset($header['Location'])) {
        $s = sprintf("HTTP/1.1 302 OK\r\n%sLocation: %s\r\n", $cookies, $header['Location']);
    }
    else {
        $s = "HTTP/1.1 200 OK\r\n";

        if (!isset($header['Date']))
            $s .= sprintf("Date: %s\r\n", date(DATE_RFC822));
        if (!isset($header['Connection']))
            $s .= "Connection: close\r\n";
        if (!isset($header['Content-Type']))
            $s .= "Content-Type: text/html\r\n";
        foreach($header as $key => $value) {
            $s .= sprintf("%s: %s\r\n", $key, $value);
        }
        if ($len >= 0) {
            $s .= sprintf("Content-Length: %d\r\n", $len);
        }
        else {
            $s .= "Cache-Control: no-cache, must-revalidate\r\n";
            $s .= "Expires: Mon, 26 Jul 1997 05:00:00 GMT\r\n";
            if (!isset($header['Content-Encoding'])) {
                $s .= "Content-Encoding: chunked\r\n";
            }
            $s .= "Transfer-Encoding: chunked\r\n";
        }
        $s .= $cookies;
    }
    $s .= "\r\n";

    return ($s);
}

/*
 *  Caching system using ob php system to cache old style pages
 *  to a var and than send it with more calm
 */

function shutta()
{
  log_rd2("SHUTTA [".connection_status()."] !");
}

register_shutdown_function('shutta');

/*
 *  MAIN
 */

function chunked_content($zls, $content)
{
    if ($zls) {
        $cont_comp = $zls->compress_chunk($content);
    }
    else {
        $cont_comp = $content;
    }
    $cont_comp_l = mb_strlen($cont_comp, "ASCII");
    printf("CHUNK: [%s]\n", $content);

    return (sprintf("%X\r\n", $cont_comp_l).$cont_comp."\r\n");
}

function chunked_fini()
{
    return sprintf("0\r\n");
}

function get_encoding($header)
{
    $enc = "plain";
    if (isset($header['Accept-Encoding'])) {
        $acc = explode(',', $header['Accept-Encoding']);

        if (array_search('gzip', $acc) !== FALSE) {
            $enc = 'gzip';
        }
        else if (array_search('deflate', $acc) !== FALSE) {
            $enc = 'deflate';
        }
    }

    return ($enc);
}

class Cookie {
    var $attr;
    // Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01-Jan-1970 00:00:01 GMT; Path=/; Domain=.foo.com; HttpOnly
    // string $name  [, string $value  [, int $expire = 0  [, string $path  [, string $domain  [, bool $secure = false  [, bool $httponly = false  ]]]]]] )
    function Cookie()
    {
        $this->attr = array();
    }

    static function create($name)
    {
        $thiz = new Cookie();

        $thiz->attr[$name] = "";

        $argc = func_num_args();
        for ($i = 1 ; $i < $argc ; $i++) {
            $arg = func_get_arg($i);
            switch ($i) {
            case 1:
                $thiz->attr[$name] = urlencode($arg);
                break;
            case 2:
                $thiz->attr['Expires'] = gmdate('D, d M Y H:i:s \G\M\T', $arg); // RFC 1211 format
                break;
            case 3:
                $thiz->attr['Path'] = $arg;
                break;
            case 4:
                $thiz->attr['Domain'] = $arg;
                break;
            case 5:
                if ($arg == TRUE) {
                    $thiz->attr['Secure'] = NULL;
                }
                break;
            case 6:
                if ($arg == TRUE) {
                    $thiz->attr['HttpOnly'] = NULL;
                }
                break;
            default:
                return FALSE;
            }
        }

        return $thiz;
    }

    function render()
    {
        $r = "Set-Cookie: ";
        $isfirst = TRUE;

        foreach ($this->attr as $k => $v) {
            if ($v == NULL) {
                $r .= sprintf("%s%s", ($isfirst ? "" : "; "), $k);
            }
            else {
                $r .= sprintf("%s%s=%s", ($isfirst ? "" : "; "), $k, $v);
            }
            $isfirst = FALSE;
        }
        $r .= "\r\n";

        return $r;
    }
}

class Cookies {
    var $cookies;

    function Cookies()
    {
        $this->cookies = array();
    }

    function add($name)
    {
        if (($cookie = call_user_func_array("Cookie::create", func_get_args())) == FALSE)
            return (FALSE);

        array_push($this->cookies, $cookie);

        return (TRUE);
    }

    function render()
    {
        $r = "";
        foreach ($this->cookies as $cookie) {
            $r .= $cookie->render();
        }

        return ($r);
    }
}


class Sac_a_push {
    // maybe fixed_fd is unuseful
    static $fixed_fd = 3;
    static $cnt_master = NULL;
    static $cnt_slave  = NULL;
    
    var $file_socket;
    var $unix_socket;
    var $socks;
    var $s2u;
    var $pending_pages;

    var $list;
    var $in;

    var $debug;
    var $blocking_mode;

    var $app;

    var $curtime;

    var $rndstr;
    var $main_loop;

    function Sac_a_push()
    {
    }

    function sig_handler($sig)
    {
        switch ($sig) {
        case SIGINT:
            exit(1);
            break;
        case SIGTERM:
            if (static::$cnt_master != NULL) {
                    fwrite(static::$cnt_master, "\nshutdown\n");
                    fflush(static::$cnt_master);
            }
            else {
                exit(1);
            }
            break;
        case SIGHUP: 
            if (static::$cnt_master != NULL) {
                fwrite(static::$cnt_master, "\nreload\n");
                fflush(static::$cnt_master);
            }
            break;
        }
    }

    static function create(&$app, $sockname, $debug, $blocking_mode)
    {        
        $thiz = new Sac_a_push();
        
        $thiz->app = $app;
        $thiz->file_socket = $sockname;
        $thiz->unix_socket = "unix://$sockname";
        $thiz->debug = $debug;
        $thiz->socks = array();
        $thiz->s2u  = array();
        $thiz->pending_pages = array();

        // create a couple of sockets for control management
        if (($sockpair = stream_socket_pair(STREAM_PF_UNIX, STREAM_SOCK_STREAM,
                                            STREAM_IPPROTO_IP)) == FALSE) {
            return FALSE;
        }
        static::$cnt_master = $sockpair[0];
        static::$cnt_slave  = $sockpair[1];

        pcntl_signal(SIGTERM, array("Sac_a_push", "sig_handler"));
        pcntl_signal(SIGINT, array("Sac_a_push", "sig_handler"));
        pcntl_signal(SIGHUP, array("Sac_a_push", "sig_handler"));

        $thiz->blocking_mode = 0; // 0 for non-blocking

        $thiz->rndstr = "";
        for ($i = 0 ; $i < 4096 ; $i++) {
            if (($i % 128) == 0)
                $thiz->rndstr .= " ";
            else
                $thiz->rndstr .= chr(mt_rand(65, 90));
        }
        
        if (file_exists($thiz->file_socket)) {
            unlink($thiz->file_socket);
        }
    
        $old_umask = umask(0);
        if (($thiz->list = stream_socket_server($thiz->unix_socket, $err, $errs)) === FALSE) {
            return (FALSE);
        }
        umask($old_umask);
        stream_set_blocking($thiz->list, $thiz->blocking_mode); # Set the stream to non-blocking

        if (($thiz->in = fopen("php://stdin", "r")) === FALSE) {
            return(FALSE);
        }

        $thiz->main_loop = FALSE;

        return ($thiz);
    }

    function socks_set($sock, $user)
    {
        $id = intval($sock);

        $this->s2u[$id]   = $user;
        $this->socks[$id] = $sock;
    }

    function socks_unset($sock)
    {
        $id = intval($sock);

        unset($this->s2u[$id]);
        unset($this->socks[$id]);
    }

    function pendpage_try_addflush(&$new_socket, $tout, $enc, $header_out, $content)
    {
        $pendpage = PendingPage::pendingpage_flushing($new_socket, $this->curtime, $tout, $enc, $header_out, $content);

        if ($pendpage->try_flush($this->curtime) == FALSE) {
            // Add $pendpage to the pendpage array
            $this->pendpage_add($pendpage);
        }
    }

    function pendpage_add($pendpage)
    {
        array_push($this->pending_pages, $pendpage);
    }

    function garbage_manager($force)
    {
        $this->app->garbage_manager($force);

        foreach ($this->socks as $k => $sock) {
            if ($this->s2u[intval($sock)]->sess == '') {
                if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                    $this->s2u[intval($sock)]->rd_socket_set(NULL);
                }
                unset($this->socks[intval($sock)]);
                unset($this->s2u[intval($sock)]);
                fclose($sock);
                printf("CLOSE ON GARBAGE MANAGER\n");
            }
        }
    }

    function run()
    {
        GLOBAL $DOCUMENT_ROOT, $HTTP_HOST;

        GLOBAL $G_alarm_passwd, $G_black_list, $G_btrace_pref_sub, $G_dbauth;
        GLOBAL $G_dbpfx, $G_donors_all, $G_donors_cur, $G_is_local, $G_lang;
        GLOBAL $G_poll_entries, $G_poll_name, $G_poll_title, $G_proxy_white_list;
        GLOBAL $G_room_roadmap, $G_shutdown, $G_sidebanner, $G_sidebanner2;
        GLOBAL $G_splash_content, $G_splash_contents, $G_splash_cont_idx;
        GLOBAL $G_splash_h, $G_splash_idx, $G_splash_interval, $G_splash_timeout;
        GLOBAL $G_splash_w, $G_topbanner, $G_with_donors, $G_with_poll;
        GLOBAL $G_with_sidebanner, $G_with_sidebanner2, $G_with_splash;
        GLOBAL $G_with_topbanner;

        if ($this->main_loop) {
            return (FALSE);
        }
        
        $this->main_loop = TRUE;
        
        while ($this->main_loop) {
            $this->curtime = time();
            printf("IN LOOP: Current opened: %d  pending_pages: %d - ", count($this->socks), count($this->pending_pages));
            
            /* Prepare the read array */
            /* // when we manage it ... */
            /* if ($shutdown)  */
            /*     $read   = array_merge(array("$in" => $in), $socks); */
            /* else */
            $read   = array_merge(array(intval($this->list) => $this->list, intval($this->in) => $this->in,
                                        intval(static::$cnt_slave) => static::$cnt_slave),
                                  $this->socks);
            
            if ($this->debug > 1) {
                printf("PRE_SELECT\n");
                print_r($read);
            }
            $write  = NULL;
            $except = NULL;
            $num_changed_sockets = @stream_select($read, $write, $except, 5, 500000);
        
            if ($num_changed_sockets == 0) {
                printf(" no data in 5 secs, splash [%d]\n", $G_with_splash);
            } 
            else if ($num_changed_sockets > 0) {
                printf("num sock %d num_of_socket: %d\n", $num_changed_sockets, count($read));
                if ($this->debug > 1) {
                    print_r($read);
                }
                /* At least at one of the sockets something interesting happened */
                foreach ($read as $i => $sock) {
                    /* is_resource check is required because there is the possibility that
                       during new request an old connection is closed */
                    if (!is_resource($sock)) {
                        continue;
                    }
                    if ($sock === $this->list) {
                        printf("NUOVA CONNEX\n");
                        if (($new_unix = stream_socket_accept($this->list)) == FALSE) {
                            printf("SOCKET_ACCEPT FAILED\n");
                            continue;
                        }
                        $stream_info = "";
                        $method      = "";
                        $get         = array();
                        $post        = array();
                        $cookie      = array();
                        if (($new_socket = ancillary_getstream($new_unix, $stream_info)) !== FALSE) {
                            printf("NEW_SOCKET: %d\n", intval($new_socket));
                            stream_set_blocking($new_socket, $this->blocking_mode); // Set the stream to non-blocking
                            printf("RECEIVED HEADER:\n%s", $stream_info);
                            $path = spu_process_info($stream_info, $method, $header, $get, $post, $cookie);
                            $addr = stream_socket_get_name($new_socket, TRUE);
                            printf("PATH: [%s]\n", $path);
                            printf("M: %s\nHEADER:\n", $method);
                            if ($method == "POST") {
                                // ADD PUSH INTO FD ARRAY AS WAITING DATA
                                // Passing all infos from spu_process_info as arguments:
                                //
                                // MAYBE: $stream_info,
                                // $method, $header, $get, $post, $cookie
                                // $s_a_p (this), $new_socket, substr($path, SITE_PREFIX_LEN),
                                // $addr
                            }
                            print_r($header);
                            printf("GET:\n");
                            print_r($get);
                            printf("POST:\n");
                            print_r($post);
                            printf("COOKIE:\n");
                            print_r($cookie);
                            $header_out = array();

                            // TODO: MOVE DOWN request_mgr to factorize new_sockets and POST closed
                            $rret = FALSE;
                            if (!strncmp($path, SITE_PREFIX, SITE_PREFIX_LEN)) {
                                $rret = $this->app->request_mgr($this, $header, $header_out, $new_socket, substr($path, SITE_PREFIX_LEN), $addr, $get, $post, $cookie);
                            }
                            if ($rret == FALSE) { 
                                // FIXME: manage 404 !!!
                                printf("TODO: fix unknown page\n");
                            }
                            printf("number of sockets after %d\n", count($this->socks));
                        }
                        else {
                            printf("WARNING: ancillary_getstream failed\n");
                        }
                    }
                    else {
                        $buf = fread($sock, 512);
                        // if socket is closed
                        if ($buf == FALSE || strlen($buf) == 0) {
                            // close socket case
                            if ($buf == FALSE) {
                                printf("ERROR READING\n");
                            }
                            if ($sock === $this->list) {
                                printf("Arrivati %d bytes da list\n", strlen($buf));
                                return(21);
                            }
                            else if ($sock === $this->in || $sock === static::$cnt_slave) {
                                printf("Arrivati %d bytes da stdin\n", strlen($buf));
                                return(22);
                            }
                            else {
                                // $user_a[$s2u[intval($sock)]]->disable();
                                if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                                    $this->s2u[intval($sock)]->rd_socket_set(NULL);
                                }
                                unset($this->socks[intval($sock)]);
                                unset($this->s2u[intval($sock)]);
                            }
                            fclose($sock);
                            printf("CLOSE ON READ\n");

                            if ($this->debug > 1) {
                                printf("post unset\n");
                                print_r($this->socks);
                            }
                        }
                        else {
                            if ($this->debug > 1) {
                                print_r($read);
                            }
                            if ($sock === $this->list) {
                                printf("Arrivati %d bytes da list\n", strlen($buf));
                            }
                            else if ($sock === $this->in || $sock === static::$cnt_slave) {
                                printf("Arrivati %d bytes da stdin\n", strlen($buf));
                                $line = trim($buf);
                                if ($line == "reload") {
                                    require("$DOCUMENT_ROOT/Etc/".BRISK_CONF);

                                    global_dump();
                                }
                                else if ($line == "shutdown") {
                                    if ($this->app->dump_data()) {
                                        return(0);
                                    }
                                    else {
                                        return(1);
                                    }
                                }
                            }
                            else {
                                $key = array_search("$sock", $this->socks);
                                printf("Arrivati %d bytes dalla socket n. %d\n", strlen($buf), $key);
                            }
                        }
                    }
                    // TODO: MOVE HERE request_mgr to factorize new_sockets and POST closed
                    // $rret = $this->app->request_mgr
                }
            }

            $this->garbage_manager(FALSE);

            /* manage unfinished pages */
            foreach ($this->pending_pages as $k => $pgflush) {
                // TODO: try_flush if exists in the class
                if ($pgflush->try_flush($this->curtime) == TRUE) {
                    unset($this->pending_pages[$k]);
                }
            }
            
            /*
               $response:                        raw stream data not sent
               $content:                         html consistent data (<script bla bla>)
               $user->stream_keepalive($w_ping)  ping srv->cli OR srv->cli + cli->srv if $w_ping == TRUE
            */

            /* manage open streaming */
            foreach ($this->socks as $k => $sock) {
                if (isset($this->s2u[intval($sock)])) {
                    $user = $this->s2u[intval($sock)];
                    $response = $user->rd_cache_get();
                    $do_ping = FALSE;
                    if (($this->curtime - $user->lacc) > (EXPIRE_TIME_RD / 3)) {
                        $do_ping = TRUE;
                    }
                    else {
                        $user->ping_req = FALSE;
                    }

                    if ($response == "") {
                        $content = "";
                        $user->stream_main($content, $get, $post, $cookie);
                        printf("[%s] [%d] [%d]\n", $user->name, $user->lacc, $this->curtime);
                        if ($do_ping && $user->ping_req == FALSE) {
                            $content .= $user->stream_keepalive(TRUE);
                            $user->ping_req = TRUE;
                        }
                        else if ($content == "" && $user->rd_kalive_is_expired($this->curtime)) {
                            $content = $user->stream_keepalive(FALSE);
                        }
                        if ($content != "") {
                            $response = chunked_content($user->rd_zls_get(), $content);
                        }
                    }
                    
                    if ($response != "") {
                        // echo "SPIA: [".substr($response, 0, 60)."...]\n";
                        echo "SPIA: [".$response."]\n";
                        $response_l = mb_strlen($response, "ASCII");
                        $wret = @fwrite($sock, $response);
                        if ($wret < $response_l) {
                            printf("TROUBLE WITH FWRITE: %d\n", $wret);
                            $user->rd_cache_set(mb_substr($response, $wret, $response_l - $wret, "ASCII"));
                        }
                        else {
                            $user->rd_cache_set("");
                        }
                        fflush($sock);
                        $user->rd_kalive_reset($this->curtime);
                    }
                    
                    // close socket after a while to prevent client memory consumption
                    if ($user->rd_endtime_is_expired($this->curtime)) {
                        if ($this->s2u[intval($sock)]->rd_socket_get() != NULL) {
                            $this->s2u[intval($sock)]->rd_socket_set(NULL);
                        }
                        unset($this->socks[intval($sock)]);
                        unset($this->s2u[intval($sock)]);
                        fclose($sock);
                        printf("CLOSE ON LOOP\n");
                    }
                }
            }  // foreach ($this->socks...
            printf("\n");
        }  // while (...
    }  // function run(...
}

?>
