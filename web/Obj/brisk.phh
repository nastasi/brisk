<?php
/*
 *  brisk - brisk.phh
 *
 *  Copyright (C) 2006-2011 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */


define(BRISK_CONF, "brisk.conf.pho");
define(FTOK_PATH, "/var/lib/brisk");
define(LEGAL_PATH, "/tmp/legal_brisk");
define(PROXY_PATH, "/var/lib/brisk_proxy");
define(TABLES_N, 36);
define(TABLES_AUTH_N, 4);
define(PLAYERS_N, 3);
define(MAX_POINTS, 5);
define(MAX_PLAYERS, (20 + (PLAYERS_N * TABLES_N)));
define(SHM_DIMS_MIN, (50000 + 10000 * TABLES_N + 15000 * MAX_PLAYERS));
define(SHM_DIMS_MAX, SHM_DIMS_MIN + 1048576);
define(SHM_DIMS_DLT, 65536);
 
define(COMM_N, 18);
define(COMM_GEN_N, 50);

define(CHAT_N, 3);
define(CHAT_ILL_TIME, 6);

define(SESS_LEN, 13);
define(STREAM_TIMEOUT, 20);
define(EXPIRE_TIME_RD, 180);
define(EXPIRE_TIME_SMAMMA, 360); 
define(EXPIRE_TIME_WAG, 10);
define(WAKEUP_TIME, 12); 
// BAN_TIME da allineare anche in commons.js
define(BAN_TIME, 3600); 
define(GARBAGE_TIMEOUT, 10);
define(NICKSERV, "<i>BriskServ</i>");


define(DBG_ONL2, 0x0001);
define(DBG_ONLY, 0x0002);
define(DBG_MAIN, 0x0004);
define(DBG_READ, 0x0008);
define(DBG_REA2, 0x0010);
define(DBG_SEND, 0x0020);
define(DBG_LOCK, 0x0040);
define(DBG_WRIT, 0x0080);
define(DBG_LOAD, 0x0100);
define(DBG_AUTH, 0x0200);
define(DBG_CRIT, 0x0400);
define(DBG_LMOP, 0x0800);

// NOTE: BRISK DEBUG must be a numerical constant, not the result of operations on symbols 
define(BRISK_DEBUG, 0xffffffbf);

define(BRISK_SINGLE_DEBUG,0);
define(BRISK_SINGLE_SESS, "");
// define(DEBUGGING, "local");

require_once("$DOCUMENT_ROOT/Etc/".BRISK_CONF);

$mlang_brisk = array( 'btn_backstand'=> array( 'it' => 'torna in piedi',
                                               'en' => 'back standing' ),
                      'btn_close' => array( 'it' => 'chiudi',
                                            'en' => 'close'),

                      'tit_all' => array( 'it' => 'tutti',
                                          'en' => 'all' ),

                      'tabtout_a'=> array( 'it' => '<br>Sei stato inattivo per ', 
                                           'en' => '<br>You are being idle for ' ),
                      'tabtout_b'=> array( 'it' => ' minuti. <br><br>Quindi ritorni tra i <b>Giocatori in piedi</b>.',
                                           'en' => ' minutes. <br><br>Then you return with the <b>standing players</b>.'),
                      'tickmust' => array( 'it' => '<br>Per attivare il messaggio di segnalazione del tavolo occorre essere seduti.<br><br>',
                                           'en' => '<br>To activate the signalling message of the table it\'s necessary to be sitting<br><br>'),
                      'tickjust' => array( 'it' => '<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br> ',
                                           'en' => 'EN<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br> '),
                      'tickwait' => array( 'it' => '<br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>',
                                           'en' => 'EN<br>The signalling message of the table<br>will be deactivated for %d second%s.<br><br>'),
                      'alarpass' => array( 'it' => '<br>La password digitata non &egrave; corretta.<br><br>',
                                           'en' => '<br>The entered password is not correct.<br><br>'),
                      'alarret'  => array( 'it' => '"Alarm \\"<b>%s</b>\\" inviato a <b>%s</b>."',
                                           'en' => '"Alarm \\"<b>%s</b>\\" sent to <b>%s</b>."'),
                      'authmust' => array( 'it' => '<b>Per autenticare qualcuno devi a tua volta essere autenticato.</b>',
                                           'en' => '<b>To authenticate someone you have to be authenticated.</b>'), // on your turn
                      'mesgmust' => array( 'it' => '<b>Per inviare un messaggio devi essere autenticato.</b>',
                                           'en' => '<b>To send a message you have to be authenticated.</b>'),
                      'nickmust' => array( 'it' => 'Il nickname deve contenere almeno una lettera dell\'alfabeto o una cifra.',
                                           'en' => 'The nickname have to contain at least one letter or one number.'),
                      'nickdupl' => array( 'it' => 'Nickname <b>%s</b> gi&agrave; in uso.',
                                           'en' => 'The nickname <b>%s</b> is already in use.'),
                      'authchan' => array( 'it' => '<b>Non puoi cambiare nick a un tavolo per soli autenticati o se sei in modalità isolata.</b>',
                                           'en' => '<b>You can\'t change your nickname into a table for only authenticated or if you are in isolation mode.</b>'),
                      'nickjust' => array( 'it' => 'Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>',
                                           'en' => 'The nickname <b>\'%s\'</b> is already registered, <b>if its proprietary will authenticate you will named again officially ghost<i>N</i>.</b>'), // FIXME: him ???
                      'statunkn' => array( 'it' => 'Questo stato non esiste.',
                                           'en' => 'This state don\'t exists.'),
                      'tabincon' => array( 'it' => '<br>I dati del tavolo n&deg; %d sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>',
                                           'en' => 'EN <br>I dati del tavolo n&deg; %d sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>'),
                      'listmust' => array( 'it' => '<b>Per andare in isolamento non bisogna essere seduti a tavoli non riservati.</b>',
                                           'en' => '<b>To go to isolation you must don\'t stay on not reserved tables</b>'),

                      'tit_onauth'=>array( 'it' => '(solo aut.)',
                                           'en' => '(only aut.)'),
                      'tit_onisol'=>array( 'it' => '(isolam.to)',
                                           'en' => '(isolation)')
                      

);

$G_false = FALSE;
$G_lng = langtolng($G_lang);

$G_all_points = array( 11,10,4,3,2, 0,0,0,0,0 );
$G_brisk_version = "2.5.0";

/* MLANG: ALL THE INFO STRINGS IN brisk.phh */
$root_wellarr = array( 'it' => array ( 'Brisk (Ver. '.$G_brisk_version.'), <b>NOVITA\'</b>: informazioni al tavolo sul chiamante, nuovo stato di supporter del sito.',
                                       'Se vuoi iscriverti alla <a target="_blank" href="mailto:ml-briscola+subscribe@milug.org">Mailing List</a>, cliccala!' ),
                       'en' => array ( 'Brisk (Ver. '.$G_brisk_version.'), <b>NEWS</b>: caller information on the table, new supporter status.',
                                       'If you want to subscribe our <a target="_blank" href="ml-briscola+subscribe@milug.org">Mailing List</a>, click it!' ) );

$G_room_help = array( 'it' => '
<div style=\\"text-align: left; padding: 8px;\\">
<b>Descrizione</b><br>
Questa è un\'implementazione della briscola in cinque, cos&igrave; come &egrave; spiegata su
<a target=\\"_blank\\" href=\\"http://it.wikipedia.org/wiki/Briscola#Gioco_a_5\\">Wikipedia</a>; in breve &egrave; la variante con l\'asta prima sulla carta e poi sui punti.<br><br>
<b>Configurazione del browser.</b><br>
Occorre abilitare i cookies.<br>
<br>
<b>Uso del sito</b><br>
Potete sedervi a un tavolo o rimanere in piedi.<br>
Se al vostro tavolo si raggiungono i 5 giocatori inizia automaticamente la partita.<br>
<br>
<b>Partita</b><br>
All\'inizio vengono distribuite le carte e parte l\'asta; per partecipare all\'asta, quando sar&agrave; il vostro turno, potrete scegliere se andare avanti o passare cliccando sulle icone corrispondenti. Se si arriva ai punti, scrivete nella textbox il vostro rilancio e cliccate PUNTI.<br><br>
Chi vince l\'asta dovr&agrave; decidere il seme della carta scelta e inizier&agrave; la mano.<br>
Per giocare le carte dovrete trascinarle nel quadrato al centro del vostro schermo.<br><br>
Il vostro turno &egrave; sempre segnalato da una cornice verde lampeggiante intorno al quadrato al centro del vostro schermo.<br><br>
Durante la partita, se vorrete ricaricare la pagina, usate l\'apposito bottone \\"reload\\" in basso a destra.<br>
Dopo che &egrave; iniziata una partita per uscirne dovete chiedere agli altri giocatori di sbloccarla cliccando sul lucchetto. Se non si segue questa prassi, una volta usciti, non vi potrete sedere a nessun tavolo per '.floor(BAN_TIME/60).' minuti.
<dl>
<dt><b>Comandi della chat</b>
<dd><b>/nick <i>&lt;nuovo_nickname&gt;</i></b> - cambio di nickname
<dd><b>/tav <i>&lt;frase di invito&gt;</i></b> - invito per gli altri giocatori al tavolo dove si &egrave; seduti 
<dd><b>/st <i>&lt;stato&gt;</i></b> - cambia l\'icona associata al tuo user; <i>stato</i> pu&ograve; valere: \\"normale\\", \\"fuori\\", \\"pausa\\", \\"cibo\\", \\"cane\\", \\"lavoro\\", \\"presente\\" oppure \\"sigaretta\\"
<dd><b>/authreq</b> - se si &egrave; autenticati permette di garantire per un utente fidato
<dd><b>/mesgtoadm</b> - se si &egrave; autenticati permette di lasciare un messaggio all\'amministratore del sito
<dd><b>/listen &lt;all or auth&gt;</b> - se si &egrave; autenticati permette leggere solo i messaggi degli altri autenticati (auth) o di tutti (all)
</dl>
</div>
',

'en' => '
<div style=\\"text-align: left; padding: 8px;\\">
<b>EN Descrizione</b><br>
EN Questa è un\'implementazione della briscola in cinque, cos&igrave; come &egrave; spiegata su
<a target=\\"_blank\\" href=\\"http://it.wikipedia.org/wiki/Briscola#Gioco_a_5\\">Wikipedia</a>; in breve &egrave; la variante con l\'asta prima sulla carta e poi sui punti.<br><br>
<b>EN Configurazione del browser.</b><br>
Occorre abilitare i cookies.<br>
<br>
<b>Uso del sito</b><br>
Potete sedervi a un tavolo o rimanere in piedi.<br>
Se al vostro tavolo si raggiungono i 5 giocatori inizia automaticamente la partita.<br>
<br>
<b>Partita</b><br>
All\'inizio vengono distribuite le carte e parte l\'asta; per partecipare all\'asta, quando sar&agrave; il vostro turno, potrete scegliere se andare avanti o passare cliccando sulle icone corrispondenti. Se si arriva ai punti, scrivete nella textbox il vostro rilancio e cliccate PUNTI.<br><br>
Chi vince l\'asta dovr&agrave; decidere il seme della carta scelta e inizier&agrave; la mano.<br>
Per giocare le carte dovrete trascinarle nel quadrato al centro del vostro schermo.<br><br>
Il vostro turno &egrave; sempre segnalato da una cornice verde lampeggiante intorno al quadrato al centro del vostro schermo.<br><br>
Durante la partita, se vorrete ricaricare la pagina, usate l\'apposito bottone \\"reload\\" in basso a destra.<br>
Dopo che &egrave; iniziata una partita per uscirne dovete chiedere agli altri giocatori di sbloccarla cliccando sul lucchetto. Se non si segue questa prassi, una volta usciti, non vi potrete sedere a nessun tavolo per '.floor(BAN_TIME/60).' minuti.
<dl>
<dt><b>Comandi della chat</b>
<dd><b>/nick <i>&lt;nuovo_nickname&gt;</i></b> - cambio di nickname
<dd><b>/tav <i>&lt;frase di invito&gt;</i></b> - invito per gli altri giocatori al tavolo dove si &egrave; seduti 
<dd><b>/st <i>&lt;stato&gt;</i></b> - cambia l\'icona associata al tuo user; <i>stato</i> pu&ograve; valere: \\"normale\\", \\"fuori\\", \\"pausa\\", \\"cibo\\", \\"cane\\", \\"lavoro\\", \\"presente\\" oppure \\"sigaretta\\"
<dd><b>/authreq</b> - se si &egrave; autenticati permette di garantire per un utente fidato
<dd><b>/mesgtoadm</b> - se si &egrave; autenticati permette di lasciare un messaggio all\'amministratore del sito
<dd><b>/listen &lt;all or auth&gt;</b> - se si &egrave; autenticati permette leggere solo i messaggi degli altri autenticati (auth) o di tutti (all)
</dl>
</div>
');

//  
$G_room_passwdhowto = array( 'it' => '<br><h2>Come registrarsi su Brisk</h2>
<div style=\\"text-align: left; padding: 8px;\\">
Attualmente ci sono due metodi per ottenere una password sul sito:<br><br>
<dir>
<li><b>Facendosi garantire da un utente di Brisk che gi&agrave; possidede una password</b><br><br>
<li><b>Auto-garantendosi utilizzando uno dei seguenti sistemi di identificazione digitale:</b><br><br>
<dir>
<li>Carta Regionale dei Servizi della Lombardia (la tessera sanitaria)
<li>Carta Regionale dei Servizi del Friuli Venezia Giulia (la tessera sanitaria)
<li>Smart card di InfoCamere
</dir>
<br>
<b>Per auto-garantisi occorre possedere:</b><br><br>
<dir>
<li>il codice PIN della propria carta
<li>il lettore di smart-card per collegare la carta al PC (acquistabile di solito presso le edicole)
</dir>
<br>
<b>Per effettuare la registrazione collegarsi al sito:</b><br><br>
<dl>
<dd><a class=\\"flat\\"  target=\\"_blank\\" href=\\"https://brisk.mine.nu\\">https://brisk.mine.nu</a>
</dl>
<br><br>
Se sei in possesso di una carta che permette l\'identificazione via internet che non è nell\'elenco qui sopra
<a class=\\"flat\\" href=\\"mailto:authadmbrisk@alternativeoutput.it\\">fai una segnalazione</a>.

</dir>
</div>
',
                             'en' => '<br><h2>EN Come registrarsi su Brisk</h2>
<div style=\\"text-align: left; padding: 8px;\\">
EN Attualmente ci sono due metodi per ottenere una password sul sito:<br><br>
<dir>
<li><b>Facendosi garantire da un utente di Brisk che gi&agrave; possidede una password</b><br><br>
<li><b>Auto-garantendosi utilizzando uno dei seguenti sistemi di identificazione digitale:</b><br><br>
<dir>
<li>Carta Regionale dei Servizi della Lombardia (la tessera sanitaria)
<li>Carta Regionale dei Servizi del Friuli Venezia Giulia (la tessera sanitaria)
</dir>
<br>
<b>Per auto-garantisi occorre possedere:</b><br><br>
<dir>
<li>il codice PIN della propria carta
<li>il lettore di smart-card per collegare la carta al PC (acquistabile di solito presso le edicole)
</dir>
<br>
<b>Per effettuare la registrazione collegarsi al sito:</b><br><br>
<dl>
<dd><a class=\\"flat\\"  target=\\"_blank\\" href=\\"https://brisk.mine.nu\\">https://brisk.mine.nu</a>
</dl>
<br><br>
Se sei in possesso di una carta che permette l\'identificazione via internet che non è nell\'elenco qui sopra
<a class=\\"flat\\" href=\\"mailto:authadmbrisk@alternativeoutput.it\\">fai una segnalazione</a>.

</dir>
</div>
' );
/*
<dd>Seguendo la procedura di auto-garanzia all\'url: <a href="https://brisk.mine.nu">https://brisk.mine.nu</a>
';
*/

$G_room_about = array( 'it' => '<br>
<div id=\\"header\\" class=\\"header\\">
  <img class=\\"nobo\\" src=\\"img/brisk_logo64.png\\">
  briscola chiamata in salsa ajax
</div>
<br><b>version '.$G_brisk_version.'</b><br><br>
Copyright 2006-2009 <a href=\\"mailto:brisk@alternativeoutput.it\\">Matteo Nastasi</a> (aka mop)<br><br>',
                      'en' => '<br>
<div id=\\"header\\" class=\\"header\\">
  <img class=\\"nobo\\" src=\\"img/brisk_logo64.png\\">
  declaration briscola in ajax sauce <b>(Beta)</b>
</div>
<br><b>version '.$G_brisk_version.'</b><br><br>
Copyright 2006-2009 <a href=\\"mailto:brisk@alternativeoutput.it\\">Matteo Nastasi</a> (aka mop)<br><br>');

$escinp_from = array( "\""     );
$escinp_to = array(   "&quot;" );

function escinput($s)
{
    GLOBAL $escinp_from, $escinp_to;
    
    return str_replace($escinp_from, $escinp_to, $s);
}

function eschtml($s)
{
    return htmlentities($s);
}

function esclfhtml($s)
{
    return str_replace("\n", "<br>\n", htmlentities($s));
}


function langtolng($lang)
{
  GLOBAL $G_lang;

  return ($G_lang == 'en' ? '-en' : '');
}

function csplitter($in, $sep)
{
  $st = 0;
  $id = 0;
  $out = array();
  $out[$id] = "";
  for ($i = 0 ; $i < strlen($in) ; $i++) {
    $ini = substr($in, $i, 1);
    if ($st == 0) {
      if ($ini == '\\')
        $st = 1;
      else if ($ini == $sep) {
        $id++;
        $out[$id] = "";
      }
      else {
        $out[$id] .= $ini;
      }
    }
    else if ($st == 1) {
      $out[$id] .= $ini;
      $st = 0;
    }
  }

  return ($out);
}

function xcape($s)
{
  $from = array (   '\\',     '@',        '|' );
  $to   = array ( '\\\\', '&#64;', '&brvbar;' );

  return (str_replace($from, $to, htmlentities($s,ENT_COMPAT,"UTF-8")));
}

function xcapelt($s)
{
  $from = array (   '\\',     '|',  "\t",  "\n");
  $to   = array ( '\\\\',   '\\|', "\\t", "\\n");

  return (str_replace($from, $to, $s));
}

function xcapemesg($s)
{
  $from = array (  "\n");
  $to   = array ( "\\n");

  return (str_replace($from, $to, $s));
}


class Table {
  var $idx;
  var $player;
  var $player_n;

  var $auth_only;     // se tavolo riservato o libero

  var $wag_own;
  var $wag_com;
  var $wag_tout;

  var $table_token;
  var $table_start;   // information field

  var $wakeup_time;

  function Table() 
  {
  }
  
  function &create($idx) 
  {
    GLOBAL $G_false;

    if (($thiz =& new Table()) == FALSE)
      return ($G_false);

    $thiz->idx       =   $idx;
    $thiz->player    =   array();
    $thiz->player_n  =   0;
    $thiz->auth_only =   FALSE;

    $thiz->wag_own   =  NULL;
    $thiz->wag_com   =  "";
    $thiz->wag_tout   =  0;

    $thiz->table_token  = "";
    $thiz->table_start  = 0;
    
    $thiz->wakeup_time = 0;

    return ($thiz);
  }

  function copy(&$from)
  {
    GLOBAL $G_false;
    
    $this->idx = $from->idx;
    $this->player = array();
    for ($i = 0 ; $i < $from->player_n ; $i++)
      $this->player[$i] = $from->player[$i];
    $this->player_n = $from->player_n;

    log_main("PLAYER_N - parent::copy.".$this->player_n);
    
    $this->auth_only =  $from->auth_only;

    $this->wag_own   =  $from->wag_own;
    $this->wag_com   =  $from->wag_com;
    $this->wag_tout  =  $from->wag_tout;

    $this->table_token  = $from->table_token;
    $this->table_start  = $from->table_start;

    $this->wakeup_time = $from->wakeup_time;
  }

  function &myclone(&$from)
  {
    GLOBAL $G_false;
    
    if (($thiz =& new Table()) == FALSE)
      return ($G_false);

    $this->copy($from);

    return ($thiz);
  }
  
  function &spawn(&$from)
  {
    GLOBAL $G_false;
    
    if (($thiz =& new Table()) == FALSE)
      return ($G_false);
    
    $thiz->idx = $from->idx;
    $thiz->player = array();
    for ($i = 0 ; $i < $from->player_n ; $i++)
      $thiz->player[$i] = $i;
    $thiz->player_n = $from->player_n;

    $thiz->auth_only =  $from->auth_only;

    $thiz->wag_own = $from->wag_own;
    $thiz->wag_com = $from->wag_com;
    $thiz->wag_tout  =  $from->wag_tout;

    $thiz->table_token  = $from->table_token;
    $thiz->table_start  = $from->table_start;

    $thiz->wakeup_time = $from->wakeup_time;

    return ($thiz);
  }

  function wag_set(&$user, $mesg)
  {
    log_main("WAG_SET");

    $this->wag_own  = &$user;
    $this->wag_com  =  $mesg;
    $this->wag_tout =  0;
  }

  function wag_reset($timeout)
  {
    log_main("WAG_RESET");

    unset($this->wag_own);
    $this->wag_own = NULL;
    $this->wag_com  = "";
    $this->wag_tout = $timeout;
  }

  function getPlayer($idx)
  {
    return ($this->player[$idx]);
  }

  function setPlayer($idx, $player)
  {
    $this->player[$idx] = $player;
  }

  function user_add($idx)
  {
    $this->player[$this->player_n] = $idx;
    $this->player_n++;
    
    return ($this->player_n - 1);
  }
  
  function user_rem(&$room, &$user)
  {
    $tabpos = $user->table_pos;
    
    /* verifico la consistenza dei dati */
    if ($room->user[$this->player[$tabpos]] == $user) {
      
      /* aggiorna l'array dei giocatori al tavolo. */
      for ($i = $tabpos ; $i < $this->player_n-1 ; $i++) {
	$this->player[$i] = $this->player[$i+1];
	$user_cur = &$room->user[$this->player[$i]];
	$user_cur->table_pos = $i;
      }
      $this->player_n--;
    }
    else {
      log_main("INCONSISTENCY ON TABLE.");
    }
  }



  //      $ret .= table_act_content(($user->subst == 'standup'), $this->table[$i]->player_n, $i, $user->table, 
  //                              ($this->table[$i]->auth_only == FALSE ? TRUE : $user->flags & USER_FLAG_AUTH));

  // function act_content($isstanding, $sitted, $table, $cur_table, $allowed)
  function act_content(&$user)
  {
    $ret = "";
    $isstanding = ($user->subst == 'standup');
    $sitted = $this->player_n;
    $table = $this->idx;
    $cur_table = $user->table;
    $allowed = TRUE;

    if ($isstanding) {
      if ($sitted < PLAYERS_N) {
        if ($this->auth_only) {
          if ($user->flags & USER_FLAG_AUTH) 
            $act = "sitreser";
          else
            $act = 'reserved';
        }
        else {
          $act = 'sit';
        }
      }
      else {
        $act = 'none';
      }
    }
    else {
      if ($table == $cur_table)
        $act = 'wake';
      else
        $act = 'none';
    }
    
    if ($act != '')
      $ret = sprintf('j_tab_act_cont(%d, \'%s\');', $table, $act);
    
    return ($ret);
  }
} // end class Table


// User flags
define(USER_FLAG_AUTH,     0x02);

define(USER_FLAG_MAP_AUTH, 0x0c);

define(USER_FLAG_LISTAUTH, 0x04);
define(USER_FLAG_ISOLAUTH, 0x08);

//   user status
define(USER_FLAG_S_NORM,  0x000); // done
define(USER_FLAG_S_PAU,   0x100); // done
define(USER_FLAG_S_OUT,   0x200); // done
define(USER_FLAG_S_DOG,   0x300); // done
define(USER_FLAG_S_EAT,   0x400); // done
define(USER_FLAG_S_WRK,   0x500); // done
define(USER_FLAG_S_SMK,   0x600); // done
define(USER_FLAG_S_EYE,   0x700); // done
define(USER_FLAG_S_RABB,  0x800); // done
define(USER_FLAG_S_SOCC,  0x900); // done
define(USER_FLAG_S_BABY,  0xa00); // done
define(USER_FLAG_S_MOP,   0xb00); // done

define(USER_FLAG_S_ALL,   0xf00); // done

/* type of user normal, supporter etc ... */
define(USER_FLAG_TY_ALL,     0xff0000); // done
define(USER_FLAG_TY_NORM,    0x010000); // done
define(USER_FLAG_TY_SUPER,   0x020000); // done
//  ... other usefull status ...
define(USER_FLAG_TY_SUSPEND, 0x400000); // done
define(USER_FLAG_TY_DISABLE, 0x800000); // done

class User {
  var $name;       // name of the user
  var $sess;       // session of the user
  var $ip;         // ip of the user
  var $lacc;       // last access (for the cleanup)
  var $laccwr;     // last access (for the cleanup)
  var $bantime;    // timeout to temporary ban
  var $stat;       // status (outdoor, room, table, game, ...)
  var $subst;      // substatus for each status   
  var $step;       // step of the current status
  var $trans_step; // step to enable transition between pages (disable == -1)
  var $comm;       // commands array
  // var $asta_card;  // 
  // var $asta_pnt;   //
  // var $handpt;     // Total card points at the beginning of the current hand.
  // var $exitislock; // Player can exit from the table ?

  // FIXME: the table_orig field must be removed after table field verify of index management (in spawned table
  //        it is allways ZERO
  var $table_orig; // id of the current table (if in table state)
  var $table;      // id of the current table (if in table state)
  var $table_pos;  // idx on the table
  var $table_token;// token that identify a game on a table
  var $flags;      // Bitfield with: AUTHENTICATE: 0x02 
  var $the_end;    // Flag to change the end of the session

  var $chat_lst;      // Last chat line
  var $chattime;      // Array of chat times
  var $chat_cur;      // Current chat line number
  var $chat_ban;      // Time for ban chat
  var $chat_dlt;      // Delta t for ban
  function User() {
  }

  function &create($name, $sess, $stat = "", $subst = "", $table = -1, $ip="0.0.0.0") {
    GLOBAL $G_false;

    if (($thiz =& new User()) == FALSE)
      return ($G_false);

    $thiz->name  = $name;
    $thiz->sess  = $sess;
    $thiz->ip    = $ip;
    $thiz->lacc   = time();
    $thiz->laccwr = time();
    $thiz->bantime = 0;
    $thiz->stat  = $stat;
    $thiz->subst  = $subst;
    $thiz->step  = 1;
    $thiz->trans_step  = -1;
    $thiz->comm  = array();
    $thiz->asta_card = -2;
    $thiz->asta_pnt  = -1;
    $thiz->handpt = -1;
    $thiz->exitislock = TRUE;

    $thiz->flags = 0x00;
    
    $thiz->chattime = array_fill(0, CHAT_N, 0);
    $thiz->chat_cur = 0;
    $thiz->chat_lst = "";
    $thiz->chat_ban = 0;
    $thiz->chat_dlt = 0;

    $thiz->table_orig = $table;
    $thiz->table      = $table;
    $thiz->table_pos = -1;
    $thiz->table_token = "";

    return ($thiz);
  }

  function copy(&$from)
  {
    GLOBAL $G_false;
    
    $this->name       = $from->name;
    $this->sess       = $from->sess;
    $this->ip         = $from->ip;
    $this->lacc       = $from->lacc;
    $this->laccwr     = $from->laccwr;
    $this->bantime    = $from->bantime;
    $this->stat       = $from->stat;
    $this->subst      = $from->subst;
    $this->step       = $from->step;
    $this->trans_step = $from->trans_step;
    $this->comm       = array();

    $i_start = (1 > ($from->step - COMM_N) ? 1 : ($from->step - COMM_N)); 
    for ($i = $i_start ; $i < $from->step ; $i++) {
      $ii = $i % COMM_N;
      $this->comm[$ii] = $from->comm[$ii];
    }
    $this->asta_card  = $from->asta_card;
    $this->asta_pnt   = $from->asta_pnt;
    $this->handpt     = $from->handpt;
    $this->exitislock = $from->exitislock;

    $this->flags = $from->flags;

    $this->chattime = array();
    for ($i = 0 ; $i < CHAT_N ; $i++)
      $this->chattime[$i] = $from->chattime[$i];
    $this->chat_cur = $from->chat_cur;
    $this->chat_lst = $from->chat_lst;
    $this->chat_ban = $from->chat_ban;
    $this->chat_dlt = $from->chat_dlt;

    $this->table_orig = $from->table_orig;
    $this->table      = $from->table;
    $this->table_pos  = $from->table_pos;
    $this->table_token = $from->table_token;
    $this->the_end    = $from->the_end;

    return (TRUE);
  }


  function &myclone(&$from)
  {
    GLOBAL $G_false;
    
    if (($thiz =& new User()) == FALSE)
      return ($G_false);
    
    $thiz->copy($from);

    return ($thiz);
  }
  
  function &spawn(&$from, $table, $table_pos)
  {
    GLOBAL $G_false;
    
    if (($thiz =& new User()) == FALSE)
      return ($G_false);
    
    $thiz->name       = $from->name;
    $thiz->sess       = $from->sess;
    $thiz->ip         = $from->ip;
    $thiz->lacc       = $from->lacc;
    $thiz->laccwr     = $from->laccwr;
    $thiz->bantime    = $from->bantime;
    $thiz->stat       = $from->stat;
    $thiz->subst      = $from->subst;
    $thiz->step       = $from->step;
    $thiz->trans_step = $from->trans_step;
    $thiz->comm       = array();

    /*
    $i_start = (1 > ($from->step - COMM_N) ? 1 : ($from->step - COMM_N)); 
    for ($i = $i_start ; $i < $from->step ; $i++) {
      log_wr("TRY PUSH:".$i);
      $ii = $i % COMM_N;
      $thiz->comm[$ii]   = $from->comm[$ii];
    }
    */
    $thiz->asta_card  = $from->asta_card;
    $thiz->asta_pnt   = $from->asta_pnt;
    $thiz->handpt     = $from->handpt;
    $thiz->exitislock = $from->exitislock;
    $thiz->the_end    = $from->the_end;

    $thiz->flags      = $from->flags;

    $thiz->chattime   = array_fill(0, CHAT_N, 0);
    $thiz->chat_cur   = 0;
    $thiz->chat_lst   = "";
    $thiz->chat_ban   = 0;
    $thiz->chat_dlt   = 0;


    $thiz->table_orig = $table;
    $thiz->table      = 0;
    $thiz->table_pos  = $table_pos;
    $thiz->table_token = $from->table_token;

    return ($thiz);
  }
  
  function stat_set($stat) {
    log_main("sess: [".$this->sess. "] NEW STAT: [".$stat."]"); 
    $this->stat = "$stat";
    
    /*
    if (validate_sess($this->sess)) {
      if (file_exists(PROXY_PATH) == FALSE)
        mkdir(PROXY_PATH);
      $fp = fopen(PROXY_PATH."/".$this->sess.".stat", 'w');
      fwrite($fp, sprintf("%s\n",$this->stat));
      fclose($fp);
    }
    */
  }

  function step_set($step) {
    $this->step = $step;
    
    do {
      if (validate_sess($this->sess) == FALSE)
	break;
      if (file_exists(PROXY_PATH) == FALSE)
        mkdir(PROXY_PATH);
      if (($fp = @fopen(PROXY_PATH."/".$this->sess.".step", 'w')) == FALSE)
	break;
      fwrite($fp, pack("l",$this->step), 4);
      fclose($fp);

      return (TRUE);
    } while (0);

    return (FALSE);
  }

  function step_inc($delta = 1) {
    $this->step += $delta;
    
    if (validate_sess($this->sess)) {
      if (file_exists(PROXY_PATH) == FALSE)
        mkdir(PROXY_PATH);
      $fp = fopen(PROXY_PATH."/".$this->sess.".step", 'w');
      fwrite($fp, pack("l",$this->step), 4);
      fclose($fp);

      return (TRUE);
    }
    
    return (FALSE);
  }

  function reset() {
    $curtime = time();
    log_legal($curtime, $this, "STAT:LOGOUT", '');

    $tmp_sess = $this->sess;
    $this->sess = "";
    step_unproxy($tmp_sess);
    $this->name = "";  // OK here
    while (array_pop($this->comm) != NULL);
    $this->step = 0;
    $this->chattime = array_fill(0, CHAT_N, 0);
    $this->chat_cur = 0;
    $this->chat_lst = "";
    $this->chat_ban = 0;
    $this->chat_dlt = 0;
    $this->the_end = FALSE;
  }
} // end class User







function step_get($sess) {
  $fp = FALSE;
  do {
    if (validate_sess($sess) == FALSE)
      break;

    if (file_exists(PROXY_PATH) == FALSE)
      mkdir(PROXY_PATH);
    if (($fp = @fopen(PROXY_PATH."/".$sess.".step", 'rb')) == FALSE)
      break;
    if (($s = fread($fp, 4)) == FALSE)
      break;
    if (strlen($s) != 4)
      break;
    $arr = unpack('l', $s);
    fclose($fp);

    // log_rd2("A0: ".$arr[0]."  A1: ".$arr[1]);
    return ($arr[1]);
  } while (0);

  if ($fp != FALSE)
    fclose($fp);

  log_rd2("STEP_GET: return false ");

  return (FALSE);
}

function step_unproxy($sess) {
  log_rd2("UNPROXY: ".PROXY_PATH."/".$sess.".step");
  if (file_exists(PROXY_PATH) == FALSE)
    mkdir(PROXY_PATH);
  @unlink(PROXY_PATH."/".$sess.".step");
}


class Room {
  var $user;
  var $table;
  var $comm; // commands for many people
  var $step; // current step of the comm array
  var $garbage_timeout;
  var $shm_sz;

  function Room () {
    $this->user = array();
    $this->table = array();

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $this->user[$i] =& User::create("", "");
    }

    for ($i = 0 ; $i < TABLES_N ; $i++) {
      $this->table[$i] =& Table::create($i);
      /* OLD METHOD
      if ($i < 12) {
        $row = ( (((int)($i / 4)) % 2) == 0 );
        $col = ($i % 2 == 0);
        $this->table[$i]->auth_only = (($row && $col) || (!$row && !$col));
      }
      else {
        $this->table[$i]->auth_only = FALSE;
      }
      */
      if ($i < TABLES_AUTH_N) 
        $this->table[$i]->auth_only = TRUE;
      else
        $this->table[$i]->auth_only = FALSE;
    }
    $this->garbage_timeout = 0;
  }

  function garbage_manager($force)
  {
    GLOBAL $G_lang, $mlang_brisk, $G_base;

    $ismod = FALSE;

    log_rd2("garbage_manager START");

    /* Garbage collector degli utenti in timeout */
    $curtime = time();
    if ($force || $this->garbage_timeout < $curtime) {
      
      // FIXME BRISK4: include for each kind of table
      require_once("${G_base}briskin5/Obj/briskin5.phh");

      // Before all align times with table timeout
      for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
	$table_cur =& $this->table[$table_idx];
	// if the table is complete and exists its shared mem we get the info about users lacc

	if ($table_cur->player_n == PLAYERS_N) {
	  log_main("PLAYERS == N TABLE ".$table_idx);
	  
	  if (($sem = Briskin5::lock_data($table_idx)) != FALSE) { 
	    log_main("bin5 lock data success");
	    
	    $no_recovery = FALSE;
	    if (($bri = &Briskin5::load_data($table_idx)) != FALSE) {
	      if ($table_cur->table_token != $bri->table_token) {
		log_main("ERROR: not matching table_token. Room: ".$table_cur->table_token."  Table: ".$bri->table_token);
		log_main("ERROR: not matching table_start. Room: ".$table_cur->table_start."  Table: ".$bri->table_start);
		$no_recovery = TRUE;
		$bri = FALSE;
	      }
	    }
	    
	    if ($bri != FALSE) {
	      //
	      //  SPAWN: JOIN
	      //
	      log_main("garbage_manager: bri loaded successfully.");
	      $bri->garbage_manager(TRUE);
	      
	      $bri_table = &$bri->table[0];

	      // is the end of the table
	      if ($bri->the_end == TRUE) {
		/*
		 *  DESTROY OF FINISHED TABLE && MOVE PLAYER TO ROOM AGAIN
		 */
		log_main("garbage_manager: INSIDE THE END.");

                $plist = "$table_cur->table_token|$table_cur->idx|$table_cur->player_n";
                for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
                  $plist .= '|'.$this->user[$table_cur->player[$i]]->sess;
                }

		for ($i = 0 ; $i < $bri_table->player_n ; $i++) {
		  // stat must be "table" by definition
		  $user_cur =& $this->user[$table_cur->player[$i]];
		  $bri_user =& $bri->user[$i];
		  
		  $user_cur->subst      = $bri_user->subst;
		  $user_cur->step       = $bri_user->step;
		  $user_cur->lacc       = $bri_user->lacc;
		  $user_cur->laccwr     = $bri_user->lacc;
		  $user_cur->bantime    = $bri_user->bantime;
		}

                log_legal($curtime, $user_cur, "STAT:DESTROY_GAME", $plist);

		$this->room_join_wakeup(&$user_cur, FALSE, 0); 
		$table_cur->table_token = "";
                $table_cur->wakeup_time = $curtime + WAKEUP_TIME;
		Briskin5::destroy_data($table_idx);
	      }
	      else {
		log_main("gm:: save_data");

		for ($i = 0 ; $i < $bri_table->player_n ; $i++) {
		  $this->user[$table_cur->player[$i]]->lacc = $bri->user[$i]->lacc;
		}
	      
		Briskin5::save_data(&$bri);
	      }
	    } // else if (($bri = &Briskin5::load_data($table_idx)) != FALSE) {
	    else if ($no_recovery == FALSE) {
	      log_crit("ERROR: table ".$table_idx." unrecoverable join");

	      for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
		$user_cur = &$this->user[$table_cur->player[$i]];
		$user_cur->subst = "shutdowner";
		$user_cur->step_inc();
		
		$ret = sprintf('stat = "%s"; subst = "%s";',  $user_cur->stat, $user_cur->subst);
		$ret .= "gst.st = ".($user_cur->step+1)."; ";
                // MLANG <br>I dati del tavolo n&deg; ".$user_cur->table." sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>
                $prestr = sprintf($mlang_brisk['tabincon'][$G_lang], $user_cur->table);
		$ret .= show_notify($prestr, 2000, $mlang_brisk['btn_close'][$G_lang], 400, 110);
		$user_cur->comm[$user_cur->step % COMM_N] = $ret;
		$user_cur->step_inc();
	      }

              $plist = "$table_cur->table_token|$user_cur->table|$table_cur->player_n";
              for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
                $plist .= '|'.$this->user[$table_cur->player[$i]]->sess;
              }
              log_legal($curtime, $user_cur, "STAT:DESTROY_GAME(RECOVERY)", $plist);
              
	      $this->room_join_wakeup(&$user_cur, TRUE, -2); 
	      $table_cur->table_token = "";
	    }

	    Briskin5::unlock_data($sem);
	  } // bri::lock_data
	} //  if ($table_cur->player_n == PLAYERS_N) {
      } //  for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
    
      log_rd2("out new loop.");
		
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
	$user_cur = &$this->user[$i];
	
	log_rd2("User: ".$user_cur->name."  stat: ".$user_cur->stat."  subst: ".$user_cur->subst);
	  
	if ($user_cur->sess == "") 
	  continue;
	
	if ($user_cur->lacc + EXPIRE_TIME_RD < $curtime) {
	  // Auto logout dell'utente
	  log_rd2("AUTO LOGOUT.".($user_cur->lacc + EXPIRE_TIME_RD)." curtime ".$curtime);
	  
	  if ($user_cur->stat == 'table' || $user_cur->stat == 'room') {
	    log_auth($user_cur->sess, "Autologout session.");
	    
	    $user_cur->reset();
	    
	    log_rd2("AUTO LOGOUT.");
	    if ($user_cur->subst == 'sitdown' || $user_cur->stat == 'table')
	      $this->room_wakeup(&$user_cur);
	    else if ($user_cur->subst == 'standup')
	      $this->room_outstandup(&$user_cur);
	    else
	      log_rd2("LOGOUT FROM WHAT ???");
	  }
	}

	if ($user_cur->laccwr + EXPIRE_TIME_SMAMMA < $curtime) { // lo rimettiamo in piedi
	  if ($user_cur->stat == 'room' && $user_cur->subst == 'sitdown') {
	    $this->room_wakeup(&$user_cur);
	    $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
            /* MLANG: <br>Sei stato inattivo per ".(EXPIRE_TIME_SMAMMA/60.0)." minuti. <br><br>Quindi ritorni tra i <b>Giocatori in piedi</b>.", "torna ai tavoli" */
	    $user_cur->comm[$user_cur->step % COMM_N] .=  show_notify($mlang_brisk['tabtout_a'][$G_lang].(EXPIRE_TIME_SMAMMA/60.0).$mlang_brisk['tabtout_b'][$G_lang], 0, $mlang_brisk['btn_backstand'][$G_lang], 400, 100);
	    $user_cur->step_inc();
	  }
	}
      }
      log_rd2("GARBAGE UPDATED!");
      
      $this->garbage_timeout = time() + GARBAGE_TIMEOUT;
      $ismod = TRUE;
    }

    return ($ismod);
  }

  function show_room($user_step, &$user)
  {
    GLOBAL $G_lang, $mlang_brisk;
    log_main("show_room: username: ".$user->name);
    
    $ret = sprintf('gst.st = %d; ',  $user_step);

    if ($user->flags & USER_FLAG_ISOLAUTH) {
      $ret .= 'list_set(\'isolation\', false, \''.$mlang_brisk['tit_onisol'][$G_lang].'\' ); ';
    }
    else if ($user->flags & USER_FLAG_LISTAUTH) {
      $ret .= 'list_set(\'auth\', false, \''.$mlang_brisk['tit_onauth'][$G_lang].'\' ); ';
    }
    else {
      $ret .= 'list_set(\'all\', false, \'\' ); ';
    }

    if ($user->subst == 'standup')
      $ret .= "tra.show(); ";
    else
      $ret .= "tra.hide(); ";

    $ret .= sprintf('stat = "%s";',  $user->stat);
    
    $ret .= root_wellcome($user);
    $ret .= sprintf('subst = "%s";', $user->subst);
    $itin = ($user->flags & USER_FLAG_AUTH ? "<i>" : "");
    $itou = ($user->flags & USER_FLAG_AUTH ? "</i>" : "");
    $ret .= sprintf('$("myname").innerHTML = "<b>%s%s%s</b>";', $itin, xcape($user->name), $itou);
    for ($i = 0 ; $i < TABLES_N ; $i++) {

      $ret .= $this->table_content($user, $i);
      // $ret .= table_act_content(($user->subst == 'standup'), $this->table[$i]->player_n, $i, $user->table, 
      //                          ($this->table[$i]->auth_only == FALSE ? TRUE : $user->flags & USER_FLAG_AUTH));
      $ret .=  $this->table[$i]->act_content($user);
      if ($this->table[$i]->wag_own != NULL) 
        $ret .= sprintf('tra.add(%d, "%s: %s"); ', $i,  $this->table[$i]->wag_own->name, $this->table[$i]->wag_com);
      else 
        $ret .= sprintf('tra.rem(%d); ', $i);
    }
    $ret .= $this->standup_content($user);
    
    return ($ret);
  }
  

  function room_wakeup(&$user)
  {
    $table_idx = $user->table;
    $table = &$this->table[$table_idx];

    log_main("WAKEUP: begin function table:".$table_idx."  stat: ".$user->stat."  subst: ".$user->subst);

    $curtime = time();

    $from_table = ($user->stat == "table");
    if ($from_table) {
      log_main("WAKEUP: from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);

      for ($i = 0 ; $i < $table->player_n ; $i++) {
	$user_cur = &$this->user[$table->player[$i]];
	log_main("PREIMPOST: INLOOP name: ".$user_cur->name);

	if ($user_cur != $user) {
	  $user_cur->stat_set("room");
	  $user_cur->subst = "sitdown";
	  $user_cur->laccwr = $curtime;
	}
	else if ($user->sess != "") {
	  $user_cur->stat_set("room");
	  $user_cur->subst = "standup";
	  $user_cur->laccwr = $curtime;
	  $user_cur->table = -1;
	}
      }
    }
    else {
      $user->stat_set("room");
      $user->subst = "standup";
      $user->laccwr = $curtime;
    }
    
    $remove_wagon = false;
    if($table->wag_own == $user) {
      $remove_wagon = true;
      $table->wag_reset($curtime);
      
    }
    

    /* aggiorna l'array dei giocatori al tavolo. */
    $table->user_rem(&$this, &$user);

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $user_cur = &$this->user[$i];
      if ($user_cur->sess == '' || $user_cur->stat != 'room')
	continue;
      
      // log_main("VALORI: name: ".$user_cur->name."from_table: ".$from_table."  tab: ".$user_cur->table." taix: ".$table_idx."  ucur: ".$user_cur."  us: ".$user);

      $ret = "gst.st = ".($user_cur->step+1)."; ".($remove_wagon ? sprintf("tra.rem(%d);",$table_idx) : "");
      if ($from_table && ($user_cur->table == $table_idx || $user_cur == $user)) {
	$ret .= 'gst.st_loc++; the_end=true; window.onunload = null; window.onbeforeunload = null; document.location.assign("index.php");|';
	// $ret .= 'gst.st_loc++; document.location.assign("index.php");|';
	log_main("DOCUMENT.index.php: from table");
      }
      else if ($user_cur->stat == "room") {
	log_main("DOCUMENT.index.php: from table");

	$ret .= $this->table_content($user_cur, $table_idx);
	$ret .= $this->standup_content($user_cur);
	
	// $ret .= table_act_content(FALSE, 0, $table_idx, $user->table, FALSE);
	$ret .= $table->act_content($user);

	if ($user_cur == $user) {
	  // set the new status 
	  $ret .=  'subst = "standup"; tra.show(); ';
	  // clean the action buttons in other tables
	  for ($e = 0 ; $e < TABLES_N ; $e++) {
	    if ($this->table[$e]->player_n < PLAYERS_N) {
	      // $ret .= table_act_content(TRUE, 0, $e, $user->table, 
              //                           ($this->table[$e]->auth_only == FALSE ? TRUE : $user->flags & USER_FLAG_AUTH));
              $ret .= $this->table[$e]->act_content($user);
            }
	  }
	}
	else {
	  // $ret .= table_act_content(($user_cur->subst == 'standup'), $table->player_n, $table_idx, $user_cur->table,
          //                           ($table->auth_only == FALSE ? TRUE : $user_cur->flags & USER_FLAG_AUTH));
          $ret .= $table->act_content($user_cur);
	}
      }
      log_wr("ROOM_WAKEUP: ".$ret);
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }
  }

  function room_join_wakeup(&$user, $update_lacc = FALSE, $trans_delta)
  {
    $table_idx = $user->table;
    $table = &$this->table[$table_idx];
    
    log_main("JOIN_WAKEUP: begin function table:".$table_idx."  stat: ".$user->stat."  subst: ".$user->subst);

    $curtime = time();
    $user_wup = array();
    $user_wup_n = 0;
    $user_tab = array();
    $user_tab_n = 0;
    log_main("JOIN WAKEUP: from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);
    
    for ($i = 0 ; $i < $table->player_n ; $i++) {
      $user_cur = &$this->user[$table->player[$i]];
      log_main("PREIMPOST INLOOP name: ".$user_cur->name);
      if ($user_cur->sess != "") {
	if ($update_lacc == TRUE) {
	  $user_cur->laccwr = $curtime;
	}
	log_main("cur: ".$user_cur->name."  subst: ".$user_cur->subst);
	if ($user_cur->subst == "shutdowned") {
	  $user_cur->stat_set("room");
	  $user_cur->subst = "sitdown";
	}
	else if ($user_cur->subst == "shutdowner") {
	  $user_cur->stat_set("room");
	  $user_cur->subst = "standup";
	  $user_cur->table = -1;
	  $user_wup[$user_wup_n++] = &$user_cur;
          
          $remove_wagon = false;
          if($table->wag_own == $user_cur) {
            $remove_wagon = true;
            $table->wag_reset($curtime);
          }
	}
	$user_tab[$user_tab_n++] = &$user_cur;
      }
    }

    for ($wup_idx = 0 ; $wup_idx < $user_wup_n  ; $wup_idx++)
      $table->user_rem(&$this, &$user_wup[$wup_idx]);

    /* aggiorna l'array dei giocatori al tavolo. */

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      log_main("START LOOP");
      $user_cur = &$this->user[$i];
      if ($user_cur->sess == '' || $user_cur->stat != 'room') {
	log_main("name: ".$user_cur->name."skip   subst: ".$user_cur->subst);
	continue;
      }

      log_main("___");
      log_main("VALORI name: ".$user_cur->name."  tab: ".$user_cur->table." taix: ".$table_idx);

      $ret = "gst.st = ".($user_cur->step+1)."; ".($remove_wagon ? sprintf("tra.rem(%d);",$table_idx) : "");
      if ($user_cur->stat == "room") {
	log_main("DOCUMENT.index.php from table");

	$ret .= $this->table_content($user_cur, $table_idx);
	$ret .= $this->standup_content($user_cur);
	
	// $ret .= table_act_content(FALSE, 0, $table_idx, $user_cur->table,
        //                           ($table->auth_only == FALSE ? TRUE : $user_cur->flags & USER_FLAG_AUTH));
        $ret .= $table->act_content($user_cur);


	for ($tab_idx = 0 ; $tab_idx < $user_tab_n  ; $tab_idx++)
	  if ($user_cur == $user_tab[$tab_idx]) 
	    break;

	// for users that wakeup the room will be reconstructed by index_rd.php
	if ($tab_idx < $user_tab_n) {
	  log_main("PRE show_room username: ".$user_cur->name."  STEP: ".$user_cur->step);

//        ARRAY_POP DISABLED
// 	  if ($trans_delta == 0)
// 	    while (array_pop($user_cur->comm) != NULL);

	  $user_cur->trans_step = $user_cur->step + 1 + $trans_delta;
	  $user_cur->comm[$user_cur->step % COMM_N] = "";
	  $user_cur->step_inc();
	  $user_cur->comm[$user_cur->step % COMM_N] = $this->show_room(($user_cur->step + 1), &$user_cur);
	  $user_cur->step_inc();
	  log_main("POST show_room username: ".$user_cur->name."  STEP: ".$user_cur->step);

	  continue;
	}
	log_main("JOIN_WAKEUP wup_idx ".$wup_idx."  wup_n ".$user_wup_n);

	log_main("JOIN_WAKEUP more");
	// $ret .= table_act_content(($user_cur->subst == 'standup'), $table->player_n, $table_idx, $user_cur->table,
        //                           ($table->auth_only == FALSE ? TRUE : $user_cur->flags & USER_FLAG_AUTH));
        $ret .= $table->act_content($user_cur);

	log_main("JOIN_WAKEUP end more");
      }
      log_wr("ROOM_JOIN_WAKEUP: ".$ret);
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }
  }

  function room_outstandup(&$user)
  {
    $this->room_sitdown(&$user, -1);
  }
  
  function table_update(&$user)
  {
    log_main("table_update: pre - USER: ".$user->name);

    $table_idx = $user->table;

    if ($table_idx > -1) 
      $table = &$this->table[$table_idx];
    
    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $ret = "";
      $user_cur = &$this->user[$i];
      if ($user_cur->sess == '' || $user_cur->stat != 'room')
      continue;
      
      $ret = "gst.st = ".($user_cur->step+1)."; ";
      if ($table_idx > -1)
	$ret .= $this->table_content($user_cur, $table_idx);
      
      if ($user_cur == $user) {
        $itin = ($user->flags & USER_FLAG_AUTH ? "<i>" : "");
        $itou = ($user->flags & USER_FLAG_AUTH ? "</i>" : "");
	$ret .= sprintf('$("myname").innerHTML = "<b>%s%s%s</b>: ";', $itin, xcape($user->name), $itou);
      }
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }

    log_main("table_update: post");
  }

  function room_sitdown(&$user, $table_idx)
  {
    log_main("room_sitdown ".($user == FALSE ? "USER: FALSE" : "USER: ".$user->name));

    $train_app = "";

    if ($table_idx > -1 && $table_idx < TABLES_N) { 
      $table = &$this->table[$table_idx];

      // wagon shutdown 
      if ($table->wag_own != NULL && $table->player_n == PLAYERS_N) {        
        for ($i = 0 ; $i < TABLES_N ; $i++) {
          $user_cur =& $this->user[$table->player[$i]];
          if ($user_cur == $table->wag_own) {
            $train_app = sprintf("tra.rem(%d); ", $table_idx); 
            $table->wag_reset(time());
            break;
          }
	}
      }
    }

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $ret = "";
      $user_cur = &$this->user[$i];
      if ($user_cur->sess == '' || $user_cur->stat != 'room')
      continue;
      
      $ret = "gst.st = ".($user_cur->step+1)."; ".$train_app;
      if ($table_idx > -1)
      $ret .= $this->table_content($user_cur, $table_idx);
      $ret .= $this->standup_content($user_cur);
      
      if ($user_cur == $user) {
	$ret .=  'subst = "sitdown"; tra.hide(); ';
	// clean the action buttons in other tables
	for ($e = 0 ; $e < TABLES_N ; $e++) {
	  // $ret .= table_act_content(FALSE, 0, $e, $user_cur->table, FALSE);
          $ret .= $this->table[$e]->act_content($user_cur);
	}
      }
      else if ($table_idx > -1) {
	if ($table->player_n == PLAYERS_N) {
	  // $ret .= table_act_content(($user_cur->subst == 'standup'), PLAYERS_N, $table_idx, $user_cur->table,
          ///                      ($table->auth_only == FALSE ? TRUE : $user_cur->flags & USER_FLAG_AUTH));
          $ret .= $table->act_content($user_cur);
	}
      }
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }
  }

  function chatt_send(&$user, $mesg)
  {
    GLOBAL $G_base, $G_alarm_passwd, $mlang_brisk, $G_lang;
    $only_you = FALSE;
    
    // common settings
    $msg = substr($mesg, 6, 128);
    $curtime = time();
    $dt = date("H:i ", $curtime);

    //
    //  Compute actions
    //

    $to_user     = FALSE;
    $to_all      = FALSE;
    $to_room     = FALSE;
    $to_tabl     = FALSE;
    $is_normchat = FALSE;
    /* for old isolation management $is_ticker   = FALSE; */
    $update_room = FALSE;

    if (strcmp($msg,  "/tav") == 0 || 
        strncmp($msg, "/tav ", 5) == 0) {
      do {
        if ($user->stat != 'room' || $user->subst != 'sitdown') {
          /* MLANG: "<br>Per attivare il messaggio di segnalazione del tavolo occorre essere seduti.<br><br>", "<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br>", "<br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>" */
          $msg = $mlang_brisk['tickmust'][$G_lang];
          $to_user = show_notify($msg, 0, "chiudi", 400, 100);

          break;
        }

        $table = &$this->table[$user->table];
        
        if ($table->wag_own != NULL) {
          // MLANG <br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br> 
          $msg = $mlang_brisk['tickjust'][$G_lang];
          $to_user = show_notify($msg, 0, "chiudi", 400, 100);

          break;
        }

        $dtime = $curtime - $table->wag_tout;
        if ($dtime  < EXPIRE_TIME_WAG) {
          // MLANG - <br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>
          $msg = sprintf($mlang_brisk['tickwait'][$G_lang],
                         EXPIRE_TIME_WAG - $dtime, (EXPIRE_TIME_WAG - $dtime == 1 ? ($G_lang == 'en' ? "" : "o") : ($G_lang == 'en' ? "s" : "i")));
          $to_user = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang] , 400, 100);

          break;
        }
        
        $msg = substr($msg, 5);
        
        $table->wag_set($user, $msg);
        $to_user = sprintf('tra.add(%d, "%s");', $user->table, xcape(sprintf("%s: %s", $user->name, $msg)));
        $to_room = $to_user;
        /* for old isolation management $is_ticker = TRUE; */
      } while (0);
    } // /tav chat command

    else if (strncmp($msg, "/alarm ", 7) == 0) {
      if (strncmp($msg, "/alarm to ", 10) == 0) {
        $sp_pos = strpos($msg, " ", 10);
        $target = substr($msg, 10, $sp_pos - 10);
        $alarm_check = "/alarm to ".$target." ".$G_alarm_passwd." ";
      }
      else {
        $target = "";
        $alarm_check = "/alarm ".$G_alarm_passwd." ";
      }
      do {
        if (strncmp($msg, $alarm_check, strlen($alarm_check)) != 0) {
          /* MLANG: "<br>La password digitata non &egrave; corretta.<br><br>" */
          $msg = $mlang_brisk['alarpass'][$G_lang];
          $to_user = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang], 400, 100);

          break;
        }

        /* MLANG: "Alarm <b>%s</b> inviato a <b>%s</b>." */
        $prestr = sprintf($mlang_brisk['alarret'][$G_lang], xcape(substr($msg, strlen($alarm_check))), 
                           ($target == "" ? $mlang_brisk['tit_all'][$G_lang] : xcape($target)) );
        $to_user = sprintf('chatt_sub("%s", [2, "%s"],%s);', 
                           $dt, NICKSERV, $prestr);

        $msg = sprintf("<br><b>%s<br><br>%s</b><br><br>",
                       $dt.NICKSERV, xcape(substr($msg, strlen($alarm_check))));
        /* MLANG: "chiudi" */
        $to_all = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang], 400, 120);
      } while (0);
    } // /alarm chat command
    else if (strncmp($msg, "/listen ", 8) == 0) {
      $arg = substr($msg, 8);

      if (strcasecmp($arg, "isolation") == 0) {
        $flags_old = 0;
        if ($user->stat == 'room' && $user->subst == 'sitdown' &&
            $user->table >= TABLES_AUTH_N) {
          $to_user = sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $mlang_brisk['listmust'][$G_lang]);
          
        }
        else {
          $user->flags &= ~USER_FLAG_MAP_AUTH;
          $user->flags |= USER_FLAG_ISOLAUTH;
          $to_user = 'list_set(\'isolation\', true, \''.$mlang_brisk['tit_onisol'][$G_lang].'\'); ';
        }
      }
      else if (strcasecmp($arg, "auth") == 0) {
        $flags_old = $user->flags;
        $user->flags &= ~USER_FLAG_MAP_AUTH;
        $user->flags |= USER_FLAG_LISTAUTH;
        $to_user = 'list_set(\'auth\', true, \''.$mlang_brisk['tit_onauth'][$G_lang].'\'); ';
      }
      else {
        $flags_old = $user->flags;
        $user->flags &= ~USER_FLAG_MAP_AUTH;
        $to_user = 'list_set(\'all\', true, \'\'); ';
        
      }
      // if from isolation redraw standup area
      if (($flags_old ^ $user->flags) & USER_FLAG_ISOLAUTH) {
        $to_user .= 'standup_data_old = null; '.$this->standup_content($user);
        
      }
    }
    else if (strcmp($msg, "/authreq") == 0) {
      if ($user->flags & USER_FLAG_AUTH) {
        $to_user = sprintf('authbox(300,200);');
      }
      else {
        /* MLANG: "<b>Per autenticare qualcuno devi a tua volta essere autenticato.</b>", "Il nickname deve contenere almeno una lettera dell\'alfabeto o una cifra.", "Nickname <b>%s</b> gi&agrave; in uso." */
        $to_user = sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $mlang_brisk['authmust'][$G_lang]);
      }
    }
    else if (strncmp($msg, "/mesgtoadm", 8) == 0) {
      if ($user->flags & USER_FLAG_AUTH) {
        $to_user = sprintf('mesgtoadmbox(500,300);');
      }
      else {
        /* MLANG: "<b>Per inviare un messaggio devi essere autenticato.</b>" */
        $to_user = sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $mlang_brisk['mesgmust'][$G_lang]);
      }
    }
    else if (strncmp($msg, "/nick ", 6) == 0) {
      log_main("chatt_send BEGIN");

      do {
        if (($name_new = validate_name(substr($msg, 6))) == FALSE) {
          $to_user = sprintf('chatt_sub("%s", [2,"%s"],"%s");', $dt, NICKSERV, $mlang_brisk['nickmust'][$G_lang]);
          break;
        }

        $msg = "COMMAND ".$msg;
        for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
          $user_cur = &$this->user[$i];

          if ($user_cur->sess == '')
            continue;
          if ($user_cur->name == $name_new)
            break;
          }
        if ($i <  MAX_PLAYERS) {
          $prestr = sprintf($mlang_brisk['nickdupl'][$G_lang], xcape($name_new));
          $to_user = sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $prestr);
          break;
        }
        
        /* MLANG: "<b>Non puoi cambiare nick a un tavolo per soli autenticati.</b>", "Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>" */
        if ($user->flags & USER_FLAG_AUTH) {
          if (strcasecmp($user->name,$name_new) != 0) {
             if (( ($user->flags & USER_FLAG_MAP_AUTH) != USER_FLAG_ISOLAUTH) &&
                ($user->subst == 'standup' || 
                 ($user->subst != 'standup' && $this->table[$user->table]->auth_only == FALSE)
                 )
                ) {
              $user->flags &= ~(USER_FLAG_AUTH | USER_FLAG_TY_ALL); // Remove auth if name changed
              for ($i = 0 ; $i < TABLES_N ; $i++) {
                $to_user .= $this->table[$i]->act_content($user);
              }
            }
            else {
              $to_user = sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $mlang_brisk['authchan'][$G_lang]);
              break;
            }
          }
        }
	$user->name = $name_new; // OK - nick changed
        /* se nome gia' in uso, segnala cosa potrebbe capitare */
        if (($user->flags & USER_FLAG_AUTH) == 0) {
          $bdb = new BriskDB();
          $bdb->users_load();
          /* MLANG: "Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>" */
          if ($bdb->login_exists($name_new)) {
            $prestr = sprintf($mlang_brisk['nickjust'][$G_lang], xcape($name_new));
            $to_user .= sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $prestr);
          }
        }

        log_main("chatt_send start set");

        $update_room = TRUE;
      } while (0);
    } // nick chat command

    else if (strncmp($msg, "/st ", 4) == 0) {
      log_main("chatt_send BEGIN");

      do {
        $st_str = substr($msg, 4);
        
        if (strcasecmp($st_str, "normale") == 0) {
          $st = USER_FLAG_S_NORM;
        }
        else if (strcasecmp($st_str, "pausa") == 0) {
          $st = USER_FLAG_S_PAU;
        }
        else if (strcasecmp($st_str, "fuori") == 0) {
          $st = USER_FLAG_S_OUT;
        }
        else if (strcasecmp($st_str, "cane") == 0) {
          $st = USER_FLAG_S_DOG;
        }
        else if (strcasecmp($st_str, "cibo") == 0) {
          $st = USER_FLAG_S_EAT;
        }
        else if (strcasecmp($st_str, "lavoro") == 0) {
          $st = USER_FLAG_S_WRK;
        }
        else if (strcasecmp($st_str, "sigaretta") == 0) {
          $st = USER_FLAG_S_SMK;
        }
        else if (strcasecmp($st_str, "presente") == 0) {
          $st = USER_FLAG_S_EYE;
        }
        else if (strcasecmp($st_str, "coniglio") == 0) {
          $st = USER_FLAG_S_RABB;
        }
        else if (strcasecmp($st_str, "calcio") == 0) {
          $st = USER_FLAG_S_SOCC;
        }
        else if (strcasecmp($st_str, "pupo") == 0) {
          $st = USER_FLAG_S_BABY;
        }
        else if (strcasecmp($st_str, "pulizie") == 0) {
          $st = USER_FLAG_S_MOP;
        }
        else {
          /* MLANG: "Questo stato non esiste." */
          $to_user = sprintf('chatt_sub("%s", [2,"%s"],"%s");', $dt, NICKSERV, $mlang_brisk['statunkn'][$G_lang]);
          break;
        }

        log_main("chatt_send start set");
        if (($user->flags & USER_FLAG_S_ALL) != $st) {
          $update_room = TRUE;
          $user->flags = ($user->flags & ~USER_FLAG_S_ALL) | $st;
        }
      } while (0);
    } // nick chat command

    else { // normal chat line
      $is_normchat = TRUE;
      if ($curtime < ($user->chat_ban + $user->chat_dlt)) {
        $only_you = TRUE;
        $user->chat_dlt = $user->chat_dlt * 2; 
        if ($user->chat_dlt > 120)
          $user->chat_dlt = 120; 
      }
      else if ($user->chat_lst == $msg)
        $only_you = TRUE;
      else if ($curtime - $user->chattime[($user->chat_cur + 1) % CHAT_N] < CHAT_ILL_TIME) {
        $user->chat_ban = $curtime;
        $user->chat_dlt = 5;
        $only_you = TRUE;
      }
      else {
        $user->chat_ban = 0;
        $user->chat_dlt = 0;
      }

      if ($only_you) {
        $to_user = sprintf('chatt_sub("%s", [%d, "%s"],"%s");', $dt, $user->flags, xcape($user->name), xcape("== chat ban =="));
      }
      else {
        $to_user = sprintf('chatt_sub("%s", [%d, "%s"],"%s");', $dt, $user->flags, xcape($user->name), xcape($msg));
	// temporary silentiation for troll (will became array check)
	// if (strcasecmp($user->name,'JackRokka') != 0 && $user->sess != '47ea653f602e8')
        $to_room = $to_user;
      }

      log_legal($curtime, $user, 
		($user->stat == 'room' ? 'room' : 'table '.$user->table),$msg);
      
      $user->chat_lst = "$msg";
      $user->chattime[$user->chat_cur % CHAT_N] = $curtime;
      $user->chat_cur++;
    }

    if ($to_all) {
      $to_room = $to_all;
      $to_tabl = $to_all;
    }

    //
    //  Output to clients
    //

    if ($to_user != FALSE) {
      $user->comm[$user->step % COMM_N] =  "gst.st = ".($user->step+1)."; ";
      $user->comm[$user->step % COMM_N] .= $to_user;
      $user->step_inc();
    }

    if ($to_room != FALSE) {
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
        $user_cur = &$this->user[$i];
        if ($target != "" && $user_cur->name != $target)
          continue;
        // 	if ($user_cur->sess == '' || $user_cur->stat != 'room')
        if ($user_cur->sess == '' || $user_cur->stat == 'table' || $user_cur == $user)
          continue;
        
        if ($is_normchat == TRUE) {
          // use MAP_AUTH to check if auth or isolation
          if ($user_cur->flags & USER_FLAG_MAP_AUTH) {
            if (($user->flags & USER_FLAG_AUTH) == 0) {
              continue;
            }
          }
        }
        /*
        else if ($is_ticker) {
          if (($user_cur->flags & USER_FLAG_MAP_AUTH) == USER_FLAG_ISOLAUTH) {
            if ($user->table >= TABLES_AUTH_N)
              continue;
          }
        }
        */
        $user_cur->comm[$user_cur->step % COMM_N] =  "gst.st = ".($user_cur->step+1)."; ";
        $user_cur->comm[$user_cur->step % COMM_N] .= $to_room; 
        $user_cur->step_inc();
      }
    }
    
    if ($to_tabl) {
      // FIXME BRISK4: include for each kind of table
      require_once("${G_base}briskin5/Obj/briskin5.phh");
      // Before all align times with table timeout
      for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
        $table_cur =& $this->table[$table_idx];
        // if the table is complete and exists its shared mem we get the info about users lacc
        
        if ($table_cur->player_n == PLAYERS_N) {
          log_main("PLAYERS == N TABLE ".$table_idx);
        
          if (($sem = Briskin5::lock_data($table_idx)) != FALSE) { 
            log_main("bin5 lock data success");
            
            $no_recovery = FALSE;
            if (($bri = &Briskin5::load_data($table_idx)) != FALSE) {
              if ($table_cur->table_token != $bri->table_token) {
                log_main("ERROR: not matching table_token. Room: ".$table_cur->table_token."  Table: ".$bri->table_token);
                $bri = FALSE;
              }
            }
            
            if ($bri != FALSE) {
              $bri_table = &$bri->table[0];
              for ($i = 0 ; $i < $bri_table->player_n ; $i++) {
                // stat must be "table" by definition
                $bri_user =& $bri->user[$i];
              
                if ($target != "" && $bri_user->name != $target)
                  continue;
                log_main("writa: ".$user_mesg);
                $bri_user->comm[$bri_user->step % COMM_N] = "gst.st = ".($bri_user->step+1)."; ";
                $bri_user->comm[$bri_user->step % COMM_N] .= $to_tabl;
                $bri_user->step_inc();
              }
              Briskin5::save_data(&$bri);
            }
            Briskin5::unlock_data($sem);
          } // bri::lock_data
        } //  if ($table_cur->player_n == PLAYERS_N) {
      } //  for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
    } // if ($to_tabl == true ...

    if ($update_room) {
      if ($user->stat == 'room' && $user->subst == 'standup') {
        $this->standup_update(&$user);
      }
      else if ($user->stat == 'room' && $user->subst == 'sitdown') {
        log_main("chatt_send pre table update");
        $this->table_update(&$user);
        log_main("chatt_send post table update");
      }
    } // if ($update_room ...

    return;
  } // function chatt_send( ...

  function &get_user($sess, &$idx)
  {
    GLOBAL $PHP_SELF, $G_false;

    if (validate_sess($sess)) {
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
	if (strcmp($sess, $this->user[$i]->sess) == 0) {
	  // find it
	  $idx = $i;
	  $ret = &$this->user[$i];
	  return ($ret);
	}
      }
      log_main(sprintf("get_user: Wrong sess from page [%s]",$PHP_SELF));
      // for ($i = 0 ; $i < MAX_PLAYERS ; $i++) 
      // log_main(sprintf("get_user: Wrong sess compared with [%s]",$this->user[$i]->sess));
    }
    else {
      log_main(sprintf("get_user: Wrong strlen [%s]",$sess));
    }

    return ($G_false);
  }

  

  /*
   * function &add_user(&$room, &$sess, &$idx, $name, $pass, $ip)
   *
   * RETURN VALUE:
   *   if ($idx >  -1    && ret == FALSE)  =>  duplicated nick
   *   if ($idx == -2    && ret == FALSE)  =>  invalid name
   *   if ($idx == -3    && ret == FALSE)  =>  wrong password
   *   if ($idx == -1    && ret == FALSE)  =>  no space left
   *   if ($idx ==  0    && ret == user)   =>  SUCCESS
   *   if ($idx == -$idx && ret == user)   =>  SUCCESS (but the login exists in the auth db 
   */



  function &add_user(&$sess, &$idx, $name, $pass, $ip)
  {
    GLOBAL $G_base, $G_false, $CO_list;

    $idx = 0;

    $authenticate = FALSE;
    $user_type    = 0;
    $login_exists = FALSE;
    $ghost = -1;
    $ghost_auth = FALSE;
    $idx = -1;
    $idfree = -1;
    
    if (($name_new = validate_name($name)) == FALSE) {
      $idx = -2;
      return ($G_false);
    }

    log_auth("XXX", sprintf("ARRIVA: [%s] pass:[%s]", $sess, ($pass == FALSE ? "FALSE" : $pass)));
    if (validate_sess($sess) == FALSE) 
      $sess = "";

    /* if pass != FALSE verify the login with pass */
    log_auth("XXX", "auth1");
    $bdb = new BriskDB();
    $bdb->users_load();
    if ($pass != FALSE) {
      log_auth("XXX", "auth2");
      $authenticate = $bdb->login_verify($name_new, $pass, $code);
      log_auth("XXX", "authenticate: ".($authenticate != FALSE ? "TRUE" : "FALSE"));
      
      if ($authenticate != FALSE) {
          $user_type = $authenticate->typeget();
      }
      else {
          $idx = -3;
          return ($G_false);
      }
    }
    else {
      $login_exists =  $bdb->login_exists($name_new);
    }
    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      /* free user ? */
      if (strcmp($sess, $this->user[$i]->sess) == 0) {
	if ($idx == -1)
	  $idx = $i;
      }
      if ($idfree == -1 && strcmp("", $this->user[$i]->sess) == 0) {
	$idfree = $i;
        continue; // NOTE: CHECK IT !!
      }
      if (strcasecmp($this->user[$i]->name, $name_new) == 0) {
          if ($authenticate != FALSE) {
              $ghost = $i;
              $ghost_auth = ($this->user[$i]->flags & USER_FLAG_AUTH);
          }
          else {
              $idx = $i;
              break;
          }
      }
    }
    if ($idx == -1)
      $idx = $idfree;

    log_auth("XXX", sprintf("TROVATO A QUESTO PUNTO [%d] sess [%s] name [%s]", $idx, $sess, $name_new));

    if ($ghost > -1 && $ghost_auth && ($authenticate != FALSE)) {
      /* swap session */

      $ghost_user =& $this->user[$ghost];
      $curtime = time();
      $ghost_user->step_inc();
      if ($sess == "") {
        $sess = uniqid(""); 
        $ghost_user->sess = $sess;
      }
      else {
        $ghost_user->sess = $sess;
      }
      
      // If user at the table we need to update the table data too
      $table_idx = $ghost_user->table;
      if ($ghost_user->stat == "table" && $this->table[$table_idx]->player_n == PLAYERS_N) {
        // FIXME BRISK4: include for each kind of table
        require_once("${G_base}briskin5/Obj/briskin5.phh");
        if (($brisem = Briskin5::lock_data($table_idx)) != FALSE) { 
          if (($bri = &Briskin5::load_data($table_idx)) != FALSE) {
            if ($bri->the_end != TRUE) {
              $bri->user[$ghost_user->table_pos]->step_inc();
              $bri->user[$ghost_user->table_pos]->sess = $sess;
              Briskin5::save_data(&$bri);
            }
          }
          Briskin5::unlock_data($brisem);
        }
      }

      $idx = $ghost;
      return ($this->user[$ghost]);
    }
    else if ($idx != -1 && $i == MAX_PLAYERS) {
      /* SUCCESS */
      $curtime = time();
      if ($sess == "") {
        $sess = uniqid("");
	$this->user[$idx]->sess = $sess;
      }
      else {
	$this->user[$idx]->sess = $sess;
      }
      $this->user[$idx]->name = $name_new; // OK - add new user
      $this->user[$idx]->stat_set("room");
      $this->user[$idx]->step_set(0);
      while (array_pop($this->user[$idx]->comm) != NULL);
      $this->user[$idx]->subst = "standup";
      $this->user[$idx]->lacc =   $curtime;
      $this->user[$idx]->laccwr = $curtime;
      $this->user[$idx]->bantime = 0;
      $this->user[$idx]->ip = $ip;

      $this->user[$idx]->flags = ($authenticate != FALSE ? USER_FLAG_AUTH : 0x00) | $user_type;

      log_auth("XXX", sprintf("FLAGS: [%x]", $this->user[$idx]->flags));

      
      if ($authenticate != FALSE) {
        $this->user[$idx]->flags |= USER_FLAG_LISTAUTH;

        if (isset($CO_list)) {
          if (strcmp($CO_list, "auth") == 0) {
            $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
            $this->user[$idx]->flags |= USER_FLAG_LISTAUTH;
          }
          if (strcmp($CO_list, "isolation") == 0) {
            $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
            $this->user[$idx]->flags |= USER_FLAG_ISOLAUTH;
          }
          else {
            $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
          }
        }
      }
      
      if ($ghost > -1) {
        log_main("ghost: rename!");
        $ghost_user =& $this->user[$ghost];

        if ($ghost_auth == FALSE) {
          for ($sfx = 1 ; $sfx <= MAX_PLAYERS ; $sfx++) {
            $ghostname = 'ghost'.$sfx;
            for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
              if (strcmp("", $this->user[$i]->sess) == 0) 
                continue;
              
              if (strcmp($this->user[$i]->name, $ghostname) == 0) {
                $ghostname = '';
                break;
              }
            }
            if ($ghostname != '')
              break;
          }
          
          $ghost_user->name = $ghostname;
          
          if ($ghost_user->stat == 'room' && $ghost_user->subst == 'standup') {
            $this->standup_update(&$ghost_user);
          }
          else {
            log_main("chatt_send pre table update");
            $this->table_update(&$ghost_user);
          log_main("chatt_send post table update");
          }
        } // if ($ghost_auth == FALSE
        else {
          // FIXME: cacciare il vecchio utente room && table (if needed)
          $ghost_user->the_end = TRUE;
          $ghost_user->lacc = 0;
          $this->garbage_manager(TRUE);
        }
      } //  if ($ghost > -1) {

      $real_idx = $idx;
      if ($login_exists)
        $idx = -($idx + 1);
      log_main(sprintf("TROVATO LIBERO A [%d] sess [%s] name [%s] count [%d] [%s]", $idx, $sess, $name_new, count($this->user),$this->user[$real_idx]->name));

      $ret = $this->user[$real_idx];
      return ($ret);
    }

    return ($G_false);
  }
  
  function standup_update(&$user)
  {
    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $user_cur = &$this->user[$i];
      if ($user_cur->sess == '')
	continue;

      log_main("STANDUP START: ".$user_cur->stat);
      
      if ($user_cur->stat == 'room') {
	$user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ".$this->standup_content($user_cur);
	if ($user_cur == $user) {
          $itin = ($user->flags & USER_FLAG_AUTH ? "<i>" : "");
          $itou = ($user->flags & USER_FLAG_AUTH ? "</i>" : "");

	  $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('$("myname").innerHTML = "<b>%s%s%s</b>: ";', 
                                                               $itin, xcape($user->name), $itou);
	}
	log_main("FROM STANDUP: NAME: ".$user_cur->name." SENDED: ".$user_cur->comm[$user_cur->step % COMM_N]);
	
	$user_cur->step_inc();
      }
    }
  }

  // Static functions
  function &init_data()
  {
    $room =& new Room();
    
    return $room;
  }
  

  function &load_data() 
  {
    GLOBAL $G_false, $sess;
    $doexit = FALSE;
    do {
      if (($tok = @ftok(FTOK_PATH."/main", "B")) == -1) {
	log_main("ftok failed");
	$doexit = TRUE;
	break;
      }
    
      if (($shm_sz = sharedmem_sz($tok)) == -1) {
	log_main("shmop_open failed");
      }
	
      if ($shm_sz == -1)
	$shm_sz = SHM_DIMS_MIN;

      if ($shm = shm_attach($tok, $shm_sz)) {
	$room = @shm_get_var($shm, $tok);
	
	log_only("bri ==  ".($room == FALSE ?   "FALSE" : "TRUE")."  bri ===  ".($room === FALSE ? "FALSE" : "TRUE")."  bri isset ".(isset($room) ?   "TRUE" : "FALSE"));
	if (isset($room)) 
	  log_only("bri count ".count($room));
	
	if ($room == FALSE) {
	  log_only("INIT MAIN DATA");
	  
	  $room =& Room::init_data();
	  if (@shm_put_var($shm, $tok, $room) == FALSE) {
	    log_only("PUT_VAR FALLITA ".strlen(serialize($room)));
	    log_only(serialize($room));
	  }
	}
	$room->shm_sz = $shm_sz;
	
	shm_detach($shm);
      }
      $ret = &$room;
      return ($ret);
    } while (0);
    
    if ($doexit)
      exit();
    
    return ($G_false);
  }
  

  function save_data(&$room) 
  {
    GLOBAL $sess;
    
    $shm =   FALSE;
    
    // var_dump($room);
    
    if (($tok = @ftok(FTOK_PATH."/main", "B")) == -1) 
      return (FALSE);
    
    while ($room->shm_sz < SHM_DIMS_MAX) {
      if (($shm = shm_attach($tok, $room->shm_sz)) == FALSE)
	break;
      
      // log_only("PUT_VAR DI ".strlen(serialize($room)));
      if (shm_put_var($shm, $tok, $room) != FALSE) {
	shm_detach($shm);
	return (TRUE);
      }
      if (shm_remove($shm) === FALSE) {
	log_only("REMOVE FALLITA");
	break;
      }
      shm_detach($shm);
      $room->shm_sz += SHM_DIMS_DLT;
    } 

    if ($shm)
      shm_detach($shm);
    
    return (FALSE);
  }

  function lock_data()
  {
    GLOBAL $sess; 
    
    //  echo "LOCK: ".FTOK_PATH."/main";
    //  exit;
    if (($tok = @ftok(FTOK_PATH."/main", "B")) == -1) {
      return (FALSE);
    }
    // echo "FTOK ".$tok."<br>";
    if (($res = sem_get($tok)) == FALSE) {
      return (FALSE);
    }
    if (sem_acquire($res)) {   
      log_lock("LOCK room");
      return ($res);
    }
    else
      return (FALSE);
  }
  
  function unlock_data($res)
  {
    GLOBAL $sess; 
    
    log_lock("UNLOCK room");

    return (sem_release($res));
  }


  function standup_content($user)
  {
    $ret = "";
    $content = "";
    
    if ($user->stat != 'room')
      return;
    
    for ($e = 0 , $ct = 0 ; $ct < 4 && $e < MAX_PLAYERS ; $e++) {
      if ($this->user[$e]->sess == "" || $this->user[$e]->stat != "room" || $this->user[$e]->name == "")
        continue;
      $ct++;
    }
    
    // $content .= sprintf('<table cols=\\"%d\\" class=\\"table_standup\\">', $ct);
    
    $content = ' j_stand_cont( [ ';

    for ($e = 0 , $ct = 0 ; $e < MAX_PLAYERS ; $e++) {
      if ($this->user[$e]->sess == "" || $this->user[$e]->stat != "room" || $this->user[$e]->name == "")
        continue;
      
      $flags = $this->user[$e]->flags;
      
      if ($this->user[$e]->subst == "standup") {
        if ($this->user[$e] == $user) 
          { 
            $flags |= 1;
          }
        
        $content .= sprintf('%s[ %d, "%s" ]',($ct > 0 ? ', ' : ''), $flags, xcape($this->user[$e]->name));
        $ct++;
      }
    }
    $content .= ' ]);';
    
    return ($content);
  }
  
  function table_content($user, $table_idx)
  {
    $content = "";
    $ret = "";
    // TODO
    //
    //   Si possono usare i dati nella classe table
    //
    
    $sess = $user->sess;
    $table = &$this->table[$table_idx];
    
    if ($user->stat != 'room')
      return;
    
    $content = "[ ";
    for ($i = 0 ; $i < $table->player_n ; $i++) {
      $user_cur = &$this->user[$table->player[$i]];

      $flags = $user_cur->flags;

      if ($user_cur == $user) 
        $flags |= 1;
      
      log_main($user_cur->name. sprintf(" IN TABLE [%d]", $table_idx));
      
      $content .= sprintf('%s[ %d, "%s" ]',($i == 0 ? '' : ', '), $flags, xcape($user_cur->name));
    }

    $content .= ' ]';

    $ret .= sprintf('j_tab_cont(%d, %s);', $table_idx, $content);
    
    return ($ret);
  }

} // end class Room

function make_seed()
{
  list($usec, $sec) = explode(' ', microtime());
  return (float) $sec + ((float) $usec * 100000);
}


function log_mop($step, $log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LMOP) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LMOP) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("LMOP: [%f] [%05d] [%s] [%s]\n", gettimeofday(TRUE), $step, $PHP_SELF, $log));
    fclose($fp);
  }
}


function log_only2($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_ONL2) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_ONL2) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("ONL2: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_crit($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_CRIT) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_CRIT) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("CRIT: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_only($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_ONLY) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_ONLY) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("ONLY: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_main($log) {
    GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_MAIN) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_MAIN) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("MAIN: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_rd($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_READ) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_READ) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("READ: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_rd2($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_REA2) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;
      
  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_REA2) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("REA2: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_send($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_SEND) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;
      
  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_SEND) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("SEND: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_lock($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LOCK) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LOCK) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("LOCK: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_wr($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_WRIT) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;
      
  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_WRIT) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("WRIT: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_load($log) {
  GLOBAL $sess, $PHP_SELF;

  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LOAD) == 0)
    return;

  if (isset($sess) == FALSE)
    $ssess = "XXXX";
  else
    $ssess = $sess;

  if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LOAD) == 0)
    return;
      
  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("LOAD: [%s] [%s] [%s]\n", $ssess, $PHP_SELF, $log));
    fclose($fp);
  }
}

function log_auth($sess, $log) {
    GLOBAL $PHP_SELF;
  if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_AUTH) == 0)
    return;

  if (( (BRISK_DEBUG | ($sess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_AUTH) == 0)
    return;

  if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
    fwrite($fp, sprintf("AUTH: [%s] [%d] [%s] [%s]\n", $sess, time(), $PHP_SELF, $log));
    fclose($fp);
  }
}


// function log_legal($curtime, $sess, $name, $where, $mesg) 
function log_legal($curtime, &$user, $where, $mesg) 
{
  GLOBAL $_SERVER;

  if (($fp = @fopen(LEGAL_PATH."/legal.log", 'a')) != FALSE) {
    /* Unix time | session | nickname | IP | where was | mesg */
    fwrite($fp, sprintf("%ld|%s|%s|%s|%s|%s|%s|\n", $curtime, $user->sess,
                        ($user->flags & USER_FLAG_AUTH ? 'A' : 'N'),
                        $user->name, $_SERVER['REMOTE_ADDR'], $where , $mesg));
    fclose($fp);
  }
}

function log_points($curtime, &$user, $where, $mesg) 
{
  GLOBAL $_SERVER;

  if (($fp = @fopen(LEGAL_PATH."/points.log", 'a')) != FALSE) {
    /* Unix time | session | nickname | IP | where was | mesg */
    fwrite($fp, sprintf("%ld|%s|%s|%s|%s|%s|%s|\n", $curtime, $user->sess,
                        ($user->flags & USER_FLAG_AUTH ? 'A' : 'N'),
                        $user->name, $_SERVER['REMOTE_ADDR'], $where , $mesg));
    fclose($fp);
  }
}




function lock_banlist()
{
  if (($tok = @ftok(FTOK_PATH."/main", "L")) == -1) {
    echo "FTOK FAILED";
    exit;
  }
  if (($res = sem_get($tok)) == FALSE) {
    echo "SEM_GET FAILED";
    exit;
  }
  if (sem_acquire($res)) 
    return ($res);
  else
    return (FALSE);
}

function unlock_banlist($res)
{
  return (sem_release($res));
}

function table_act_content($isstanding, $sitted, $table, $cur_table, $allowed)
{
  $ret = "";

  if ($isstanding) {
    if ($sitted < PLAYERS_N) {
      if ($allowed)
        $act = 'sit';
      else
        $act = 'reserved';
    }
  }
  else {
    if ($table == $cur_table)
      $act = 'wake';
    else
      $act = 'none';
  }

  if ($act != '')
    $ret = sprintf('j_tab_act_cont(%d, \'%s\');', $table, $act);

  return ($ret);
}

function show_notify($text, $tout, $butt, $w, $h)
{
  log_main("SHOW_NOTIFY: ".$text);
  return sprintf('var noti = new notify(gst,"%s",%d,"%s",%d,%d);', $text, $tout, $butt, $w, $h);
}

function show_notify_ex($text, $tout, $butt, $w, $h, $is_opaque, $block_time)
{
  log_main("SHOW_NOTIFY OPAQUE: ".$text);
  return sprintf('var noti = new notify_ex(gst,"%s",%d,"%s",%d,%d, %s, %d);', $text, $tout, $butt, $w, $h, ($is_opaque ? "true" : "false"), $block_time);
}


function root_wellcome($user)
{
  GLOBAL $root_wellarr, $G_lang;
  $ret = "";

  $curtime = time();
  $dt = date("H:i ", $curtime);
    
  for ($i = 0 ; $i < count($root_wellarr[$G_lang]) ; $i++)
    $ret .= sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, str_replace('"', '\"', $root_wellarr[$G_lang][$i]));

  return ($ret);
}



function validate_sess($sess) 
{
  if (strlen($sess) == SESS_LEN) 
    return (TRUE);
  else
    return (FALSE);
}

function validate_name($name) 
{
  $name_new = str_replace(' ', '_', substr(trim($name),0,12));

  for ($i = 0 ; $i < strlen($name_new) ; $i++) {
    $c = $name_new[$i];
    if (($c >= "a" && $c <= "z") || ($c >= "A" && $c <= "Z") || ($c >= "0" && $c <= "9"))
      return ($name_new);
  }

  return (FALSE);
}

function playsound($filename)
{
  return (sprintf('playsound("flasou", "%s");', $filename));
}

function secstoword($secs)
{
  GLOBAL $G_lang;

  $mins = floor($secs / 60);
  $secs = $secs % 60;
  if ($G_lang == 'en') {
    if ($mins > 0) 
      $ret = sprintf("%d minute%s%s", $mins, ($mins > 1 ? "s" : ""), ($secs > 0 ? " and " : ""));
    
    if ($secs > 0)
      $ret .= sprintf("%d second%s", $secs, ($secs > 1 ? "s" : ""));
  }
  else {
    if ($mins > 0) 
      $ret = sprintf("%d minut%s%s", $mins, ($mins > 1 ? "i" : "o"), ($secs > 0 ? " e " : ""));
    
    if ($secs > 0)
      $ret .= sprintf("%d second%s", $secs, ($secs > 1 ? "i" : "o"));
  }
  return ($ret);
}

function sharedmem_sz($tok)
{
  if (($shm_id = @shmop_open($tok, 'a', 0, 0)) == FALSE) {
    log_main("shmop_open failed");
    return (-1);
  }
  $shm_sz = shmop_size($shm_id);
  shmop_close($shm_id);
  
  log_main("shm_sz: ".$shm_sz."   SHM_DIMS: ".SHM_DIMS);
  return ($shm_sz);
}    

class Warrant {
  function lock_data()
  {
    GLOBAL $sess; 
    
    if (($tok = @ftok(FTOK_PATH."/warrant", "B")) == -1) {
      return (FALSE);
    }
    // echo "FTOK ".$tok."<br>";
    if (($res = sem_get($tok)) == FALSE) {
      return (FALSE);
    }
    if (sem_acquire($res)) {   
      log_lock("LOCK warrant");
      return ($res);
    }
    else
      return (FALSE);
  }
  
  function unlock_data($res)
  {
    GLOBAL $sess; 
    
    log_lock("UNLOCK warrant");
    
    return (sem_release($res));
  }
}

class Poll {
  function lock_data()
  {
    GLOBAL $sess; 
    
    if (($tok = @ftok(FTOK_PATH."/poll", "B")) == -1) {
      return (FALSE);
    }
    // echo "FTOK ".$tok."<br>";
    if (($res = sem_get($tok)) == FALSE) {
      return (FALSE);
    }
    if (sem_acquire($res)) {   
      log_lock("LOCK poll");
      return ($res);
    }
    else
      return (FALSE);
  }
  
  function unlock_data($res)
  {
    GLOBAL $sess; 
    
    log_lock("UNLOCK poll");
    
    return (sem_release($res));
  }
}

?>
