<?php
/*
 *  brisk - brisk.phh
 *
 *  Copyright (C) 2006-2014 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */


define('BRISK_CONF', "brisk.conf.pho");
define('FTOK_PATH', "/var/lib/brisk");
define('LEGAL_PATH', "/tmp/legal_brisk");
define('PROXY_PATH', "/var/lib/brisk_proxy");
define('TABLES_N', 36);
define('TABLES_AUTH_N', 8);
define('TABLES_CERT_N', 4);
define('PLAYERS_N', 3);
define('MAX_POINTS', 5);
define('MAX_PLAYERS', (20 + (PLAYERS_N * TABLES_N)));
define('SHM_DIMS_MIN', (50000 + 10000 * TABLES_N + 15000 * MAX_PLAYERS));
define('SHM_DIMS_MAX', SHM_DIMS_MIN + 1048576);
define('SHM_DIMS_DLT', 65536);

define('SHM_DIMS_U_MIN', 4096);
define('SHM_DIMS_U_MAX', 65536);
define('SHM_DIMS_U_DLT', 4096);

define('COMM_N', 18);
define('COMM_GEN_N', 50);

define('CHAT_N', 3);
define('CHAT_ILL_TIME', 6);
define('CHAT_ENABLED', TRUE);

define('SESS_LEN', 13);
define('STREAM_TIMEOUT', 60);
/* FIXME: move to sac-a-push .phh */
/* TIME_RD define the server-side timeout, after half of it a ping request
   is sent to client, after this time the client is log out */
define('EXPIRE_TIME_RD', 180);
define('EXPIRE_TIME_SMAMMA', 360);
define('EXPIRE_TIME_WAG', 10);
define('WAKEUP_TIME', 12);
// BAN_TIME da allineare anche in commons.js
define('BAN_TIME', 3600);
define('GARBAGE_TIMEOUT', 5);
define('NICKSERV', "BriskServ");

define('LOCK_SHARE_MAX', 10000);

define('DBG_ONL2', 0x000001);
define('DBG_ONLY', 0x000002);
define('DBG_MAIN', 0x000004);
define('DBG_READ', 0x000008);
define('DBG_REA2', 0x000010);
define('DBG_SEND', 0x000020);
define('DBG_LOCK', 0x000040);
define('DBG_WRIT', 0x000080);
define('DBG_LOAD', 0x000100);
define('DBG_AUTH', 0x000200);
define('DBG_CRIT', 0x000400);
define('DBG_LMOP', 0x000800);
define('DBG_TRAC', 0x001000);
define('DBG_SHME', 0x002000);
define('DBG_ENGI', 0x004000);
define('DBG_CDS',  0x008000);
define('DBG_STEP', 0x010000);
// NOTE: BRISK DEBUG must be a numerical constant, not the result of operations on symbols
define('BRISK_DEBUG', 0x0800);

define('BRISK_SINGLE_DEBUG',0);
define('BRISK_SINGLE_SESS', "");
define('DEBUGGING', "no-debugging");

require_once("$DOCUMENT_ROOT/Etc/".BRISK_CONF);
require_once("${G_base}Obj/ipclass.phh");
require_once("${G_base}Obj/provider_proxy.phh");

$mlang_brisk = array( 'btn_backstand'=> array( 'it' => 'torna in piedi',
                                               'en' => 'back standing' ),
                      'btn_close' => array( 'it' => 'chiudi',
                                            'en' => 'close'),

                      'tit_all' => array( 'it' => 'tutti',
                                          'en' => 'all' ),

                      'tabtout_a'=> array( 'it' => '<br>Sei stato inattivo per ',
                                           'en' => '<br>You are being idle for ' ),
                      'tabtout_b'=> array( 'it' => ' minuti. <br><br>Quindi ritorni tra i <b>Giocatori in piedi</b>.',
                                           'en' => ' minutes. <br><br>Then you return with the <b>standing players</b>.'),
                      'tickmust' => array( 'it' => '<br>Per attivare il messaggio di segnalazione del tavolo occorre essere seduti.<br><br>',
                                           'en' => '<br>To activate the signalling message of the table it\'s necessary to be sitting<br><br>'),
                      'tickjust' => array( 'it' => '<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br> ',
                                           'en' => 'EN<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br> '),
                      'tickwait' => array( 'it' => '<br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>',
                                           'en' => 'EN<br>The signalling message of the table<br>will be deactivated for %d second%s.<br><br>'),
                      'alarpass' => array( 'it' => '<br>La password digitata non &egrave; corretta.<br><br>',
                                           'en' => '<br>The entered password is not correct.<br><br>'),
                      'alarret'  => array( 'it' => 'Alarm \\"<b>%s</b>\\" inviato a <b>%s</b>.',
                                           'en' => 'Alarm \\"<b>%s</b>\\" sent to <b>%s</b>.'),
                      'authmust' => array( 'it' => '<b>Per autenticare qualcuno devi a tua volta essere autenticato e certificato.</b>',
                                           'en' => '<b>To authenticate someone you have to be authenticated and certified.</b>'), // on your turn
                      'mesgmust' => array( 'it' => '<b>Per inviare un messaggio devi essere autenticato.</b>',
                                           'en' => '<b>To send a message you have to be authenticated.</b>'),
                      'nickmust' => array( 'it' => 'Il nickname deve contenere almeno una lettera dell\'alfabeto o una cifra.',
                                           'en' => 'The nickname have to contain at least one letter or one number.'),
                      'nickdupl' => array( 'it' => 'Nickname <b>%s</b> gi&agrave; in uso.',
                                           'en' => 'The nickname <b>%s</b> is already in use.'),
                      'authchan' => array( 'it' => '<b>Non puoi cambiare nick a un tavolo per soli autenticati o se sei in modalità isolata.</b>',
                                           'en' => '<b>You can\'t change your nickname into a table for only authenticated or if you are in isolation mode.</b>'),
                      'nickjust' => array( 'it' => 'Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>',
                                           'en' => 'The nickname <b>\'%s\'</b> is already registered, <b>if its proprietary will authenticate you will named again officially ghost<i>N</i>.</b>'), // FIXME: him ???
                      'statunkn' => array( 'it' => 'Questo stato non esiste.',
                                           'en' => 'This state don\'t exists.'),
                      'tabincon' => array( 'it' => '<br>I dati del tavolo n&deg; %d sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>',
                                           'en' => 'EN <br>I dati del tavolo n&deg; %d sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>'),
                      'listmust' => array( 'it' => '<b>Per andare in isolamento non bisogna essere seduti a tavoli non riservati.</b>',
                                           'en' => '<b>To go to isolation you must don\'t stay on not reserved tables</b>'),

                      'tit_onauth'=>array( 'it' => '(solo aut.)',
                                           'en' => '(only aut.)'),
                      'tit_onisol'=>array( 'it' => '(isolam.to)',
                                           'en' => '(isolation)'),
                      'db_failed' =>array('it'  => '<br>Il collegamento al database è fallito.<br>Temporaneamente tutte le autenticazioni verranno sospese, accederai a Brisk come un utente normale.<br><br>Ci scusiamo per il disagio.',
                                          'en'  => 'Connection to the database failed<br>All authentications are suspended temporarly, you login as normal user.<br>We are about the limitation'),

                      'tos_old'  => array( 'it' => '<b>%s</b> ha sottoscritto dei Termini del Servizio antecedenti a quelli necessari per poter richiedere questa funzionalità.',
                                           'en' => 'EN <b>%s</b> ha sottoscritto dei Termini del Servizio antecedenti a quelli necessari per poter richiedere questa funzionalità.'),
                      'gua_nfd'  => array( 'it' => 'Non è stato trovato un garante per <b>%s</b>.',
                                           'en' => 'EN Non è stato trovato un garante per <b>%s</b>.'),
                      'gua_self' => array( 'it' => '<b>%s</b> si è auto-garantito.',
                                           'en' => 'EN <b>%s</b> si è auto-garantito.'),
                      'gua_info' => array( 'it' => 'Il garante di <b>%s</b> è <b>%s</b>.',
                                           'en' => 'EN Il garante di <b>%s</b> è <b>%s</b>.'),
                      'gua_err'  => array( 'it' => 'Error %d. Utilizzo: <b>/guar <i>&lt;login&gt;</i></b>.',
                                           'en' => 'Error %d. Usage: <b>/guar <i>&lt;login&gt;</i></b>.')
);

$G_lng = langtolng($G_lang);

$G_all_points = array( 11,10,4,3,2, 0,0,0,0,0 );
$G_brisk_version = "4.17.0";

/* MLANG: ALL THE INFO STRINGS IN brisk.phh */
$root_wellarr = array( 'it' => array ( 'Brisk (Ver. '.$G_brisk_version.'), <b>NOVITA\'</b>: gestione accessi da sistemi di anonimizzazione, nuovi termini di utilizzo.',
                                       'Se vuoi iscriverti alla <a target="_blank" href="mailto:ml-briscola+subscribe@milug.org">Mailing List</a>, cliccala!' ),
                       'en' => array ( 'Brisk (Ver. '.$G_brisk_version.'), <b>NEWS</b>: engine refactoring and logout message.',
                                       'If you want to subscribe our <a target="_blank" href="ml-briscola+subscribe@milug.org">Mailing List</a>, click it!' ) );

$G_room_help = array( 'it' => '
<div style=\\"text-align: left; padding: 8px;\\">
<b>Descrizione</b><br>
Questa è un\'implementazione della briscola in cinque, cos&igrave; come &egrave; spiegata su
<a target=\\"_blank\\" href=\\"http://it.wikipedia.org/wiki/Briscola#Gioco_a_5\\">Wikipedia</a>; in breve &egrave; la variante con l\'asta prima sulla carta e poi sui punti.<br><br>
<b>Configurazione del browser.</b><br>
Occorre abilitare i cookies.<br>
<br>
<b>Uso del sito</b><br>
Potete sedervi a un tavolo o rimanere in piedi.<br>
Se al vostro tavolo si raggiungono i 5 giocatori inizia automaticamente la partita.<br>
<br>
<b>Partita</b><br>
All\'inizio vengono distribuite le carte e parte l\'asta; per partecipare all\'asta, quando sar&agrave; il vostro turno, potrete scegliere se andare avanti o passare cliccando sulle icone corrispondenti. Se si arriva ai punti, scrivete nella textbox il vostro rilancio e cliccate PUNTI.<br><br>
Chi vince l\'asta dovr&agrave; decidere il seme della carta scelta e inizier&agrave; la mano.<br>
Per giocare le carte dovrete trascinarle nel quadrato al centro del vostro schermo.<br><br>
Il vostro turno &egrave; sempre segnalato da una cornice verde lampeggiante intorno al quadrato al centro del vostro schermo.<br><br>
Durante la partita, se vorrete ricaricare la pagina, usate l\'apposito bottone \\"reload\\" in basso a destra.<br>
Dopo che &egrave; iniziata una partita per uscirne dovete chiedere agli altri giocatori di sbloccarla cliccando sul lucchetto. Se non si segue questa prassi, una volta usciti, non vi potrete sedere a nessun tavolo per '.floor(BAN_TIME/60).' minuti.
<dl>
<dt><b>Comandi della chat</b>
<dd><b>/nick <i>&lt;nuovo_nickname&gt;</i></b> - cambio di nickname
<dd><b>/tav <i>&lt;frase di invito&gt;</i></b> - invito per gli altri giocatori al tavolo dove si &egrave; seduti
<dd><b>/st <i>&lt;stato&gt;</i></b> - cambia l\'icona associata al tuo user; <i>stato</i> pu&ograve; valere: \\"normale\\", \\"fuori\\", \\"pausa\\", \\"cibo\\", \\"cane\\", \\"lavoro\\", \\"presente\\" oppure \\"sigaretta\\"
<dd><b>/cont <i>&lt;id partita&gt;</i></b> - quando si è a un tavolo per garantiti, permette di proseguire una partita giocata in precedenza con gli stessi giocatori
<dd><b>/guar <i>&lt;login&gt;</i></b> - mostra il garante dell\'utente con il login passato come argomento
<dd><b>/authreq</b> - se si &egrave; autenticati permette di garantire per un utente fidato
<dd><b>/mesgtoadm</b> - se si &egrave; autenticati permette di lasciare un messaggio all\'amministratore del sito
<dd><b>/listen &lt;all or auth&gt;</b> - se si &egrave; autenticati permette leggere solo i messaggi degli altri autenticati (auth) o di tutti (all)
</dl>
</div>
',

'en' => '
<div style=\\"text-align: left; padding: 8px;\\">
<b>EN Descrizione</b><br>
EN Questa è un\'implementazione della briscola in cinque, cos&igrave; come &egrave; spiegata su
<a target=\\"_blank\\" href=\\"http://it.wikipedia.org/wiki/Briscola#Gioco_a_5\\">Wikipedia</a>; in breve &egrave; la variante con l\'asta prima sulla carta e poi sui punti.<br><br>
<b>Configurazione del browser.</b><br>
Occorre abilitare i cookies.<br>
<br>
<b>Uso del sito</b><br>
Potete sedervi a un tavolo o rimanere in piedi.<br>
Se al vostro tavolo si raggiungono i 5 giocatori inizia automaticamente la partita.<br>
<br>
<b>Partita</b><br>
All\'inizio vengono distribuite le carte e parte l\'asta; per partecipare all\'asta, quando sar&agrave; il vostro turno, potrete scegliere se andare avanti o passare cliccando sulle icone corrispondenti. Se si arriva ai punti, scrivete nella textbox il vostro rilancio e cliccate PUNTI.<br><br>
Chi vince l\'asta dovr&agrave; decidere il seme della carta scelta e inizier&agrave; la mano.<br>
Per giocare le carte dovrete trascinarle nel quadrato al centro del vostro schermo.<br><br>
Il vostro turno &egrave; sempre segnalato da una cornice verde lampeggiante intorno al quadrato al centro del vostro schermo.<br><br>
Durante la partita, se vorrete ricaricare la pagina, usate l\'apposito bottone \\"reload\\" in basso a destra.<br>
Dopo che &egrave; iniziata una partita per uscirne dovete chiedere agli altri giocatori di sbloccarla cliccando sul lucchetto. Se non si segue questa prassi, una volta usciti, non vi potrete sedere a nessun tavolo per '.floor(BAN_TIME/60).' minuti.
<dl>
<dt><b>Comandi della chat</b>
<dd><b>/nick <i>&lt;nuovo_nickname&gt;</i></b> - cambio di nickname
<dd><b>/tav <i>&lt;frase di invito&gt;</i></b> - invito per gli altri giocatori al tavolo dove si &egrave; seduti
<dd><b>/st <i>&lt;stato&gt;</i></b> - cambia l\'icona associata al tuo user; <i>stato</i> pu&ograve; valere: \\"normale\\", \\"fuori\\", \\"pausa\\", \\"cibo\\", \\"cane\\", \\"lavoro\\", \\"presente\\" oppure \\"sigaretta\\"
<dd><b>/cont <i>&lt;id partita&gt;</i></b> - quando si è a un tavolo per garantiti, permette di proseguire una partita giocata in precedenza con gli stessi giocatori
<dd><b>/guar <i>&lt;login&gt;</i></b> - mostra il garante dell\'utente con il login passato come argomento
<dd><b>/authreq</b> - se si &egrave; autenticati permette di garantire per un utente fidato
<dd><b>/mesgtoadm</b> - se si &egrave; autenticati permette di lasciare un messaggio all\'amministratore del sito
<dd><b>/listen &lt;all or auth&gt;</b> - se si &egrave; autenticati permette leggere solo i messaggi degli altri autenticati (auth) o di tutti (all)
</dl>
</div>
');

//
$G_room_passwdhowto = array( 'it' => '<br><h2>Come registrarsi su Brisk</h2>
<div style=\\"text-align: left; padding: 8px;\\">
Attualmente ci sono due metodi per ottenere una password sul sito:<br><br>
<dir>
<li><b>Facendosi garantire da un utente di Brisk che sia certificato.</b><br><br>
<li><b>Auto-garantendosi utilizzando uno dei seguenti sistemi di identificazione digitale:</b><br><br>
<dir>
<li>Carta Regionale dei Servizi della Lombardia (la tessera sanitaria)
<li>Carta Regionale dei Servizi del Friuli Venezia Giulia (la tessera sanitaria)
<li>Smart card di InfoCamere
</dir>
<br>
<b>Per auto-garantisi occorre possedere:</b><br><br>
<dir>
<li>il codice PIN della propria carta
<li>il lettore di smart-card per collegare la carta al PC (acquistabile di solito presso le edicole)
</dir>
<br>
<b>Per effettuare la registrazione collegarsi al sito:</b> <a class=\\"flat\\"  target=\\"_blank\\" href=\\"https://brisk.mine.nu\\">https://brisk.mine.nu</a>
<br>
Se sei in possesso di una carta che permette l\'identificazione via internet che non è nell\'elenco qui sopra
<a class=\\"flat\\" href=\\"mailto:authadmbrisk@alternativeoutput.it\\">fai una segnalazione</a>.<br><br>
Le regole per ottenere la certificazione sono in via di definizione, l\' unica accettata è la conoscenza
diretta dell\' utente da parte dell\' amministratore.

</dir>
</div>
',
                             'en' => '<br><h2>EN Come registrarsi su Brisk</h2>
<div style=\\"text-align: left; padding: 8px;\\">
EN Attualmente ci sono due metodi per ottenere una password sul sito:<br><br>
<dir>
<li><b>Facendosi garantire da un utente di Brisk che gi&agrave; possidede una password</b><br><br>
<li><b>Auto-garantendosi utilizzando uno dei seguenti sistemi di identificazione digitale:</b><br><br>
<dir>
<li>Carta Regionale dei Servizi della Lombardia (la tessera sanitaria)
<li>Carta Regionale dei Servizi del Friuli Venezia Giulia (la tessera sanitaria)
</dir>
<br>
<b>Per auto-garantisi occorre possedere:</b><br><br>
<dir>
<li>il codice PIN della propria carta
<li>il lettore di smart-card per collegare la carta al PC (acquistabile di solito presso le edicole)
</dir>
<br>
<b>Per effettuare la registrazione collegarsi al sito:</b> <a class=\\"flat\\"  target=\\"_blank\\" href=\\"https://brisk.mine.nu\\">https://brisk.mine.nu</a>
<br>
Se sei in possesso di una carta che permette l\'identificazione via internet che non è nell\'elenco qui sopra
<a class=\\"flat\\" href=\\"mailto:authadmbrisk@alternativeoutput.it\\">fai una segnalazione</a>.<br><br>
Le regole per ottenere la certificazione sono in via di definizione, l\' unica accettata è la conoscenza
diretta dell\' utente da parte dell\' amministratore.


</dir>
</div>
' );
/*
<dd>Seguendo la procedura di auto-garanzia all\'url: <a href="https://brisk.mine.nu">https://brisk.mine.nu</a>
';
*/

$G_room_about = array( 'it' => '<br>
<div id=\\"header\\" class=\\"header\\">
  <img class=\\"nobo\\" src=\\"img/brisk_logo64.png\\">
  briscola chiamata in salsa ajax
</div>
<br><b>version '.$G_brisk_version.'</b><br><br>
Copyright 2006-2012 <a href=\\"mailto:brisk@alternativeoutput.it\\">Matteo Nastasi</a> (aka mop)<br><br>',
                      'en' => '<br>
<div id=\\"header\\" class=\\"header\\">
  <img class=\\"nobo\\" src=\\"img/brisk_logo64.png\\">
  declaration briscola in ajax sauce <b>(Beta)</b>
</div>
<br><b>version '.$G_brisk_version.'</b><br><br>
Copyright 2006-2012 <a href=\\"mailto:brisk@alternativeoutput.it\\">Matteo Nastasi</a> (aka mop)<br><br>');


$G_PG_vow = array("a", "e", "i", "o", "u", "y");
$G_PG_vow_n = 6;
$G_PG_cons = array(
      "b", "bb", "bc", "bd", "bf", "bg", "bk", "bl", "bm", "bn", "bp",       "br", "bs", "bt", "bv", "bw",       "bz",
      "c", "cb", "cc", "cd", "cf", "cg", "ck", "cl", "cm", "cn", "cp", "cq", "cr", "cs", "ct", "cv", "cw", "cx", "cz",
      "d", "db", "dc", "dd", "df", "dg", "dk", "dl", "dm", "dn", "dp",       "dr", "ds", "dt", "dv", "dw", "dx", "dz",
      "f", "fb", "fc", "fd", "ff", "fg", "fk", "fl", "fm", "fn", "fp",       "fr", "fs", "ft", "fv", "fw", "fx", "fz",
      "g", "gb", "gc", "gd", "gf", "gg", "gk", "gl", "gm", "gn", "gp",       "gr", "gs", "gt", "gv", "gw", "gx", "gz",
      "j", "jb", "jc", "jd", "jf", "jg", "jk", "jl", "jm", "jn", "jp", "jq", "jr", "js", "jt", "jv", "jw", "jx", "jz",
      "k", "kb", "kc", "kd", "kf", "kg", "kk", "kl", "km", "kn", "kp",       "kr", "ks", "kt", "kv", "kw", "kx", "kz",
      "l", "lb", "lc", "ld", "lf", "lg", "lk", "ll", "lm", "ln", "lp",       "lr", "ls", "lt", "lv", "lw", "lx", "lz",
      "m", "mb", "mc", "md", "mf", "mg", "mk", "ml", "mm", "mn", "mp",       "mr", "ms", "mt", "mv", "mw", "mx", "mz",
      "n", "nb", "nc", "nd", "nf", "ng", "nk", "nl", "nm", "nn", "np",       "nr", "ns", "nt", "nv", "nw", "nx", "nz",
      "p", "pb", "pc", "pd", "pf", "pg", "pk", "pl", "pm", "pn", "pp",       "pr", "ps", "pt", "pv", "pw", "px", "pz",
      "q", "qb", "qc", "qd", "qf", "qg", "qk", "ql", "qm", "qn", "qp", "qq", "qr", "qs", "qt", "qv", "qw", "qx", "qz",
      "r", "rb", "rc", "rd", "rf", "rg", "rk", "rl", "rm", "rn", "rp",       "rr", "rs", "rt", "rv", "rw", "rx", "rz",
      "s", "sb", "sc", "sd", "sf", "sg", "sk", "sl", "sm", "sn", "sp", "sq", "sr", "ss", "st", "sv", "sw", "sx", "sz",
      "t", "tb", "tc", "td", "tf", "tg", "tk", "tl", "tm", "tn", "tp",       "tr", "ts", "tt", "tv", "tw", "tx", "tz",
      "v", "vb", "vc", "vd", "vf", "vg", "vk", "vl", "vm", "vn", "vp",       "vr", "vs", "vt", "vv", "vw", "vx", "vz",
      "w", "wb", "wc", "wd", "wf", "wg", "wk", "wl", "wm", "wn", "wp",       "wr", "ws", "wt", "wv", "ww", "wx", "wz",
      "x", "xb", "xc", "xd", "xf", "xg", "xk", "xl", "xm", "xn", "xp",       "xr", "xs", "xt", "xv", "xw", "xx", "xz",
      "z", "zb", "zc", "zd", "zf", "zg", "zk", "zl", "zm", "zn", "zp",       "zr", "zs", "zt", "zv", "zw", "zx", "zz",
                  );
// $G_PG_cons_n = count($G_PG_cons);
// printf("N CONS: %d\n", $G_PG_cons_n);
$G_PG_cons_n = 345;
    /*     printf("%d %d\n", count($voc), count($cons)); */
    /* for ($i = 0 ; $i < 26 ; $i++) { */
    /*     if (array_search(chr(ord('a') + $i), $voc) !== FALSE || $i == 7) */
    /*         continue; */
    /*     printf('      "%s", ', chr(ord('a') + $i)); */
    /*     for ($e = 0 ; $e < 26 ; $e++) { */
    /*         if (array_search(chr(ord('a') + $e), $voc) !== FALSE || $e == 7) */
    /*             continue; */
    /*         printf('"%s%s", ', chr(ord('a') + $i), chr(ord('a') + $e)); */
    /*     } */
    /*     printf("\n"); */
    /* } */

function nickserv_msg($dt, $msg) {
    return sprintf('chatt_sub("%s",[0x040003,"%s"],"%s");', $dt, NICKSERV, $msg);
}

function passwd_gen($seed = NULL)
{
    GLOBAL $G_PG_vow, $G_PG_vow_n, $G_PG_cons, $G_PG_cons_n;

    $pw = "";

    if ($seed != NULL)
        mt_srand($seed);
    else
        mt_srand();

    for ($sil = 0 ; $sil < 7 ; $sil++) {
        if (($sil % 2) == 0) {
            // vowels
            for ($n = 0 ; $n < mt_rand(1,2) ; $n++) {
                if ($n == 0) {
                    $old = mt_rand(0, $G_PG_vow_n-1);
                    $pw .= $G_PG_vow[$old];
                }
                else {
                    $new = mt_rand(0, $G_PG_vow_n-1);
                    if ($new == $old)
                        $new = ($new + mt_rand(0, $G_PG_vow_n-2)) % $G_PG_vow_n;
                    $pw .= $G_PG_vow[$new];
                }
            }
        }
        else {
            // consonants
            $pw .= $G_PG_cons[mt_rand(0, $G_PG_cons_n-1)];
        }
    }

    return $pw;
}

function cmd_return($val, $desc)
{
    return array('val' => $val, 'desc' => $desc);
}

function cmd_serialize($attrs)
{
    $ret = "";

    $sep = "";
    foreach ($attrs as $key => $value) {
        $ret .= $sep . $key . '=' . urlencode($value);
        $sep = "&";
    }
    return $ret;
}

function cmd_deserialize($cmd)
{
    $ret = array();
    $a = explode('&', $cmd);
    $i = 0;
    while ($i < count($a)) {
        $b = split('=', $a[$i]);
        $ret[urldecode($b[0])] = urldecode($b[1]);
        $i++;
    }

    return $ret;
}

//  return values
// -1 v1 < v2
//  0 equal
//  1 v1 > v2
function versions_cmp($v1, $v2)
{
    // printf("V1: [%s]\nV2: [%s]\n", $v1, $v2);
    if ($v1 == $v2)
        return 0;

    $v1_ar = split('\.', $v1);
    $v2_ar = split('\.', $v2);

    $v2_ct = count($v2_ar);

    for ($i = 0 ; $i < count($v1_ar) ; $i++) {
        if (($v2_ct - 1) < $i) {
            break;
        }
        // printf("here [%s] [%s]\n", $v1_ar[$i], $v2_ar[$i]);
        if ($v1_ar[$i] != $v2_ar[$i]) {
            if (strval($v1_ar[$i]) < strval($v2_ar[$i]))
                return -1;
            else
                return  1;
        }
    }
    return 0;
}

// return string with IPV4 address
function addrtoipv4($addr)
{
    $ipv4addr_arr = explode(':' , $addr);
    if (isset($ipv4addr_arr[3])) {
        $ipv4addr = $ipv4addr_arr[3];
    }
    else {
        $ipv4addr = $addr;
    }
    return $ipv4addr;
}

function mop_flush()
{
    for ($i = 0; $i < ob_get_level(); $i++)
        ob_end_flush();
    ob_implicit_flush(1);
    flush();
}

function force_no_cache(&$header_out)
{
    $header_out['Pragma'] = 'no-cache, must-revalidate';
    $header_out['Cache-Control'] = 'no-cache';
    $header_out['Expires'] = '-1';
}

function file_lock($fname, $is_exclusive)
{
    if (($res = @fopen($fname, "r+")) == FALSE) {
        return (FALSE);
    }

    if (flock($res, ($is_exclusive ? LOCK_EX : LOCK_SH)) == FALSE) {
        fclose($res);
        return (FALSE);
    }

    return ($res);
}

function file_unlock($res)
{
    if ($res != FALSE) {
        flock($res, LOCK_UN);
        fclose($res);
    }
}

$escpush_from = array("\\", "\"");
$escpush_to   = array("\\\\", "\\\"");
function escpush($s)
{
    GLOBAL $escpush_from, $escpush_to;

    return str_replace($escpush_from, $escpush_to, $s);
}

$escinp_from = array( "\""     );
$escinp_to = array(   "&quot;" );

function escinput($s)
{
    GLOBAL $escinp_from, $escinp_to;

    return str_replace($escinp_from, $escinp_to, $s);
}

function eschtml($s)
{
    return htmlentities($s, ENT_COMPAT, "UTF-8");
}

function esclfhtml($s)
{
    return str_replace(" ", "&nbsp;", str_replace("\n", "<br>", htmlspecialchars($s)));
}

function langtolng($lang)
{
  GLOBAL $G_lang;

  return ($G_lang == 'en' ? '-en' : '');
}

function csplitter($in, $sep)
{
  $st = 0;
  $id = 0;
  $out = array();
  $out[$id] = "";
  for ($i = 0 ; $i < strlen($in) ; $i++) {
    $ini = substr($in, $i, 1);
    if ($st == 0) {
      if ($ini == '\\')
        $st = 1;
      else if ($ini == $sep) {
        $id++;
        $out[$id] = "";
      }
      else {
        $out[$id] .= $ini;
      }
    }
    else if ($st == 1) {
      $out[$id] .= $ini;
      $st = 0;
    }
  }

  return ($out);
}

function xcape($s)
{
  $from = array (   '\\',     '@',        '|' );
  $to   = array ( '\\\\', '&#64;', '&brvbar;' );

  return (str_replace($from, $to, htmlentities($s,ENT_COMPAT,"UTF-8")));
}

function xcapelt($s)
{
  $from = array (   '\\',     '|',  "\t",  "\n");
  $to   = array ( '\\\\',   '\\|', "\\t", "\\n");

  return (str_replace($from, $to, $s));
}

function xcapemesg($s)
{
  $from = array (  "\n");
  $to   = array ( "\\n");

  return (str_replace($from, $to, $s));
}


class Vect {
    function Vect($a)
    {
        $this->el = $a;
    }

    function getbyid($idx)
    {
        return ($this->el[$idx]);
    }

    function setbyid($idx, $v)
    {
        $this->el[$idx] = $v;
    }
}

define('TABLE_AUTH_TY_PUBL', 0);
define('TABLE_AUTH_TY_AUTH', 1);
define('TABLE_AUTH_TY_CERT', 2);


class Table {
  var $idx;
  var $player;
  var $player_n;

  var $auth_type;     // required authorization to sit down

  var $wag_own;
  var $wag_com;
  var $wag_tout;

  var $table_token;
  var $table_start;   // information field

  var $wakeup_time;

  function Table()
  {
  }

  function create($idx)
  {
    if (($thiz = new Table()) == FALSE)
      return (FALSE);

    $thiz->idx       =   $idx;
    $thiz->player    =   array();
    $thiz->player_n  =   0;

    if ($idx < TABLES_CERT_N)
        $thiz->auth_type =   TABLE_AUTH_TY_CERT;
    else if ($idx < TABLES_AUTH_N)
        $thiz->auth_type =   TABLE_AUTH_TY_AUTH;
    else
        $thiz->auth_type =   TABLE_AUTH_TY_PUBL;

    $thiz->wag_own   =  -1;
    $thiz->wag_com   =  "";
    $thiz->wag_tout   =  0;

    $thiz->table_token  = "";
    $thiz->table_start  = 0;

    $thiz->wakeup_time = 0;

    return ($thiz);
  }

  function copy($from)
  {
    $this->idx = $from->idx;
    $this->player = array();
    for ($i = 0 ; $i < $from->player_n ; $i++)
      $this->player[$i] = $from->player[$i];
    $this->player_n = $from->player_n;

    log_main("PLAYER_N - parent::copy.".$this->player_n);

    $this->auth_type =  $from->auth_type;

    $this->wag_own   =  $from->wag_own;
    $this->wag_com   =  $from->wag_com;
    $this->wag_tout  =  $from->wag_tout;

    $this->table_token  = $from->table_token;
    $this->table_start  = $from->table_start;

    $this->wakeup_time = $from->wakeup_time;
  }

  function myclone($from)
  {
    if (($thiz = new Table()) == FALSE)
      return (FALSE);

    $this->copy($from);

    return ($thiz);
  }

  function spawn($from)
  {
    if (($thiz = new Table()) == FALSE)
      return (FALSE);

    $thiz->idx = $from->idx;
    $thiz->player = array();
    for ($i = 0 ; $i < $from->player_n ; $i++)
      $thiz->player[$i] = $i;
    $thiz->player_n = $from->player_n;

    $thiz->auth_type =  $from->auth_type;

    $thiz->wag_own = $from->wag_own;
    $thiz->wag_com = $from->wag_com;
    $thiz->wag_tout  =  $from->wag_tout;

    $thiz->table_token  = $from->table_token;
    $thiz->table_start  = $from->table_start;

    $thiz->wakeup_time = $from->wakeup_time;

    return ($thiz);
  }

  function wag_set($user_idx, $mesg)
  {
    log_main("WAG_SET");

    $this->wag_own  =  $user_idx;
    $this->wag_com  =  $mesg;
    $this->wag_tout =  0;
  }

  function wag_reset($timeout)
  {
    log_main("WAG_RESET");

    unset($this->wag_own);
    $this->wag_own  = -1;
    $this->wag_com  = "";
    $this->wag_tout = $timeout;
  }

  function player_get($idx)
  {
    return ($this->player[$idx]);
  }

  function player_set($idx, $player)
  {
    $this->player[$idx] = $player;
  }

  function user_add($idx)
  {
    $this->player[$this->player_n] = $idx;
    $this->player_n++;

    return ($this->player_n - 1);
  }

  function user_rem($brisk, $user)
  {
    $tabpos = $user->table_pos;

    /* verifico la consistenza dei dati */
    if ($brisk->user[$this->player[$tabpos]] == $user) {

      /* aggiorna l'array dei giocatori al tavolo. */
      for ($i = $tabpos ; $i < $this->player_n-1 ; $i++) {
        $this->player[$i] = $this->player[$i+1];
        $user_cur = $brisk->user[$this->player[$i]];
        $user_cur->table_pos = $i;
      }
      $this->player_n--;
    }
    else {
      log_main("INCONSISTENCY ON TABLE.");
    }
  }

  // Table->act_content - return 'id' of type of output required for table button
  function act_content($user)
  {
    $ret = "";
    $isstanding = ($user->subst == 'standup');
    $sitted = $this->player_n;
    $table = $this->idx;
    $cur_table = $user->table;
    $allowed = TRUE;

    if ($isstanding) {
      if ($sitted < PLAYERS_N) {
          switch ($this->auth_type) {
          case TABLE_AUTH_TY_CERT:
              if ($user->is_cert())
                  $act = "sitcert";
              else
                  $act = 'resercert';
              break;
          case TABLE_AUTH_TY_AUTH:
              if ($user->is_auth())
                  $act = "sitreser";
              else
                  $act = 'reserved';
              break;
          default:
              $act = 'sit';
              break;
          }
      }
      else {
        $act = 'none';
      }
    }
    else {
      if ($table == $cur_table)
        $act = 'wake';
      else
        $act = 'none';
    }

    if ($act != '')
      $ret = sprintf('j_tab_act_cont(%d, \'%s\');', $table, $act);

    return ($ret);
  }
} // end class Table


class Delay_Manager
{
    var $delta;
    var $lastckeck;
    var $triglevel;

    function Delay_Manager($triglevel)
    {
        $this->triglevel = $triglevel;
        $this->delta = array();
        $this->lastcheck = 0;
    }

    function delta_get($curtime)
    {
        // clean too old delta items
        for ($i = 0 ; $i < count($this->delta) ; $i++) {
            if ($this->delta[$i][0] < $curtime) {
                array_splice($this->delta, $i, 1);
                $i--;
            }
        }

        // add new delta items if delay exceeded $this->triglevel sec
        if ($curtime > $this->lastcheck + $this->triglevel && $curtime < $this->lastcheck + 1200.0) {
            $delta = $curtime - $this->lastcheck - $this->triglevel;
            array_push($this->delta, array($curtime + $delta , $delta));
            // fprintf(STDERR, "DELTA: add new delta [%f] [%f] [%f]\n", $this->triglevel, $curtime + $delta, $delta);
        }

        // extract the maximum valid delta
        $delta_max = 0.0;
        for ($i = 0 ; $i < count($this->delta) ; $i++) {
            $delta_cur = $this->delta[$i][1];
            if ($delta_max < $delta_cur)
                $delta_max = $delta_cur;
        }

        // fprintf(STDERR, "DELTA: status %d, delta_max: %f\n", count($this->delta), $delta_max);

        return ($delta_max);
    }

    function lastcheck_set($curtime)
    {
        $this->lastcheck = $curtime;
    }
}

class Client_prefs {
    var $listen;
    var $supp_comp;

    function Client_prefs()
    {
    }

    static function from_user($user)
    {
        $thiz = new Client_prefs();
        $thiz->user_load($user);

        return ($thiz);
    }

    static function from_json($json)
    {
        $thiz = new Client_prefs();
        if ($thiz->json_load($json) == FALSE) {
            unset($thiz);
            return (FALSE);
        }

        return ($thiz);
    }

    function user_load($user)
    {
        fprintf(STDERR, "QQ %s: %x\n", __FUNCTION__, $user->flags);
        $this->listen = ($user->flags & USER_FLAG_MAP_AUTH) >> 2;
        if ($user->rec != FALSE) {
            $this->supp_comp = $user->rec->supp_comp_get();
        }
        else {
            $this->supp_comp = "000000000000";
        }

        fprintf(STDERR, "QQ %s: LISTEN: %d\n", __FUNCTION__, $this->listen);
    }

    function json_load($json_s)
    {
        $ret = FALSE;

        do {
            if (gettype($json_s) == "string") {
                if (($json = json_decode($json_s)) == FALSE)
                    break;
            }
            else {
                $json = $json_s;
            }
            if ($this->listen < 0 || $this->listen > 2)
                break;
            $this->listen = $json->listen;

            if (mb_strlen($json->supp_comp, "ASCII") != 12)
                break;

            for ($i = 0, $idx = 0 ; $i < 12 ; $i++) {
                if (($json->supp_comp[$i] >= '0' && $json->supp_comp[$i] <= '9') ||
                    ($json->supp_comp[$i] >= 'a' && $json->supp_comp[$i] <= 'f'))
                    continue;
                break;
            }
            if ($i < 12)
                break;
            $this->supp_comp = $json->supp_comp;
            $ret = TRUE;
        } while (FALSE);

        return ($ret);
    }

    function store($user, $is_save)
    {
        // save into DB
        fprintf(STDERR, "QQ %s::%s PRE: %x\n", __CLASS__, __FUNCTION__,
                $user->flags & (~USER_FLAG_S_ALL & ~USER_FLAG_AUTH));
        $user->flags_set(($this->listen << 2), USER_FLAG_MAP_AUTH);
        fprintf(STDERR, "QQ %s::%s %x\n", __CLASS__, __FUNCTION__,
                $user->flags);
        if ($user->is_supp_custom()) {
            $user->rec->supp_comp_set($this->supp_comp);
        }
        if ($is_save)
            $user->prefs_store();
    }
}

define('GHOST_SESS_TOUT', 1800);
define('GHOST_SESS_REAS_LOUT', 1); // logout
define('GHOST_SESS_REAS_ANOT', 2); // another user get session
define('GHOST_SESS_REAS_TOUT', 3); // room timeout
define('GHOST_SESS_REAS_TTOT', 4); // table timeout
define('GHOST_SESS_REAS_ANON', 5); // anonymizer access

class GhostSessEl
{
    var $time;
    var $sess;
    var $reas;

    function GhostSessEl($time, $sess, $reas)
    {
        $this->time = $time + GHOST_SESS_TOUT;
        $this->sess = $sess;
        $this->reas = $reas;
    }
}

class GhostSess
{
    var $gs;

    function GhostSess()
    {
        $this->gs = array();
    }

    // push or update for this session
    function push($time, $sess, $reas)
    {
        foreach($this->gs as $el) {
            if ($el->sess == "$sess") {
                $el->reas = $reas;
                $el->time = $time + GHOST_SESS_TOUT;
                return TRUE;
            }
        }

        $this->gs[] = new GhostSessEl($time, $sess, $reas);
        return TRUE;
    }

    function pop($sess)
    {
        foreach($this->gs as $key => $el) {
            if ($el->sess == "$sess") {
                $ret = $this->gs[$key];
                unset($this->gs[$key]);
                return ($ret);
            }
        }
        return FALSE;
    }

    function garbage_manager($curtime)
    {
        foreach($this->gs as $key => $el) {
            if ($el->time < $curtime) {
                unset($this->gs[$key]);
            }
        }
    }
}

class Brisk
{
    static $delta_t;

    var $crystal_filename;
    var $user;
    var $table;
    var $match;
    var $comm; // commands for many people
    var $step; // current step of the comm array
    var $garbage_timeout;
    var $shm_sz;

    var $ban_list;  // ban list (authized allowed)
    var $black_list;  // black list (anti-dos, noone allowed)
    var $provider_proxy; // list of provider/browser that offer proxy service
    var $ghost_sess;
    var $delay_mgr;

    var $cds;

    public static $sess_cur;

    function Brisk()
    {
        $this->cds = NULL;
    }

    // constructor
    static function create($crystal_filename, $ban_list, $black_list, $prov_proxy) {
        if (($brisk_ser = @file_get_contents($crystal_filename)) != FALSE) {
            if (($brisk = unserialize($brisk_ser)) != FALSE) {
                fprintf(STDERR, "ROOM FROM FILE\n");
                rename($crystal_filename, $crystal_filename.".old");

                $brisk->reload(TRUE, $ban_list, $black_list, $prov_proxy);

                return($brisk);
            }
        }

        fprintf(STDERR, "NEW ROOM\n");
        $thiz = new Brisk();

        $thiz->crystal_filename = $crystal_filename;
        $thiz->user  = array();
        $thiz->table = array();
        $thiz->match = array();

        $thiz->ban_list = IpClass::create();
        $thiz->black_list = IpClass::create();
        $thiz->provider_proxy = ProviderProxy::create();
        $thiz->ghost_sess = new GhostSess();

        for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
            $thiz->user[$i] = User::create($thiz, $i, "", "");
        }

        for ($i = 0 ; $i < TABLES_N ; $i++) {
            $thiz->table[$i] = Table::create($i);
        }
        $thiz->garbage_timeout = 0;
        $thiz->shm_sz = SHM_DIMS_MIN;

        $thiz->delay_mgr = new Delay_Manager(1.5);

        static::$sess_cur = FALSE;

        $thiz->reload(TRUE, $ban_list, $black_list, $prov_proxy);

        return ($thiz);
    }

    function reload($is_first, $ban_list, $black_list, $prov_proxy)
    {
        fprintf(STDERR, "RELOAD STUFF (%d)(%d)(%d)\n", count($ban_list), count($black_list), count($prov_proxy));

        if (defined('CURL_DE_SAC_VERS')) {
            if (brisk_cds_reload($this) == FALSE) {
                exit(12);
            }
        }
        $this->ban_list->update($ban_list);
        $this->black_list->update($black_list);
        $this->provider_proxy->update($prov_proxy);

        if (!$is_first) {
            $this->banned_kickoff();
            $this->garbage_manager(TRUE);
        }
    }

    function banned_kickoff()
    {
        $is_ban = FALSE;

        for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
            $table_cur = $this->table[$table_idx];
            // if the table is complete and exists we check users IP

            if ($table_cur->player_n == PLAYERS_N) {
                if (isset($this->match[$table_idx]) &&
                    $table_cur->table_token == $bin5->table_token) {
                    log_main("PLAYERS == N TABLE ".$table_idx);

                    $bin5 = $this->match[$table_idx];

                    $is_ban |= $bin5->banned_kickoff();
                }
            }
        }

        for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
            $user_cur = $this->user[$i];

            if ($user_cur->is_active() == FALSE)
                continue;

            // check if the IP is blacklisted
            if ($this->black_check($user_cur->ip)) {
                $user_cur->lacc = 0;
                $is_ban = TRUE;
                continue;
            }

            // if authorized not check if banlisted
            if ($user_cur->is_auth()) {
                continue;
            }

            if ($this->ban_check($user_cur->ip)) {
                $user_cur->lacc = 0;
                $is_ban = TRUE;
            }
        }

        return $is_ban;
    }

    function ban_check($ip_str)
    {
        return ($this->ban_list->check($ip_str));
    }

    function black_check($ip_str)
    {
        return ($this->black_list->check($ip_str));
    }

    function pproxy_realip($header, $ip_str)
    {
        return ($this->provider_proxy->realip($header, $ip_str));
    }

    function users_cleanup()
    {
        for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
            $user_cur = $this->user[$i];

            if ($user_cur->the_end) {
                $user_cur->reset(); // users_cleanup, OK
            }
        }
    }

  function garbage_manager($force)
  {
    GLOBAL $G_lang, $mlang_brisk, $G_base;

    $ismod = FALSE;

    log_rd2("garbage_manager START");

    /* Garbage collector degli utenti in timeout */
    $curtime = microtime(TRUE);

    $delta = $this->delay_mgr->delta_get($curtime);

    if (!$force && !($this->garbage_timeout < $curtime)) {
        $this->delay_mgr->lastcheck_set($curtime);
        return ($ismod);
    }

    // Before all align times with table timeout
    for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
        $table_cur = $this->table[$table_idx];
        // if the table is complete and exists its shared mem we get the info about users lacc

        if ($table_cur->player_n == PLAYERS_N) {
            log_main("PLAYERS == N TABLE ".$table_idx);


            $no_recovery = FALSE;
            if (isset($this->match[$table_idx])) {
                $bin5 = $this->match[$table_idx];

                if ($table_cur->table_token != $bin5->table_token) {
                    log_main("ERROR: not matching table_token. Brisk: ".$table_cur->table_token."  Table: ".$bin5->table_token);
                    log_main("ERROR: not matching table_start. Brisk: ".$table_cur->table_start."  Table: ".$bin5->table_start);
                    $no_recovery = TRUE;
                    $bin5 = FALSE;
                }

                if ($bin5 != FALSE) {
                    //
                    //  SPAWN: JOIN
                    //
                    log_main("garbage_manager: bri loaded successfully.");
                    $bin5->garbage_manager(TRUE);

                    $bin5_table = $bin5->table[0];

                    // is the end of the table

                    if ($bin5->the_end == TRUE) {
                        /*
                         *  DESTROY OF FINISHED TABLE && MOVE PLAYER TO ROOM AGAIN
                         */
                        log_main("garbage_manager: INSIDE THE END.");

                        $plist = "$table_cur->table_token|$table_cur->idx|$table_cur->player_n";
                        for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
                            $plist .= '|'.$this->user[$table_cur->player[$i]]->sess;
                        }

                        for ($i = 0 ; $i < $bin5_table->player_n ; $i++) {
                            // stat must be "table" by definition
                            $user_cur = $this->user[$table_cur->player[$i]];
                            $bin5_user = $bin5->user[$i];

                            $user_cur->subst      = $bin5_user->subst;
                            $user_cur->rd_step    = $bin5_user->rd_step;
                            $user_cur->step       = $bin5_user->step;
                            $user_cur->lacc       = $bin5_user->lacc;
                            $user_cur->laccwr     = $bin5_user->lacc;
                            $user_cur->bantime    = $bin5_user->bantime;
                            $user_cur->the_end    = $bin5_user->the_end;
                            if ($user_cur->the_end) {
                                $this->ghost_sess->push($curtime, $user_cur->sess, GHOST_SESS_REAS_TTOT);
                            }
                        }

                        log_legal($curtime, $user_cur->ip, $user_cur, "STAT:DESTROY_GAME", $plist);

                        $this->room_join_wakeup($user_cur, FALSE, 0);
                        $table_cur->table_token = "";
                        $table_cur->wakeup_time = $curtime + WAKEUP_TIME;

                        $this->match_del($table_idx);
                    }
                    else {
                        log_main("gm:: save_data");

                        for ($i = 0 ; $i < $bin5_table->player_n ; $i++) {
                            $this->user[$table_cur->player[$i]]->lacc = $bin5->user[$i]->lacc;
                        }
                    }
                } // if ($bin5 == FALSE
                else if ($no_recovery == FALSE) {
                    log_crit("ERROR: table ".$table_idx." unrecoverable join");

                    for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
                        $user_cur = $this->user[$table_cur->player[$i]];
                        $user_cur->subst = "shutdowner";
                        $user_cur->step_inc();

                        $ret = sprintf('stat = "%s"; subst = "%s";',  $user_cur->stat, $user_cur->subst);
                        $ret .= "gst.st = ".($user_cur->step+1)."; ";
                        // MLANG <br>I dati del tavolo n&deg; ".$user_cur->table." sono inconsistenti, verranno resettati.<br><br>Torni in piedi.<br><br>
                        $prestr = sprintf($mlang_brisk['tabincon'][$G_lang], $user_cur->table);
                        $ret .= show_notify($prestr, 2000, $mlang_brisk['btn_close'][$G_lang], 400, 110);
                        $user_cur->comm[$user_cur->step % COMM_N] = $ret;
                        $user_cur->step_inc();
                    }

                    $plist = "$table_cur->table_token|$user_cur->table|$table_cur->player_n";
                    for ($i = 0 ; $i < $table_cur->player_n ; $i++) {
                        $plist .= '|'.$this->user[$table_cur->player[$i]]->sess;
                    }
                    log_legal($curtime, $user_cur->ip, $user_cur, "STAT:DESTROY_GAME(RECOVERY)", $plist);

                    $this->room_join_wakeup($user_cur, TRUE, -2);
                    $table_cur->table_token = "";
                }
            }
        } //  if ($table_cur->player_n == PLAYERS_N) {
    } //  for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {

    log_rd2("out new loop.");

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
        $user_cur = $this->user[$i];

        log_rd2("User: ".$user_cur->name."  stat: ".$user_cur->stat."  subst: ".$user_cur->subst);

        if ($user_cur->is_active() == FALSE)
            continue;

        if ($user_cur->lacc + EXPIRE_TIME_RD < ($curtime - $delta)) {
            // Auto logout dell'utente
            log_rd2("AUTO LOGOUT.".($user_cur->lacc + EXPIRE_TIME_RD)." curtime - delta ".($curtime - $delta));

            $this->ghost_sess->push($curtime, $user_cur->sess, GHOST_SESS_REAS_TOUT);
            $user_cur->the_end = TRUE;

            log_rd2("AUTO LOGOUT.");
            if ($user_cur->stat == 'table' || $user_cur->stat == 'room') {
                log_auth($user_cur->sess, "Autologout session.");

                if ($user_cur->subst == 'sitdown' || $user_cur->stat == 'table')
                    $this->room_wakeup($user_cur);
                else if ($user_cur->subst == 'standup')
                    $this->room_outstandup($user_cur);
                else
                    log_rd2("LOGOUT FROM WHAT ???");
            }
        }

        if ($user_cur->laccwr + EXPIRE_TIME_SMAMMA < ($curtime - $delta)) { // lo rimettiamo in piedi
            if ($user_cur->stat == 'room' && $user_cur->subst == 'sitdown') {
                $this->room_wakeup($user_cur);
                $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
                /* MLANG: <br>Sei stato inattivo per ".(EXPIRE_TIME_SMAMMA/60.0)." minuti. <br><br>Quindi ritorni tra i <b>Giocatori in piedi</b>.", "torna ai tavoli" */
                $user_cur->comm[$user_cur->step % COMM_N] .=  show_notify($mlang_brisk['tabtout_a'][$G_lang].(EXPIRE_TIME_SMAMMA/60.0).$mlang_brisk['tabtout_b'][$G_lang], 0, $mlang_brisk['btn_backstand'][$G_lang], 400, 100);
                $user_cur->step_inc();
            }
        }
    }
    log_rd2("GARBAGE UPDATED!");

    $this->garbage_timeout = $curtime + GARBAGE_TIMEOUT;
    $ismod = TRUE;

    $this->ghost_sess->garbage_manager($curtime);

    $this->delay_mgr->lastcheck_set($curtime);
    return ($ismod);
  }

  function show_room($user_step, $user)
  {
    GLOBAL $G_lang, $mlang_brisk;
    log_main("show_room: username: ".$user->name);

    $ret = sprintf('gst.st = %d; ',  $user_step);

    $prefs = Client_prefs::from_user($user);
    $ret .= sprintf('prefs_load(\'%s\', false, false);', json_encode($prefs));

    if(false) {
        if ($user->flags & USER_FLAG_ISOLAUTH) {
            $ret .= 'list_set(\'isolation\', false, \''.$mlang_brisk['tit_onisol'][$G_lang].'\' ); ';
        }
        else if ($user->flags & USER_FLAG_LISTAUTH) {
            $ret .= 'list_set(\'auth\', false, \''.$mlang_brisk['tit_onauth'][$G_lang].'\' ); ';
        }
        else {
            $ret .= 'list_set(\'all\', false, \'\' ); ';
        }
    }

    if ($user->subst == 'standup')
      $ret .= "tra.show(); ";
    else
      $ret .= "tra.hide(); ";

    $ret .= sprintf('stat = "%s";',  $user->stat);

    $ret .= root_welcome($user);
    if ($user->flags & USER_FLAG_DBFAILED) {
        $ret .= "gst.st = ".($user->step+1)."; ";
        $ret .= show_notify($mlang_brisk['db_failed'][$G_lang], 0, $mlang_brisk['btn_close'][$G_lang], 400, 140);
    }

    $ret .= sprintf('subst = "%s";', $user->subst);
    $ret .= $user->myname_innerHTML();

    for ($i = 0 ; $i < TABLES_N ; $i++) {

      $ret .= $this->table_content($user, $i);

      $ret .=  $this->table[$i]->act_content($user);
      if ($this->table[$i]->wag_own != -1)
        $ret .= sprintf('tra.add(%d, "%s: %s"); ', $i,  $this->user[$this->table[$i]->wag_own]->name, $this->table[$i]->wag_com);
      else
        $ret .= sprintf('tra.rem(%d); ', $i);
    }
    $ret .= $this->standup_content($user);
    $ret .= "setTimeout(preload_images, 0, g_preload_img_arr, g_imgct); ";

    return ($ret);
  }


  function room_wakeup($user)
  {
    $table_idx = $user->table;
    $table = $this->table[$table_idx];

    log_main("WAKEUP: begin function table:".$table_idx."  stat: ".$user->stat."  subst: ".$user->subst);

    $curtime = time();

    $from_table = ($user->stat == "table");
    if ($from_table) {
        log_main("WAKEUP: from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);

        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user_cur = $this->user[$table->player[$i]];
            log_main("PREIMPOST: INLOOP name: ".$user_cur->name);

            if ($user->idx_get() != $table->player[$i]) {
                $user_cur->stat_set("room");
                $user_cur->subst = "sitdown";
                $user_cur->laccwr = $curtime;
            }
            else if ($user->is_active()) {
                $user_cur->stat_set("room");
                $user_cur->subst = "standup";
                $user_cur->laccwr = $curtime;
                $user_cur->table = -1;
            }
        }
    }
    else {
        $user->stat_set("room");
        $user->subst = "standup";
        $user->laccwr = $curtime;
    }

    $remove_wagon = FALSE;
    if($table->wag_own == $user->idx_get()) {
        $table->wag_reset($curtime);
        $remove_wagon = TRUE;
    }


    /* aggiorna l'array dei giocatori al tavolo. */
    $table->user_rem($this, $user);

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $user_cur = $this->user[$i];
      if ($user_cur->is_active() == FALSE || $user_cur->stat != 'room') // is not active user or the stat isn't 'room'
        continue;

      // log_main("VALORI: name: ".$user_cur->name."from_table: ".$from_table."  tab: ".$user_cur->table." taix: ".$table_idx."  ucur: ".$user_cur."  us: ".$user);

      $ret = "gst.st = ".($user_cur->step+1)."; ".($remove_wagon ? sprintf("tra.rem(%d);",$table_idx) : "");
      if ($from_table && ($user_cur->table == $table_idx || $user->idx_get() == $i)) {
        $ret .= 'gst.st_loc++; xstm.stop(); window.onunload = null; window.onbeforeunload = null; document.location.assign("index.php");|';
        // $ret .= 'gst.st_loc++; document.location.assign("index.php");|';
        log_main("DOCUMENT.index.php: from table");
      }
      else if ($user_cur->stat == "room") {
        log_main("DOCUMENT.index.php: from table");

        $ret .= $this->table_content($user_cur, $table_idx);
        $ret .= $this->standup_content($user_cur);

        // $ret .= table_act_content(FALSE, 0, $table_idx, $user->table, FALSE);
        $ret .= $table->act_content($user);

        if ($user->idx_get() == $i) {
          // set the new status
          $ret .=  'subst = "standup"; tra.show(); ';
          // clean the action buttons in other tables
          for ($e = 0 ; $e < TABLES_N ; $e++) {
            if ($this->table[$e]->player_n < PLAYERS_N) {
              $ret .= $this->table[$e]->act_content($user);
            }
          }
        }
        else {
          $ret .= $table->act_content($user_cur);
        }
      }
      log_wr("ROOM_WAKEUP: ".$ret);
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }
  }

  function room_join_wakeup($user, $update_lacc = FALSE, $trans_delta)
  {
    $table_idx = $user->table;
    $table = $this->table[$table_idx];

    log_main("JOIN_WAKEUP: begin function table:".$table_idx."  stat: ".$user->stat."  subst: ".$user->subst);

    $curtime = time();
    $user_wup = array();
    $user_wup_n = 0;
    $user_tab = array();
    $user_tab_n = 0;
    log_main("JOIN WAKEUP: from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);

    for ($i = 0 ; $i < $table->player_n ; $i++) {
        $user_cur = $this->user[$table->player[$i]];
        log_main("PREIMPOST INLOOP name: ".$user_cur->name);
        if ($user_cur->is_empty()) {
            continue;
        }
        if ($update_lacc == TRUE) {
            $user_cur->laccwr = $curtime;
        }
        log_main("cur: ".$user_cur->name."  subst: ".$user_cur->subst);
        if ($user_cur->subst == "shutdowned") {
            $user_cur->stat_set("room");
            $user_cur->subst = "sitdown";
        }
        else if ($user_cur->subst == "shutdowner") {
            $user_cur->stat_set("room");
            $user_cur->subst = "standup";
            $user_cur->table = -1;
            $user_wup[$user_wup_n++] = $user_cur;

            $remove_wagon = FALSE;
            if($table->wag_own == $table->player[$i]) {
                $remove_wagon = TRUE;
                $table->wag_reset($curtime);
            }
        }
        $user_tab[$user_tab_n++] = $table->player[$i];
    }

    for ($wup_idx = 0 ; $wup_idx < $user_wup_n  ; $wup_idx++)
      $table->user_rem($this, $user_wup[$wup_idx]);

    /* aggiorna l'array dei giocatori al tavolo. */

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      log_main("START LOOP");
      $user_cur = $this->user[$i];
      if ($user_cur->is_active() == FALSE || $user_cur->stat != 'room') { // is not active user or the stat isn't 'room'
        log_main("name: ".$user_cur->name."skip   subst: ".$user_cur->subst);
        continue;
      }

      log_main("___");
      log_main("VALORI name: ".$user_cur->name."  tab: ".$user_cur->table." taix: ".$table_idx);

      $ret = "gst.st = ".($user_cur->step+1)."; ".($remove_wagon ? sprintf("tra.rem(%d);",$table_idx) : "");
      if ($user_cur->stat == "room") {
        log_main("DOCUMENT.index.php from table");

        $ret .= $this->table_content($user_cur, $table_idx);
        $ret .= $this->standup_content($user_cur);

        $ret .= $table->act_content($user_cur);


        for ($tab_idx = 0 ; $tab_idx < $user_tab_n  ; $tab_idx++)
            if ($user_tab[$tab_idx] == $i)
                break;

        // for users that wakeup the room will be reconstructed by index_rd.php
        if ($tab_idx < $user_tab_n) {
          log_main("PRE show_room username: ".$user_cur->name."  STEP: ".$user_cur->step);

//        ARRAY_POP DISABLED
//           if ($trans_delta == 0)
//             while (array_pop($user_cur->comm) != NULL);

          $user_cur->trans_step = $user_cur->step + 1 + $trans_delta;
          $user_cur->comm[$user_cur->step % COMM_N] = "";
          $user_cur->step_inc();
          $user_cur->comm[$user_cur->step % COMM_N] = $this->show_room(($user_cur->step + 1), $user_cur);
          $user_cur->step_inc();
          log_main("POST show_room username: ".$user_cur->name."  STEP: ".$user_cur->step);

          continue;
        }
        log_main("JOIN_WAKEUP wup_idx ".$wup_idx."  wup_n ".$user_wup_n);

        log_main("JOIN_WAKEUP more");

        $ret .= $table->act_content($user_cur);

        log_main("JOIN_WAKEUP end more");
      }
      log_wr("ROOM_JOIN_WAKEUP: ".$ret);
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }
  }

  function guarantee_show($user, $user_login, $dt)
  {
      GLOBAL $G_lang, $mlang_brisk, $G_base;

      $user_code = -1;
      $ret = 0;

      do {
          if ($user_login == "") {
              $ret = 1;
              break;
          }
          if (($bdb = BriskDB::create()) == FALSE) {
              $ret = 2;
              break;
          }
          if (($user_item = $bdb->getitem_bylogin($user_login, $user_code)) == FALSE) {
              $ret = 3;
              break;
          }
          if (($guar_item = $bdb->getitem_bycode($user_item->guar_code_get())) != FALSE) {
              $guar_login = $guar_item->login_get();
          }
          else {
              $guar_login = "";
          }
          $user_tos_vers = $user_item->tos_vers_get();

          if (versions_cmp($user_tos_vers, "1.2") < 0) {
              $mesg = nickserv_msg($dt, sprintf($mlang_brisk['tos_old'][$G_lang], xcape($user_login)));
          }
          else if ($guar_login == "") {
              $mesg = nickserv_msg($dt, sprintf($mlang_brisk['gua_nfd'][$G_lang], xcape($user_login)));
          }
          else if ($guar_login == $user_login) {
              $mesg = nickserv_msg($dt, sprintf($mlang_brisk['gua_self'][$G_lang], xcape($user_login)));
          }
          else {
              $mesg = nickserv_msg($dt, sprintf($mlang_brisk['gua_info'][$G_lang],
                                                xcape($user_login), xcape($guar_login)));
          }
      } while (0);

      if ($ret > 0) {
          $mesg = nickserv_msg($dt, sprintf($mlang_brisk['gua_err'][$G_lang], $ret));
      }

      $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ".$mesg;
      $user->step_inc();

      return TRUE;
  }

  function room_outstandup($user)
  {
    $this->room_sitdown($user, -1);
  }

  function table_update($user)
  {
    log_main("table_update: pre - USER: ".$user->name);

    $table_idx = $user->table;

    if ($table_idx > -1)
      $table = $this->table[$table_idx];

    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $ret = "";
      $user_cur = $this->user[$i];
      if ($user_cur->is_active() == FALSE || $user_cur->stat != 'room') // is not active user or the stat isn't 'room'
          continue;

      $ret = "gst.st = ".($user_cur->step+1)."; ";
      if ($table_idx > -1)
        $ret .= $this->table_content($user_cur, $table_idx);

      if ($user->idx_get() == $i) {
          $ret .= $user->myname_innerHTML();
      }
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }

    log_main("table_update: post");
  }

  function room_sitdown($user, $table_idx)
  {
      log_main("room_sitdown ".($user == FALSE ? "USER: FALSE" : "USER: ".$user->name));

      $train_app = "";

      if ($table_idx > -1 && $table_idx < TABLES_N) {
          $table = $this->table[$table_idx];

          // wagon shutdown
          if ($table->wag_own != -1 && $table->player_n == PLAYERS_N) {
              for ($i = 0 ; $i < TABLES_N ; $i++) {
                  if ($table->wag_own == $table->player[$i]) {
                      $train_app = sprintf("tra.rem(%d); ", $table_idx);
                      $table->wag_reset(time());
                      break;
                  }
              }
          }
      }

      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
          $ret = "";
          $user_cur = $this->user[$i];
          if ($user_cur->is_active() == FALSE || $user_cur->stat != 'room') // is not active user or the stat isn't 'room'
              continue;

          $ret = "gst.st = ".($user_cur->step+1)."; ".$train_app;
          if ($table_idx > -1)
              $ret .= $this->table_content($user_cur, $table_idx);
          $ret .= $this->standup_content($user_cur);

          if ($user->idx_get() == $i) {
              $ret .=  'subst = "sitdown"; tra.hide(); ';
              // clean the action buttons in other tables
              for ($e = 0 ; $e < TABLES_N ; $e++) {
                  $ret .= $this->table[$e]->act_content($user_cur);
              }
          }
          else if ($table_idx > -1) {
              if ($table->player_n == PLAYERS_N) {

                  $ret .= $table->act_content($user_cur);
              }
          }
          $user_cur->comm[$user_cur->step % COMM_N] = $ret;
          $user_cur->step_inc();
      }
  }

  function kickuser($user, $out_reas)
  {
      $curtime = time();

      fprintf(STDERR, "MOP: GHOST_SESS: %d\n", $out_reas);

      $this->ghost_sess->push($curtime, $user->sess, $out_reas);

      fprintf(STDERR, "MOP: status out: %s %s %d\n", $user->stat, $user->subst, $user->idx);
      if ($user->stat == 'table' && $user->subst != 'sitdown') {
          $bin5 = &$this->match[$user->table];
          $user_bin5 = &$bin5->user[$user->table_pos];
          fprintf(STDERR, "MOP: status in: %s %s %d\n", $user_bin5->stat, $user_bin5->subst, $user_bin5->idx);
          $bin5->table_wakeup($user_bin5);
          $user->the_end = TRUE;
          $this->room_wakeup($user);
          return;
      }

      if ($user->stat == 'table' || $user->stat == 'room') {
          $user->the_end = TRUE;
          if ($user->subst == 'sitdown' || $user->stat == 'table') {
              $this->room_wakeup($user);
          }
          else if ($user->subst == 'standup') {
              fprintf(STDERR, "MOP: KICK here [%s]\n", btrace_line(debug_backtrace()));
              $this->room_outstandup($user);
          }
          else {
              log_rd2("LOGOUT FROM WHAT ???");
          }
      }
  }

  function kickuser_by_name($name, $out_reas)
  {
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
          $user_out = $this->user[$i];
          if (strcmp($user_out->name, $name) == 0) {
              return ($this->kickuser($user_out, $out_reas));
          }
      }
      return FALSE;
  }

  function kickuser_by_sess($sess, $out_reas)
  {
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
          $user_out = $this->user[$i];
          if (strcmp($user_out->sess, $sess) == 0) {
              return ($this->kickuser($user_out, $out_reas));
          }
      }
      return FALSE;
  }

  function kickuser_by_idx($idx, $out_reas)
  {
      $user_out = $this->user[$idx];
      return ($this->kickuser($user_out, $out_reas));
  }

  function chatt_send($user, $mesg)
  {
    GLOBAL $G_base, $G_alarm_passwd, $mlang_brisk, $G_lang;
    $only_you = FALSE;

    // common settings
    $msg = mb_substr($mesg, 6, 128, "UTF-8");
    $curtime = time();
    $dt = date("H:i ", $curtime);
    $target = "";

    //
    //  Compute actions
    //

    $to_user     = FALSE;
    $to_all      = FALSE;
    $to_room     = FALSE;
    $to_tabl     = FALSE;
    $is_normchat = FALSE;
    /* for old isolation management $is_ticker   = FALSE; */
    $update_room = FALSE;

    if (strcmp($msg,  "/tav") == 0 ||
        strncmp($msg, "/tav ", 5) == 0) {
      do {
        if ($user->stat != 'room' || $user->subst != 'sitdown') {
          /* MLANG: "<br>Per attivare il messaggio di segnalazione del tavolo occorre essere seduti.<br><br>", "<br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br>", "<br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>" */
          $msg = $mlang_brisk['tickmust'][$G_lang];
          $to_user = show_notify($msg, 0, "chiudi", 400, 100);

          break;
        }

        $table = $this->table[$user->table];

        if ($table->wag_own != -1) {
          // MLANG <br>Il messaggio di segnalazione del tavolo &egrave; gi&agrave; attivato.<br><br>
          $msg = $mlang_brisk['tickjust'][$G_lang];
          $to_user = show_notify($msg, 0, "chiudi", 400, 100);

          break;
        }

        $dtime = $curtime - $table->wag_tout;
        if ($dtime  < EXPIRE_TIME_WAG) {
          // MLANG - <br>Il messaggio di segnalazione del tavolo<br>&egrave; disattivato ancora per %d second%s.<br><br>
          $msg = sprintf($mlang_brisk['tickwait'][$G_lang],
                         EXPIRE_TIME_WAG - $dtime, (EXPIRE_TIME_WAG - $dtime == 1 ? ($G_lang == 'en' ? "" : "o") : ($G_lang == 'en' ? "s" : "i")));
          $to_user = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang] , 400, 100);

          break;
        }

        $msg = substr($msg, 5);

        $table->wag_set($user->idx_get(), $msg);
        $to_user = sprintf('tra.add(%d, "%s");', $user->table, xcape(sprintf("%s: %s", $user->name, $msg)));
        $to_room = $to_user;
        /* for old isolation management $is_ticker = TRUE; */
      } while (0);
    } // /tav chat command
    // just for development use currently
    else if (FALSE && strncmp($msg, "/out ", 5) == 0) {
        fprintf(STDERR, "MOP OUT\n");
        $target = substr($msg, 5);
        $this->kickuser_by_name($target, GHOST_SESS_REAS_ANON);
    }
    else if (strncmp($msg, "/alarm ", 7) == 0) {
      if (strncmp($msg, "/alarm to ", 10) == 0) {
        $sp_pos = strpos($msg, " ", 10);
        $target = substr($msg, 10, $sp_pos - 10);
        $alarm_check = "/alarm to ".$target." ".$G_alarm_passwd." ";
      }
      else {
        $target = "";
        $alarm_check = "/alarm ".$G_alarm_passwd." ";
      }
      do {
        if (strncmp($msg, $alarm_check, strlen($alarm_check)) != 0) {
          /* MLANG: "<br>La password digitata non &egrave; corretta.<br><br>" */
          $msg = $mlang_brisk['alarpass'][$G_lang];
          $to_user = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang], 400, 100);

          break;
        }

        /* MLANG: "Alarm <b>%s</b> inviato a <b>%s</b>." */
        $prestr = sprintf($mlang_brisk['alarret'][$G_lang], xcape(substr($msg, strlen($alarm_check))),
                           ($target == "" ? $mlang_brisk['tit_all'][$G_lang] : xcape($target)) );
        $to_user = nickserv_msg($dt, $prestr);

        $msg = sprintf("<br><b>%s<br><br>%s</b><br><br>",
                       $dt.NICKSERV, xcape(substr($msg, strlen($alarm_check))));
        /* MLANG: "chiudi" */
        $to_all = show_notify($msg, 0, $mlang_brisk['btn_close'][$G_lang], 400, 120);
      } while (0);
    } // /alarm chat command
    else if (strncmp($msg, "/listen ", 8) == 0) {
      $arg = substr($msg, 8);

      if (strcasecmp($arg, "isolation") == 0) {
        $flags_old = 0;
        if ($user->stat == 'room' && $user->subst == 'sitdown' &&
            $user->table >= TABLES_AUTH_N) {
          $to_user = nickserv_msg($dt, $mlang_brisk['listmust'][$G_lang]);

        }
        else {
          $user->flags &= ~USER_FLAG_MAP_AUTH;
          $user->flags |= USER_FLAG_ISOLAUTH;
          $to_user = 'list_set(\'isolation\', true, \''.$mlang_brisk['tit_onisol'][$G_lang].'\'); ';
        }
      }
      else if (strcasecmp($arg, "auth") == 0) {
        $flags_old = $user->flags;
        $user->flags &= ~USER_FLAG_MAP_AUTH;
        $user->flags |= USER_FLAG_LISTAUTH;
        $to_user = 'list_set(\'auth\', true, \''.$mlang_brisk['tit_onauth'][$G_lang].'\'); ';
      }
      else {
        $flags_old = $user->flags;
        $user->flags &= ~USER_FLAG_MAP_AUTH;
        $to_user = 'list_set(\'all\', true, \'\'); ';

      }
      // if from isolation redraw standup area
      if (($flags_old ^ $user->flags) & USER_FLAG_ISOLAUTH) {
        $to_user .= 'standup_data_old = null; '.$this->standup_content($user);

      }
    }
    else if (strcmp($msg, "/authreq") == 0) {
        if ($user->is_cert()) {
            $to_user = sprintf('authbox(300,200);');
        }
        else {
            /* MLANG: "<b>Per autenticare qualcuno devi a tua volta essere autenticato.</b>", "Il nickname deve contenere almeno una lettera dell\'alfabeto o una cifra.", "Nickname <b>%s</b> gi&agrave; in uso." */
            $to_user = nickserv_msg($dt, $mlang_brisk['authmust'][$G_lang]);
        }
    }
    else if (strncmp($msg, "/mesgtoadm", 8) == 0) {
        if ($user->is_auth()) {
        $to_user = sprintf('mesgtoadmbox(500,300);');
      }
      else {
        /* MLANG: "<b>Per inviare un messaggio devi essere autenticato.</b>" */
        $to_user = nickserv_msg($dt, $mlang_brisk['mesgmust'][$G_lang]);
      }
    }
    else if (strncmp($msg, "/nick ", 6) == 0) {
      log_main("chatt_send BEGIN");

      do {
        if (($name_new = validate_name(substr($msg, 6))) == FALSE) {
          $to_user = nickserv_msg($dt, $mlang_brisk['nickmust'][$G_lang]);
          break;
        }

        $msg = "COMMAND ".$msg;
        for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
          $user_cur = $this->user[$i];

          if ($user_cur->is_active() == FALSE)
            continue;
          if (strcasecmp($user_cur->name,$name_new) == 0)
            break;
          }
        if ($i <  MAX_PLAYERS) {
          $prestr = sprintf($mlang_brisk['nickdupl'][$G_lang], xcape($name_new));
          $to_user = nickserv_msg($dt, $prestr);
          break;
        }

        /* MLANG: "<b>Non puoi cambiare nick a un tavolo per soli autenticati.</b>", "Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>" */
        if ($user->is_auth()) {
          if (strcasecmp($user->name,$name_new) != 0) {
             if (( ($user->flags & USER_FLAG_MAP_AUTH) != USER_FLAG_ISOLAUTH) &&
                ($user->subst == 'standup' ||
                 ($user->subst != 'standup' && $this->table[$user->table]->auth_type == TABLE_AUTH_TY_PUBL)
                 )
                ) {
              $user->flags &= ~(USER_FLAG_AUTH | USER_FLAG_TY_ALL); // Remove auth if name changed
              for ($i = 0 ; $i < TABLES_N ; $i++) {
                $to_user .= $this->table[$i]->act_content($user);
              }
            }
            else {
              $to_user = nickserv_msg($dt, $mlang_brisk['authchan'][$G_lang]);
              break;
            }
          }
        }
        $user->name = $name_new; // OK - nick changed
        /* se nome gia' in uso, segnala cosa potrebbe capitare */
        if ( ! $user->is_auth() ) {
            if (($bdb = BriskDB::create()) != FALSE) {
                $bdb->users_load();
                /* MLANG: "Il nickname <b>\'%s\'</b> &egrave; gi&agrave; registrato, <b>se il suo proprietario si autentificher&agrave; verrai rinominato d\'ufficio come ghost<i>N</i>.</b>" */
                if ($bdb->login_exists($name_new)) {
                    $prestr = sprintf($mlang_brisk['nickjust'][$G_lang], xcape($name_new));
                    $to_user .= nickserv_msg($dt, $prestr);
                }
            }
        }

        log_main("chatt_send start set");

        $update_room = TRUE;
      } while (0);
    } // nick chat command
    else if (strncmp($msg, "/guar ", 6) == 0 || $msg == "/guar") {
        $guar_user = substr($msg, 6);

        $this->guarantee_show($user, $guar_user, $dt);
    }
    else if (strncmp($msg, "/st ", 4) == 0) {
      log_main("chatt_send BEGIN");

      do {
        $st_str = substr($msg, 4);

        if (strcasecmp($st_str, "normale") == 0) {
          $st = USER_FLAG_S_NORM;
        }
        else if (strcasecmp($st_str, "pausa") == 0) {
          $st = USER_FLAG_S_PAU;
        }
        else if (strcasecmp($st_str, "fuori") == 0) {
          $st = USER_FLAG_S_OUT;
        }
        else if (strcasecmp($st_str, "cane") == 0) {
          $st = USER_FLAG_S_DOG;
        }
        else if (strcasecmp($st_str, "cibo") == 0) {
          $st = USER_FLAG_S_EAT;
        }
        else if (strcasecmp($st_str, "lavoro") == 0) {
          $st = USER_FLAG_S_WRK;
        }
        else if (strcasecmp($st_str, "sigaretta") == 0) {
          $st = USER_FLAG_S_SMK;
        }
        else if (strcasecmp($st_str, "presente") == 0) {
          $st = USER_FLAG_S_EYE;
        }
        else if (strcasecmp($st_str, "coniglio") == 0) {
          $st = USER_FLAG_S_RABB;
        }
        else if (strcasecmp($st_str, "calcio") == 0) {
          $st = USER_FLAG_S_SOCC;
        }
        else if (strcasecmp($st_str, "pupo") == 0) {
          $st = USER_FLAG_S_BABY;
        }
        else if (strcasecmp($st_str, "pulizie") == 0) {
          $st = USER_FLAG_S_MOP;
        }
        else if (strcasecmp($st_str, "babbo") == 0) {
          $st = USER_FLAG_S_BABBO;
        }
        else if (strcasecmp($st_str, "renna") == 0) {
          $st = USER_FLAG_S_RENNA;
        }
        else if (strcasecmp($st_str, "pupazzo") == 0) {
          $st = USER_FLAG_S_PUPAZ;
        }
        else if (strcasecmp($st_str, "vischio") == 0) {
          $st = USER_FLAG_S_VISCH;
        }
        else {
          /* MLANG: "Questo stato non esiste." */
          $to_user = nickserv_msg($dt, $mlang_brisk['statunkn'][$G_lang]);
          break;
        }

        log_main("chatt_send start set");
        if (($user->flags & USER_FLAG_S_ALL) != $st) {
          $update_room = TRUE;
          $user->flags = ($user->flags & ~USER_FLAG_S_ALL) | $st;
        }
      } while (0);
    } // nick chat command

    else { // normal chat line
      $is_normchat = TRUE;
      if (CHAT_ENABLED && $curtime < ($user->chat_ban + $user->chat_dlt)) {
        $only_you = TRUE;
        $user->chat_dlt = $user->chat_dlt * 2;
        if ($user->chat_dlt > 120)
          $user->chat_dlt = 120;
      }
      else if ($user->chat_lst == $msg)
        $only_you = TRUE;
      else if (CHAT_ENABLED && $curtime - $user->chattime[($user->chat_cur + 1) % CHAT_N] < CHAT_ILL_TIME) {
        $user->chat_ban = $curtime;
        $user->chat_dlt = 5;
        $only_you = TRUE;
      }
      else {
        $user->chat_ban = 0;
        $user->chat_dlt = 0;
      }

      if ($only_you) {
        $to_user = sprintf('chatt_sub("%s",[%d,"%s"],"%s");', $dt, $user->flags, xcape($user->name), xcape("== chat ban =="));
      }
      else {
          if ( TRUE && (! $user->is_auth()) ) {
              $to_user = nickserv_msg($dt, xcape("Visto l'elevato numero di molestatori che ultimamente hanno preso dimora su Brisk abbiamo deciso"));
              $to_user .= nickserv_msg($dt, xcape("di disattivare temporaneamente la chat in room per i non registrati, non ce ne vogliate e buone feste."));
              $aug_head = array("Tanti", "Tantissimi", "Un enormità", "Un milione", "Un' esagerazione");
              $aug_body = array("a tutti gli utenti", "a tutti gli uomini", "a tutte le donne", "a tutti gli utenti");
              $aug_tail = array("di Brisk", "del sito", "della ciurma", "della comitiva", "del gruppo");

              $auguri = sprintf("%s auguri %s %s.",
                                $aug_head[mt_rand(0, count($aug_head)-1)],
                                $aug_body[mt_rand(0, count($aug_body)-1)],
                                $aug_tail[mt_rand(0, count($aug_tail)-1)]);

              $to_room = sprintf('chatt_sub("%s",[%d,"%s"],"%s");', $dt, $user->flags, xcape($user->name),
                                 xcape($auguri));
          }
          else {
              $to_user = sprintf('chatt_sub("%s",[%d,"%s"],"%s");', $dt, $user->flags, xcape($user->name), xcape($msg));
              // temporary silentiation for troll (will became array check)
              // if (strcasecmp($user->name,'JackRokka') != 0 && $user->sess != '47ea653f602e8')
              $to_room = $to_user;
          }
      }

      log_legal($curtime, $user->ip, $user,
                ($user->stat == 'room' ? 'room' : 'table '.$user->table),$msg);

      $user->chat_lst = "$msg";
      $user->chattime[$user->chat_cur % CHAT_N] = $curtime;
      $user->chat_cur++;
    }

    if ($to_all) {
      $to_room = $to_all;
      $to_tabl = $to_all;
    }

    //
    //  Output to clients
    //

    if ($to_user != FALSE) {
      $user->comm[$user->step % COMM_N] =  "gst.st = ".($user->step+1)."; ";
      $user->comm[$user->step % COMM_N] .= $to_user;
      $user->step_inc();
    }

    if ($to_room != FALSE) {
      for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
        $user_cur = $this->user[$i];
        if ($target != "" && $user_cur->name != $target)
          continue;
        if ($user_cur->is_active() == FALSE // is not active user
            || $user_cur->stat == 'table'   // or stat is 'table'
            || $user->idx_get() == $i)      // or the $user idx is equal to current var
          continue;

        if ($is_normchat == TRUE) {
          // use MAP_AUTH to check if auth or isolation
          if ($user_cur->flags & USER_FLAG_MAP_AUTH) {
              if ( ! $user->is_auth() ) {
                  continue;
              }
          }
        }
        /*
        else if ($is_ticker) {
          if (($user_cur->flags & USER_FLAG_MAP_AUTH) == USER_FLAG_ISOLAUTH) {
            if ($user->table >= TABLES_AUTH_N)
              continue;
          }
        }
        */
        $user_cur->comm[$user_cur->step % COMM_N] =  "gst.st = ".($user_cur->step+1)."; ";
        $user_cur->comm[$user_cur->step % COMM_N] .= $to_room;
        $user_cur->step_inc();
      }
    }

    if ($to_tabl) {
        // FIXME BRISK4: include for each kind of table
        require_once("${G_base}briskin5/Obj/briskin5.phh");
        // Before all align times with table timeout
        for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
            if (isset($this->match[$table_idx])) {
                $bin5 = $this->match[$table_idx];

                $bin5_table = $bin5->table[0];
                for ($i = 0 ; $i < $bin5_table->player_n ; $i++) {
                    // stat must be "table" by definition
                    $bin5_user = $bin5->user[$i];

                    if ($target != "" && $bin5_user->name != $target)
                        continue;
                    log_main("writa: ".$user_mesg);
                    $bin5_user->comm[$bin5_user->step % COMM_N] = "gst.st = ".($bin5_user->step+1)."; ";
                    $bin5_user->comm[$bin5_user->step % COMM_N] .= $to_tabl;
                    $bin5_user->step_inc();
                }
            } // if (isset($this->match
        } //  for ($table_idx = 0 ; $table_idx < TABLES_N ; $table_idx++) {
    } // if ($to_tabl == true ...

    if ($update_room) {
      if ($user->stat == 'room' && $user->subst == 'standup') {
        $this->standup_update($user);
      }
      else if ($user->stat == 'room' && $user->subst == 'sitdown') {
        log_main("chatt_send pre table update");
        $this->table_update($user);
        log_main("chatt_send post table update");
      }
    } // if ($update_room ...

    return;
  } // function chatt_send( ...

  function get_user($sess, &$idx)
  {
      GLOBAL $PHP_SELF;

      if (validate_sess($sess)) {
          for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
              if ($this->user[$i]->is_empty())
                  continue;
              if (strcmp($sess, $this->user[$i]->sess) == 0) {
                  // find it
                  $idx = $i;
                  $ret = $this->user[$i];
                  return ($ret);
              }
          }
          log_main(sprintf("get_user: Wrong sess from page [%s]",$PHP_SELF));
          // for ($i = 0 ; $i < MAX_PLAYERS ; $i++)
          // log_main(sprintf("get_user: Wrong sess compared with [%s]",$this->user[$i]->sess));
      }
      else {
          log_main(sprintf("get_user: Wrong strlen [%s]",$sess));
      }

      return (FALSE);
  }

  /*
   * function add_user(&$brisk, &$sess, &$idx, $name, $pass, $ip, $header, $cookie)
   *
   * RETURN VALUE:
   *   if ($idx >  -1    && ret == FALSE)  =>  duplicated nick
   *   if ($idx == -2    && ret == FALSE)  =>  invalid name
   *   if ($idx == -3    && ret == FALSE)  =>  wrong password
   *   if ($idx == -1    && ret == FALSE)  =>  no space left
   *   if ($idx ==  0    && ret == user)   =>  SUCCESS
   *   if ($idx == -($idx + 1) && ret == user)   =>  SUCCESS (but the login exists in the auth db)
   */

  function add_user(&$sess, &$idx, $name, $pass, $ip, $header, $cookie)
  {
    GLOBAL $G_base;

    $idx = 0;

    $authenticate = FALSE;
    $user_type    = 0;
    $login_exists = FALSE;
    $ghost = -1;
    $ghost_auth = FALSE;
    $idx = -1;
    $idfree = -1;
    $code = FALSE;

    if (($name_new = validate_name($name)) == FALSE) {
      $idx = -2;
      return (FALSE);
    }

    log_auth("XXX", sprintf("ARRIVA: [%s] pass:[%s]", $sess, ($pass == FALSE ? "FALSE" : $pass)));
    if (validate_sess($sess) == FALSE)
      $sess = "";

    /* if pass != FALSE verify the login with pass */
    log_auth("XXX", "auth1");

    if (($bdb = BriskDB::create()) != FALSE) {
        $bdb->users_load();
        if ($pass != FALSE) { // TODO: here add a method to $bdb to check if the db is available.
            log_auth("XXX", "auth2");
            $authenticate = $bdb->login_verify($name_new, $pass, $code);
            log_auth("XXX", "authenticate: ".($authenticate != FALSE ? "TRUE" : "FALSE"));

            if ($authenticate != FALSE) {
                $user_type = $authenticate->type_get();
            }
            else {
                $idx = -3;
                return (FALSE);
            }
        }
        else {
            $login_exists =  $bdb->login_exists($name_new);
        }
    }
    else {
        // if db is down, send a warning and verify only current users
        // no actions at this moment
    }
    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
        /* free user ? */
        if ($this->user[$i]->is_empty()) {
            if ($idfree == -1) {
                $idfree = $i;
            }
            continue;
        }
        if (strcmp($sess, $this->user[$i]->sess) == 0) {
            if ($idx == -1) {
                $idx = $i;
            }
        }
        if (strcasecmp($this->user[$i]->name, $name_new) == 0) {
            if ($authenticate != FALSE) {
                $ghost = $i;
                $ghost_auth = $this->user[$i]->is_auth();
            }
            else {
                $idx = $i;
                break;
            }
        }
    }
    if ($idx == -1)
      $idx = $idfree;

    log_auth("XXX", sprintf("TROVATO A QUESTO PUNTO [%d] sess [%s] name [%s]", $idx, $sess, $name_new));

    /* there is another user logged with your account and you and him have authenticated => new user
       get the session of the old user */
    if ($ghost > -1 && $ghost_auth && ($authenticate != FALSE)) {
      /* swap session */

      $ghost_user = $this->user[$ghost];
      $curtime = time();
      $this->ghost_sess->push($curtime, $ghost_user->sess, GHOST_SESS_REAS_ANOT);
      $ghost_user->comm[$ghost_user->step % COMM_N] = "";
      $ghost_user->step_inc();
      if ($sess == "") {
        $sess = uniqid("");
        $ghost_user->sess = $sess;
      }
      else {
        $ghost_user->sess = $sess;
      }

      // If user at the table we need to update the table data too
      $table_idx = $ghost_user->table;
      if ($ghost_user->stat == "table" && $this->table[$table_idx]->player_n == PLAYERS_N) {
          require_once("${G_base}briskin5/Obj/briskin5.phh");
          if (isset($this->match[$table_idx])) {
              $bin5 = $this->match[$table_idx];

              if ($bin5->the_end != TRUE) {
                  $bin5->user[$ghost_user->table_pos]->comm[$bin5->user[$ghost_user->table_pos]->step % COMM_N] = "";
                  $bin5->user[$ghost_user->table_pos]->step_inc();
                  $bin5->user[$ghost_user->table_pos]->sess = $sess;
              }
          }
      }

      $idx = $ghost;
      if (defined('CURL_DE_SAC_VERS')) {
          brisk_cds_execute($this, $ghost, $idx, $sess, $ip, $authenticate, $header);
      }
      return ($this->user[$ghost]);
    }
    else if ($idx != -1 && $i == MAX_PLAYERS) {
      /* SUCCESS */
      $curtime = time();
      if ($sess == "") {
        $sess = uniqid("");
        $this->user[$idx]->sess = $sess;
      }
      else {
        $this->user[$idx]->sess = $sess;
      }
      $this->user[$idx]->name = $name_new; // OK - add new user
      $this->user[$idx]->stat_set("room");
      $this->user[$idx]->step_set(0);
      while (array_pop($this->user[$idx]->comm) != NULL);
      $this->user[$idx]->subst = "standup";
      $this->user[$idx]->lacc =   $curtime;
      $this->user[$idx]->laccwr = $curtime;
      $this->user[$idx]->bantime = 0;
      $this->user[$idx]->ip = $ip;

      $this->user[$idx]->rec = $authenticate;
      $this->user[$idx]->flags = $user_type;
      $this->user[$idx]->flags |= ($authenticate != FALSE ? USER_FLAG_AUTH : 0x00);
      $this->user[$idx]->flags |= ( ($pass != FALSE && $bdb == FALSE) ? USER_FLAG_DBFAILED : 0x00);
      log_auth("XXX", sprintf("FLAGS: [%x]", $this->user[$idx]->flags));

      if ($authenticate != FALSE) {
          $this->user[$idx]->code = $authenticate->code_get();
          if (0 == 1) {
              // all this part is included in the db server
              $this->user[$idx]->flags |= USER_FLAG_LISTAUTH;

              if (isset($cookie['CO_list'])) {
                  fprintf(STDERR, "QQ: %s CO_list: [%s]\n", __FUNCTION__, $cookie['CO_list']);
                  if (strcmp($cookie['CO_list'], "auth") == 0) {
                      $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
                      $this->user[$idx]->flags |= USER_FLAG_LISTAUTH;
                  }
                  if (strcmp($cookie['CO_list'], "isolation") == 0) {
                      $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
                      $this->user[$idx]->flags |= USER_FLAG_ISOLAUTH;
                  }
                  else {
                      $this->user[$idx]->flags &= ~USER_FLAG_MAP_AUTH;
                  }
              }
          }
          else {
              fprintf(STDERR, "QQ: CO_list not set flags: %x\n", __FUNCTION__, $this->user[$idx]->flags);
          }
      }
      fprintf(STDERR, "QQ %s: flag %x\n", __FUNCTION__, $this->user[$idx]->flags);
      if ($ghost > -1) {
        log_main("ghost: rename!");
        $ghost_user = $this->user[$ghost];

        if ($ghost_auth == FALSE) {
          for ($sfx = 1 ; $sfx <= MAX_PLAYERS ; $sfx++) {
            $ghostname = 'ghost'.$sfx;
            for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
              if (strcmp("", $this->user[$i]->sess) == 0)
                continue;

              if (strcasecmp($this->user[$i]->name, $ghostname) == 0) {
                $ghostname = '';
                break;
              }
            }
            if ($ghostname != '')
              break;
          }

          $ghost_user->name = $ghostname;

          if ($ghost_user->stat == 'room' && $ghost_user->subst == 'standup') {
            $this->standup_update($ghost_user);
          }
          else {
            log_main("chatt_send pre table update");
            $this->table_update($ghost_user);
          log_main("chatt_send post table update");
          }
        } // if ($ghost_auth == FALSE
        else {
          // FIXME: cacciare il vecchio utente room && table (if needed)
          $ghost_user->the_end = TRUE;
          $ghost_user->lacc = 0;
          $this->garbage_manager(TRUE);
        }
      } //  if ($ghost > -1) {

      $real_idx = $idx;
      if ($login_exists)
        $idx = -($idx + 1);
      log_main(sprintf("TROVATO LIBERO A [%d] sess [%s] name [%s] count [%d] name [%s] code [%s]", $idx, $sess, $name_new, count($this->user),$this->user[$real_idx]->name, $this->user[$real_idx]->code));

      $ret = $this->user[$real_idx];
      if (defined('CURL_DE_SAC_VERS')) {
          brisk_cds_execute($this, $ghost, $real_idx, $sess, $ip, $authenticate, $header);
      }
      return ($ret);
    }

    return (FALSE);
  }

  function standup_update($user)
  {
    for ($i = 0 ; $i < MAX_PLAYERS ; $i++) {
      $user_cur = $this->user[$i];
      if ($user_cur->is_active() == FALSE)
        continue;

      log_main("STANDUP START: ".$user_cur->stat);

      if ($user_cur->stat == 'room') {
        $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ".$this->standup_content($user_cur);
        if ($user->idx_get() == $i) {
          $user_cur->comm[$user_cur->step % COMM_N] .= $user->myname_innerHTML();
        }
        log_main("FROM STANDUP: NAME: ".$user_cur->name." SENDED: ".$user_cur->comm[$user_cur->step % COMM_N]);

        $user_cur->step_inc();
      }
    }
  }

  function dump_data()
  {
      $brisk_ser = serialize($this);
      $brisk_ser_len = mb_strlen($brisk_ser, "ASCII");
      if (file_put_contents($this->crystal_filename, $brisk_ser) == $brisk_ser_len) {
          return (TRUE);
      }

      return (FALSE);
  }

  function standup_content($user)
  {
    $ret = "";

    if ($user->stat != 'room')
      return;

    $content = ' j_stand_cont( [ ';

    $user_cur_id = $user->idx_get();
    for ($i = 0 , $ct = 0 ; $i < MAX_PLAYERS ; $i++) {
        if ($this->user[$i]->is_active() == FALSE // is not active user
            || $this->user[$i]->stat != "room"    // or the stat isn't 'room'
            || $this->user[$i]->name == "")       // or the name is empty, happens when user is reset (TODO: check it)
        continue;

      $flags = $this->user[$i]->flags;

      // sql record exists AND last donate > 2013-01-01
      if ($this->user[$i]->is_supp_custom()) {
          $supp_comp_s = sprintf(', "%s"', $this->user[$i]->rec->supp_comp_get());
      }
      else {
          $supp_comp_s = '';
      }

      if ($this->user[$i]->subst == "standup") {
          if ($user_cur_id == $i) {
              $flags |= 1;
          }

          $content .= sprintf('%s[ %d, "%s"%s ]',($ct > 0 ? ', ' : ''), $flags,
                              xcape($this->user[$i]->name), $supp_comp_s);
          $ct++;
      }
    }
    $content .= ' ]);';

    return ($content);
  }

  function table_content($user, $table_idx)
  {
    $content = "";
    $ret = "";
    // TODO
    //
    //   Si possono usare i dati nella classe table
    //

    $sess = $user->sess;
    $table = $this->table[$table_idx];

    if ($user->stat != 'room')
      return;

    $user_cur_id = $user->idx_get();
    $content = "[ ";
    for ($i = 0 ; $i < $table->player_n ; $i++) {
        $user_cur = $this->user[$table->player[$i]];

        $flags = $user_cur->flags;

        if ($user_cur_id == $table->player[$i])
            $flags |= 1;

        log_main($user_cur->name. sprintf(" IN TABLE [%d]", $table_idx));
        if ($user_cur->is_supp_custom())
            $supp_comp_s = sprintf(', "%s"', $user_cur->rec->supp_comp_get());
        else
            $supp_comp_s = '';

        $content .= sprintf('%s[ %d, "%s"%s ]',($i == 0 ? '' : ', '), $flags,
                            xcape($user_cur->name), $supp_comp_s);
    }

    $content .= ' ]';

    $ret .= sprintf('j_tab_cont(%d, %s);', $table_idx, $content);

    return ($ret);
  }

  function request_mgr(&$s_a_p, $header, &$header_out, &$new_socket, $path, $addr, $get, $post, $cookie)
  {
      GLOBAL $G_ban_list, $G_black_list, $G_provider_proxy;

      printf("NEW_SOCKET (root): %d PATH [%s]\n", intval($new_socket), $path);
      // $remote_addr = addrtoipv4($addr);
      $remote_addr = $this->pproxy_realip($header, addrtoipv4($addr));

      fprintf(STDERR, "\n\n\n PRE_BLACK_CHECK \n\n\n");
      if ($this->black_check($remote_addr)) {
          // TODO: waiting async 5 sec before close
          fprintf(STDERR, "\n\n\n BLACK CHECK\n\n\n");
          return (FALSE);
      }

      $enc = get_encoding($header);
      if (isset($header['User-Agent'])) {
          if (strstr($header['User-Agent'], "MSIE")) {
              $transp_type = "htmlfile";
          }
          else {
              $transp_type = "xhr";
          }
      }
      else {
          $transp_type = "iframe";
      }
      force_no_cache($header_out);

      switch ($path) {
      case "":
      case "index.php":
          ob_start();
          index_main($this, $transp_type, $header, $header_out, $addr, $get, $post, $cookie);
          $content = ob_get_contents();
          ob_end_clean();

          // fprintf(STDERR, "\n\nCONTENT [%s]\n\n", $content);
          $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
          return TRUE;

          break;
      case "index_wr.php":
          //
          // Enhance required: in the POST case, after the header you must get content
          //                   from the socket, waiting if necessary
          //

          ob_start();
          index_wr_main($this, $addr, $get, $post, $cookie);
          $content = ob_get_contents();
          ob_end_clean();

          $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
          return TRUE;

          break;
      case "index_rd.php":
          if (($transp  = gpcs_var('transp', $get, $post, $cookie)) === FALSE)
              $transp = "iframe";
          if ($transp == 'websocket')
              $enc = 'plain';

          do {
              if (!isset($cookie['sess'])
                  || (($user = $this->get_user($cookie['sess'], $idx)) == FALSE)) {

                  $content = User::stream_fini($transp, $s_a_p->rndstr, TRUE);

                  $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
                  return TRUE;

                  break;
              }
              $this->sess_cur_set($user->sess);
              // close a previous opened index_read_ifra socket, if exists
              if (($prev = $user->rd_socket_get()) != NULL) {
                  $s_a_p->socks_unset($user->rd_socket_get());
                  fclose($user->rd_socket_get());
                  printf("CLOSE AND OPEN AGAIN ON IFRA2\n");
                  $user->rd_socket_set(NULL);
              }

              $content = "";
              $user->stream_init($s_a_p->rndstr, $enc, $header, $header_out, $content, $get, $post, $cookie);
              $response = headers_render($header_out, -1).$user->chunked_content($content);
              $response_l = mb_strlen($response, "ASCII");

              $wret = @fwrite($new_socket, $response, $response_l);
              if ($wret < $response_l) {
                  printf("TROUBLES WITH FWRITE: %d\n", $wret);
                  $user->rd_cache_set(mb_substr($content, $wret, $response_l - $wret, "ASCII"));
              }
              else {
                  $user->rd_cache_set("");
              }
              fflush($new_socket);


              $s_a_p->socks_set($new_socket, $user, NULL);
              $user->rd_socket_set($new_socket);
              printf(" - qui ci siamo - ");
              return TRUE;
          } while (FALSE);

          return FALSE;
          break;
      case 'test.php':
          if (!(BRISK_DEBUG & DBG_ENGI))
              return (FALSE);
          fprintf(STDERR, "TEST.PHP running\n");
          if (isset($post['data'])) {
              $content = $post['data'];
          }
          else {
              $content = "NO DATA AVAILABLE";
          }
          $header_out['Content-Type'] = 'text/plain';
          $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
          return TRUE;
          break;
      default:
          /* FAR TODO: move all into an array of registered sub-apps */
          $subs = "briskin5/";
          $subs_l = strlen($subs);
          if (!strncmp($path, $subs, $subs_l)) {
              $ret = Bin5::request_mgr(&$s_a_p, $header, &$header_out, &$new_socket, substr($path, $subs_l) , $addr, $get, $post, $cookie);
              return ($ret);
          }
          break;
      }

      return (FALSE);
  }

  function match_add($idx, $match)
  {
      $this->match[$idx] = $match;
  }

  function match_del($idx)
  {
      unset($this->match[$idx]);
  }

  function match_get($idx, $token)
  {
      if (isset($this->match[$idx])) {
          if (   $token == NULL
              || $token == $this->match[$idx]->table_token) {
              return ($this->match[$idx]);
          }
      }
      return NULL;
  }
  function sess_cur_set($sess)
  {
      static::$sess_cur = $sess;
  }

  static function sess_cur_get()
  {
      return(static::$sess_cur);
  }
} // end class Brisk

function make_seed()
{
  list($usec, $sec) = explode(' ', microtime());
  return (float) $sec + ((float) $usec * 100000);
}

function btrace_line($ar)
{
    GLOBAL $G_btrace_pref_sub;

    $ret = "";
    for ($i = 0 ; $i < count($ar) ; $i++) {
        $with_class = isset($ar[$i]['class']);
        $with_file  = isset($ar[$i]['file']);
        $ret .= sprintf("%s%s%s (%s:%d)", ($i == 0 ? "" : ", "),
                        ($with_class ?  $ar[$i]['class'].$ar[$i]['type'] : ""),
                        $ar[$i]['function'], ($with_file ? str_replace($G_btrace_pref_sub, "", $ar[$i]['file']) : ""),
                        ($with_file ? $ar[$i]['line'] : ""));
    }

    return ($ret);
}

function trace_ftok($id, $add)
{
    // NOTE: without space to use sed to substitute "= @ftok("  with "= @ftok("
    $tok=@ftok($id, $add);

    log_shme($tok.": ".$id." + ".$add);

    return ($tok);
}

function log_mop($step, $log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LMOP) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LMOP) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("LMOP: [%f] [%05d] [%s] [%s]\n", gettimeofday(TRUE), $step, $log, $btrace));
        fclose($fp);
    }
}

function log_step($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_STEP) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_STEP) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/step.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("STEP: [%f] [%s] [%s]\n", gettimeofday(TRUE), $log, $btrace));
        fclose($fp);
    }
}



function log_cds($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_CDS) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_CDS) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/cds.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("CDS: [%f] [%s] [%s]\n", gettimeofday(TRUE), $log, $btrace));
        fclose($fp);
    }
}


function log_only2($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_ONL2) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_ONL2) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("ONL2: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_crit($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_CRIT) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_CRIT) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("CRIT: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_only($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_ONLY) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_ONLY) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("ONLY: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_main($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_MAIN) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_MAIN) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("MAIN: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_rd($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_READ) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_READ) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("READ: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_rd2($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_REA2) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_REA2) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";

    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("REA2: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_send($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_SEND) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_SEND) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("SEND: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_lock($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LOCK) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LOCK) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("LOCK: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_wr($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_WRIT) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_WRIT) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("WRIT: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_load($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_LOAD) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_LOAD) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("LOAD: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}

function log_auth($sess, $log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_AUTH) == 0)
        return;

    if (( (BRISK_DEBUG | ($sess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_AUTH) == 0)
        return;

    if ((BRISK_DEBUG | ($sess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("LOAD: [%s] [%d] [%s] [%s]\n", $sess, time(), $log, $btrace));
        fclose($fp);
    }
}

function log_shme($log)
{
    GLOBAL $PHP_SELF;

    if (BRISK_SINGLE_SESS == "" && (BRISK_DEBUG & DBG_SHME) == 0)
        return;

    $sess = Brisk::sess_cur_get();
    if (isset($sess) == FALSE)
        $ssess = "XXXX";
    else
        $ssess = $sess;

    if (( (BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_SHME) == 0)
        return;

    if ((BRISK_DEBUG | ($ssess == BRISK_SINGLE_SESS ? BRISK_SINGLE_DEBUG : 0) ) & DBG_TRAC)
        $btrace = btrace_line(debug_backtrace());
    else
        $btrace = "";
    if (($fp = @fopen(LEGAL_PATH."/brisk.log", 'a')) != FALSE) {
        fwrite($fp, sprintf("SHME: [%s] [%s] [%s]\n", $ssess, $log, $btrace));
        fclose($fp);
    }
}



// function log_legal($curtime, $sess, $name, $where, $mesg)
function log_legal($curtime, $addr, $user, $where, $mesg)
{

  if (($fp = @fopen(LEGAL_PATH."/legal.log", 'a')) != FALSE) {
    /* Unix time | session | nickname | IP | where was | mesg */
    fwrite($fp, sprintf("%ld|%s|%s|%s|%s|%s|%s|\n", $curtime, $user->sess,
                        ($user->is_auth() ? 'A' : 'N'),
                        $user->name, $addr, $where , $mesg));
    fclose($fp);
  }
}

function table_act_content($isstanding, $sitted, $table, $cur_table, $allowed)
{
  $ret = "";

  if ($isstanding) {
    if ($sitted < PLAYERS_N) {
      if ($allowed)
        $act = 'sit';
      else
        $act = 'reserved';
    }
  }
  else {
    if ($table == $cur_table)
      $act = 'wake';
    else
      $act = 'none';
  }

  if ($act != '')
    $ret = sprintf('j_tab_act_cont(%d, \'%s\');', $table, $act);

  return ($ret);
}

function show_notify($text, $tout, $butt, $w, $h)
{
  log_main("SHOW_NOTIFY: ".$text);
  return sprintf('var noti = new notify(gst,"%s",%d,"%s",%d,%d);', $text, $tout, $butt, $w, $h);
}

function show_notify_ex($text, $tout, $butt, $w, $h, $is_opaque, $block_time)
{
  log_main("SHOW_NOTIFY OPAQUE: ".$text);
  return sprintf('var noti = new notify_ex(gst,"%s",%d,"%s",%d,%d, %s, %d);', $text, $tout, $butt, $w, $h, ($is_opaque ? "true" : "false"), $block_time);
}

function show_notify_document($text, $tout, $butt_arr, $confirm_func, $confirm_func_args, $w, $h, $is_opaque, $block_time)
{
  log_main("SHOW_NOTIFY OPAQUE: ".$text);

  $butts = "";
  for ($i = 0 ; $i < count($butt_arr) ; $i++) {
      $butts .= sprintf("%s'%s'", ($i == 0 ? "" : ","), $butt_arr[$i]);
  }

  return sprintf('g_nd = new notify_document(gst, "%s", %d, [ %s ], %s, %s, %d, %d, %s, %d);|',
                 escpush($text), $tout, $butts, ($confirm_func == NULL ? "null" : $confirm_func), (($confirm_func == NULL|| $confirm_func_args == NULL) ? "[]" : $confirm_func_args), $w, $h, ($is_opaque ? "true" : "false"), $block_time);
}


function root_welcome($user)
{
  GLOBAL $root_wellarr, $G_lang;
  $ret = "";

  $curtime = time();
  $dt = date("H:i ", $curtime);

  for ($i = 0 ; $i < count($root_wellarr[$G_lang]) ; $i++)
      $ret .= nickserv_msg($dt, str_replace('"', '\"', $root_wellarr[$G_lang][$i]));

  return ($ret);
}



function validate_sess($sess)
{
  if (strlen($sess) == SESS_LEN)
    return (TRUE);
  else
    return (FALSE);
}

function validate_name($name)
{
    $name_new = str_replace(' ', '_', mb_substr(trim($name),0,12, "UTF-8"));

  for ($i = 0 ; $i < strlen($name_new) ; $i++) {
    $c = $name_new[$i];
    if (($c >= "a" && $c <= "z") || ($c >= "A" && $c <= "Z") || ($c >= "0" && $c <= "9"))
      return ($name_new);
  }

  return (FALSE);
}

function playsound($filename)
{
  return (sprintf('playsound("flasou", "%s");', $filename));
}

function secstoword($secs)
{
  GLOBAL $G_lang;

  $ret = "";

  $mins = floor($secs / 60);
  $secs = $secs % 60;
  if ($G_lang == 'en') {
    if ($mins > 0)
      $ret = sprintf("%d minute%s%s", $mins, ($mins > 1 ? "s" : ""), ($secs > 0 ? " and " : ""));

    if ($secs > 0)
      $ret .= sprintf("%d second%s", $secs, ($secs > 1 ? "s" : ""));
  }
  else {
    if ($mins > 0)
      $ret = sprintf("%d minut%s%s", $mins, ($mins > 1 ? "i" : "o"), ($secs > 0 ? " e " : ""));

    if ($secs > 0)
      $ret .= sprintf("%d second%s", $secs, ($secs > 1 ? "i" : "o"));
  }
  return ($ret);
}

function sharedmem_sz($tok)
{
  if (($shm_id = @shmop_open($tok, 'a', 0, 0)) == FALSE) {
    log_main("shmop_open failed");
    return (-1);
  }
  $shm_sz = shmop_size($shm_id);
  shmop_close($shm_id);

  // log_main("shm_sz: ".$shm_sz."   SHM_DIMS: ".SHM_DIMS);
  return ($shm_sz);
}

class Warrant {
    static $delta_t;

  static function lock_data($is_exclusive)
  {
      if (($res = file_lock(FTOK_PATH."/warrant", $is_exclusive)) != FALSE) {
          self::$delta_t = microtime(TRUE);
          log_lock("LOCK   warrant      [".self::$delta_t."]");

          return ($res);
      }

      return (FALSE);
  }

  static function unlock_data($res)
  {
    GLOBAL $sess;

    log_lock("UNLOCK warrant      [".(microtime(TRUE) - (self::$delta_t))."]");

    file_unlock($res);
  }
}

class Poll {
    static $delta_t;

  static function lock_data($is_exclusive)
  {
      if (($res = file_lock(FTOK_PATH."/poll", $is_exclusive)) != FALSE) {
          self::$delta_t = microtime(TRUE);
          log_lock("LOCK   poll         [".self::$delta_t."]");

          return ($res);
      }

      return (FALSE);
  }

  static function unlock_data($res)
  {
    GLOBAL $sess;

    log_lock("UNLOCK poll         [".(microtime(TRUE) - (self::$delta_t))."]");

    file_unlock($res);
  }
}

function carousel_top()
{
    $what = rand(1,2);
    if ($what == 1) {
        $rn = rand(1, 3);
        return (sprintf('<a target="_blank" href="http://shop.alternativeoutput.it"><img class="nobo" style="display: inline; border: 1px solid #808080;" alt="il negozio virtuale di Brisk" title="il negozio virtuale di Brisk" src="img/briskshop%d.gif"></a>', $rn));
        }
    else {
        return (sprintf('<a target="_blank" href="http://www.alternativeoutput.it/briskblog"><img class="nobo" alt="il nuovo blog di Brisk" title="il nuovo blog di Brisk" style="display: inline; border: 1px solid #808080;" src="img/briskblog_bannersmall.png"></a>'));
    }
}


?>
