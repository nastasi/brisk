<?php
define(BRISKIN5_PLAYERS_N, 3);
define(BRISKIN5_MAX_PLAYERS, BRISKIN5_PLAYERS_N);
// define(BRISKIN5_SHM_MIN, (50000 * BRISKIN5_MAX_PLAYERS));
define(BRISKIN5_SHM_MIN, 32768);
define(BRISKIN5_SHM_MAX, (BRISKIN5_SHM_MIN + 1048576));
define(BRISKIN5_SHM_DLT, 32768);

$table_wellarr = Array ( 'Benvenuto al tavolo. Se almeno tre giocatori non sbloccano l\'uscita cliccando il lucchetto, chi esce non pu&ograve; risedersi a un qualunque tavolo per '.floor(BAN_TIME/60).' minuti.');


class Briskin5 {
  var $user;
  var $table;
  var $table_idx;
  var $table_token;

  var $comm; // commands for many people
  var $step; // current step of the comm array
  var $garbage_timeout;

  var $the_end;
  
  var $tok;
  var $shm_sz;

  function Briskin5 (&$room, $table_idx, $table_token) {
    $this->user = array();
    $this->table = array();

    $this->the_end = FALSE;
    $this->shm_sz = BRISKIN5_SHM_MIN;
    if (($this->tok = @ftok(FTOK_PATH."/table".$table_idx, "B")) == -1) {
      echo "FTOK FAILED";
      exit;
    }

    $user  =& $room->user;
    $table =& $room->table[$table_idx];

    log_wr("Briskin5 constructor");

    for ($i = 0 ; $i < $table->player_n ; $i++) {
      $user[$table->player[$i]]->table_token = $table_token;
      $this->user[$i] =& User::spawn(&$user[$table->player[$i]], 0, $i);
    }
    $this->table[0] =& Table::spawn(&$table);
    $this->table_idx = $table_idx;
    $this->table_token = $table_token;
    $this->garbage_timeout = 0;
    
    log_wr("Briskin5 constructor end");
  }


  function &get_user($sess, &$idx)
  {
    GLOBAL $PHP_SELF, $G_false;

    if (validate_sess($sess)) {
      for ($i = 0 ; $i < BRISKIN5_MAX_PLAYERS ; $i++) {
	if (strcmp($sess, $this->user[$i]->sess) == 0) {
	  // find it
	  $idx = $i;
	  $ret = &$this->user[$i];
	  return ($ret);
	}
      }
      log_main(sprintf("get_user: Wrong sess from page [%s]",$PHP_SELF));
      // for ($i = 0 ; $i < BRISKIN5_MAX_PLAYERS ; $i++) 
      // log_main(sprintf("get_user: Wrong sess compared with [%s]",$this->user[$i]->sess));
    }
    else {
      log_main(sprintf("get_user: Wrong strlen [%s]",$sess));
    }

    return ($G_false);
  }


  function garbage_manager($force)
  {
    
    /* Garbage collector degli utenti in timeout */
    $ismod = FALSE;
    $curtime = time();
    if ($force || $this->garbage_timeout < $curtime) {
      
      for ($i = 0 ; $i < BRISKIN5_MAX_PLAYERS ; $i++) {
	$user_cur = &$this->user[$i];
	if ($user_cur->sess == "" || 
	    ($user_cur->stat == 'table' && ($user_cur->subst == 'shutdowned' || $user_cur->subst == 'shutdowner')))
	  continue;
	
	if ($user_cur->lacc + EXPIRE_TIME_RD < $curtime) { // Auto logout dell'utente
	  log_rd2($user_cur->sess." bin5 AUTO LOGOUT.");

	  if ($user_cur->stat == 'table') {
	    log_auth($user_cur->sess," bin5 Autologout session.");

	    /* SI DELEGA AL garbage_manager principale LA RIMOZIONE DELL'UTENTE 

	    $tmp_sess = $user_cur->sess;
	    $user_cur->sess = "";
	    step_unproxy($tmp_sess);
	    $user_cur->name = "";
	    $user_cur->the_end = FALSE;
	    
            */

	    $this->table_wakeup(&$user_cur);
	  }
	}
      }
      log_rd2($user_cur->sess." GARBAGE UPDATED!");
      
      $this->garbage_timeout = $curtime + GARBAGE_TIMEOUT;
      $ismod = TRUE;
    }

    return ($ismod);
  }




  //
  //  static functions
  //
  function &load_data($table_idx, $table_token = "") 
  {
    GLOBAL $G_false, $sess;
    $doexit = FALSE;
    $shm = FALSE;

    log_wr("TABLE_IDX ".FTOK_PATH."/table".$table_idx);
    
    do {
      if (($tok = @ftok(FTOK_PATH."/table".$table_idx, "B")) == -1) {
	log_main("ftok failed");
	$doexit = TRUE;
	break;
      }

      if (($shm_sz = sharedmem_sz($tok)) == -1) {
	log_main("shmop_open failed");
	break;
      }
	
      if (($shm = shm_attach($tok, $shm_sz)) == FALSE)
	break;

      if (($bri = @shm_get_var($shm, $tok)) == FALSE) 
	break;

      if ($table_token != "" && $bri->table_token != $table_token) {
	log_wr("bri->table_token: ".$bri->table_token."table_token: ".$table_token);
	
	break;
      }
      $bri->tok = $tok;

      shm_detach($shm);
	
      $ret = &$bri;
      return ($ret); 
    } while (FALSE);

    if ($shm != FALSE)
      shm_detach($shm);

    log_wr("briskin5 load_data failed");
    if ($doexit)
      exit();
    
    return ($G_false);
  }
  


  function save_data(&$bri) 
  {
    GLOBAL $sess;
    
    $ret =   FALSE;
    $shm =   FALSE;
    
    log_main("SAVE BRISKIN5 DATA");
    
    if (!isset($bri->tok))
      return (FALSE);
    
    while ($bri->shm_sz < BRISKIN5_SHM_MAX) {
      if (($shm = shm_attach($bri->tok, $bri->shm_sz)) == FALSE)
	break;
      
      if (@shm_put_var($shm, $bri->tok, $bri) != FALSE) {
	shm_detach($shm);
	return (TRUE);
      }
      if (shm_remove($shm) === FALSE) {
	log_only("REMOVE FALLITA");
	break;
      }
      shm_detach($shm);
      $bri->shm_sz += BRISKIN5_SHM_DLT;
    } 

    log_crit("save data failed!");

    if ($shm)
      shm_detach($shm);
    
    return ($ret);
  }



  function destroy_data($table_idx) 
  {
    GLOBAL $sess;

    $ret =   FALSE;
    $shm =   FALSE;
    log_main("DESTROY BRISKIN5 DATA");
    
    do {
      log_main("DESTROY2 BRISKIN5 DATA");

      if (($tok = @ftok(FTOK_PATH."/table".$table_idx, "B")) == -1) 
	break;

      if (($shm = @shmop_open($tok, 'a', 0, 0)) == FALSE)
	break;
      
      if (shmop_delete($shm) == 0) {
	log_only("REMOVE FALLITA ");
	break;
      }
   
      $shm = FALSE;
      log_main("DESTROY2 BRISKIN5 DATA SUCCESS");
      
      // log_main("QUI CI ARRIVA [".$bri->user[0]->name."]");
      $ret = TRUE;
    } while (0);
    
    if ($shm)
      shm_detach($shm);
    
    return ($ret);
  }

  function lock_data($table_idx)
  {
    GLOBAL $sess; 
    
    log_wr("LOCK_DATA ".FTOK_PATH."/table".$table_idx);
    //  echo "LOCK: ".FTOK_PATH."/main";
    //  exit;
    // WARNING monitor this step
    if (($tok = @ftok(FTOK_PATH."/table".$table_idx, "B")) == -1) {
      return (FALSE);
    }
    // WARNING monitor this step
    if (($res = @sem_get($tok)) == FALSE) {
      return (FALSE);
    }
    if (sem_acquire($res)) {   
      log_lock("LOCK table ".$table_idx."[res: ".$res."]");
      return ($res);
    }
    else {
      log_lock("LOCK table ".$table_idx.":FAILED");
      return (FALSE);
    }
  }
  
  function unlock_data($res)
  {
    GLOBAL $sess; 
    
    log_lock("UNLOCK table [res: ".$res."]");

    return (sem_release($res));
  }


  function chatt_send(&$user, $mesg)
  {
    if ($user->stat == 'table') {
      $table = &$this->table[$user->table];
    }
    
    $user_mesg = substr($mesg,6);
    
    $curtime = time();
    
    $dt = date("H:i ", $curtime);
    if (strncmp($user_mesg, "/nick ", 6) == 0) {
      log_main($user->sess." chatt_send BEGIN");

      if (($name_new = validate_name(substr($user_mesg, 6))) == FALSE) {
	  $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";
	  $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"Il nickname deve contenere almeno una lettera dell\'alfabeto o una cifra.");', $dt, NICKSERV);
	  $user->step_inc();

	  return;
      }
      $user_mesg = "COMMAND ".$user_mesg;
      // Search dup name
      // change
      // update local graph
      // update remote graphs
      for ($i = 0 ; $i < BRISKIN5_MAX_PLAYERS ; $i++) {
	$user_cur = &$this->user[$i];
	// 	if ($user_cur->sess == '' || $user_cur->stat != 'room')
	if ($user_cur->sess == '')
	  continue;
	if ($user_cur->name == $name_new) {
	  $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";
	  $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"Nickname <b>%s</b> gi&agrave; in uso.%d");', $dt, NICKSERV, xcape($name_new), $this->table[$user->table]->auth_only == TRUE);
	  $user->step_inc();
	  break;
	}
      }
      if ($i == BRISKIN5_MAX_PLAYERS) {
        if ($user->flags & USER_FLAG_AUTH && strcasecmp($user->name,$name_new) != 0) {
          if ($this->table[$user->table]->auth_only == TRUE) {
            $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";
            $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"<b>Non puoi cambiare nick a un tavolo per soli autenticati.</b>");', $dt, NICKSERV);
	    $user->step_inc();
            return;
          }
          else {
            $user->flags &= ~USER_FLAG_AUTH; // Remove auth if name changed
          }
        }
    
	$user->name = $name_new;

        log_main($user->sess." chatt_send start set");
	

	for ($i = 0 ; $i < BRISKIN5_MAX_PLAYERS ; $i++) {
	  log_main($user->sess." chatt_send set loop");
	  
	  $user_cur = &$this->user[$i];
	  if ($user_cur->sess == '')
	    continue;
	  if ($user_cur->stat == 'room') {
	    if ($user->stat == 'room' && $user->subst == 'standup') {
	      $this->standup_update(&$user);
	    }
	    else if ($user->stat == 'room' && $user->subst == 'sitdown' ||
		     $user->stat == 'table') {
	      log_main($user->sess." chatt_send pre table update");

	      $this->table_update(&$user);

	      log_main($user->sess." chatt_send post table update");
	    }
	  }
	  else if ($user_cur->stat == 'table' && $user_cur->table == $user->table) {
	    $table = &$this->table[$user->table];
	    
	    $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
	    $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('set_names([%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"]); ',
                      $this->user[$table->player[($user_cur->table_pos) % BRISKIN5_PLAYERS_N]]->flags,
                      xcape($this->user[$table->player[($user_cur->table_pos) % BRISKIN5_PLAYERS_N]]->name),

                      $this->user[$table->player[($user_cur->table_pos+1) % BRISKIN5_PLAYERS_N]]->flags,
                      xcape($this->user[$table->player[($user_cur->table_pos+1) % BRISKIN5_PLAYERS_N]]->name),

                      $this->user[$table->player[($user_cur->table_pos+2) % BRISKIN5_PLAYERS_N]]->flags,
                      xcape($this->user[$table->player[($user_cur->table_pos+2) % BRISKIN5_PLAYERS_N]]->name),

                      (BRISKIN5_PLAYERS_N == 3 ? 0:  $this->user[$table->player[($user_cur->table_pos+3) % BRISKIN5_PLAYERS_N]]->flags),
                      (BRISKIN5_PLAYERS_N == 3 ? "" :  xcape($this->user[$table->player[($user_cur->table_pos+3) % BRISKIN5_PLAYERS_N]]->name)),

                      (BRISKIN5_PLAYERS_N == 3 ? 0:  $this->user[$table->player[($user_cur->table_pos+4) % BRISKIN5_PLAYERS_N]]->flags),
                      (BRISKIN5_PLAYERS_N == 3 ? "" :  xcape($this->user[$table->player[($user_cur->table_pos+4) % BRISKIN5_PLAYERS_N]]->name)));
	    if ($user_cur == $user) {
              $itin = ($user->flags & USER_FLAG_AUTH ? "<i>" : "");
              $itou = ($user->flags & USER_FLAG_AUTH ? "</i>" : "");
	      $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('$("myname").innerHTML = "<b>%s%s%s</b>";', 
								   $itin, xcape($user->name,ENT_COMPAT,"UTF-8"), $itou);
            }
	    $user_cur->step_inc();
	  }
	}
      }
    }
    else {
      for ($i = 0 ; $i < ($user->stat == 'room' ? BRISKIN5_MAX_PLAYERS : BRISKIN5_PLAYERS_N) ; $i++) {
	if ($user->stat == 'room') {
	  $user_cur = &$this->user[$i];
	  if ($user_cur->sess == '' || $user_cur->stat != 'room')
	    continue;
	}
	else {
	  $user_cur = &$this->user[$table->player[$i]];
	}
	
	$user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
	$user_cur->comm[$user_cur->step % COMM_N] .= sprintf('chatt_sub("%s", [%d, "%s"],"%s");',
							     $dt, $user->flags, xcape($user->name), xcape($user_mesg));
	$user_cur->step_inc();
      }
      log_legal($curtime, $user, ($user->stat == 'room' ? 'room' : 'table '.$user->table),$user_mesg);
    }
  }

  function table_wakeup(&$user)
  {
    $table = &$this->table[0];

    log_main("BRISKIN5_WAKEUP begin function table  stat: ".$user->stat."  subst: ".$user->subst);

    $curtime = time();

    log_main("BRISKIN5_WAKEUP from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);
    
    for ($i = 0 ; $i < $table->player_n ; $i++) {
      $user_cur = &$this->user[$i];
      log_main("PREIMPOST INLOOP name: ".$user_cur->name);
      
      if ($user_cur == $user)
	$user_cur->subst = "shutdowner";
      else
	$user_cur->subst = "shutdowned";
      $user_cur->laccwr = $curtime;

      $ret = "gst.st = ".($user_cur->step+1)."; ";
      $ret .= 'gst.st_loc++; the_end=true; window.onbeforeunload = null; window.onunload = null; document.location.assign("../index.php");|';

      log_wr($user_cur->sess." BRISKIN5_WAKEUP: ".$ret);
      $user_cur->comm[$user_cur->step % COMM_N] = $ret;
      $user_cur->step_inc();
    }

    $this->the_end = TRUE;
  }
  
  /*
   *  If all players are freezed the room garbage_manager clean up table and users.
   */ 
  function is_abandoned() 
  {
    $is_ab = TRUE;
    $curtime = time();

    $table = &$this->table[0];

    for ($i = 0 ; $i < $table->player_n ; $i++) {
      $user_cur = &$this->user[$i];

      if ($user_cur->lacc + (EXPIRE_TIME_RD * 2) >= $curtime) { 
	$is_ab = FALSE;
	break;
      }
    }

    return ($is_ab);
  }
} // end class Briskin5

function locshm_exists($tok)
{
  // return (TRUE);

  if (($id = @shmop_open($tok,"a", 0, 0)) == FALSE) {
    log_main($tok." SHM NOT exists");

    return (FALSE);
  }
  else {
    shmop_close($id);
    log_main($tok." SHM exists");

    return (TRUE);
  }
    
}


function calculate_points(&$table)
{
  GLOBAL $G_all_points; 

  $pro = 0;

  if ($table->asta_pnt == 60)
    $table->asta_pnt = 61;

  $table->old_reason = "";
  $table->old_win = $table->asta_win;
  $table->old_friend = $table->friend;
  $table->old_asta_pnt = $table->asta_pnt;

  for ($i = 0 ; $i < 40 ; $i++) {
    $ctt = $table->card[$i]->value % 10;
    $own = $table->card[$i]->owner;
    if ($own == $table->asta_win || $own == $table->friend) 
      $pro += $G_all_points[$ctt];
  }

  log_wr(sprintf("PRO: [%d]", $pro));

  
  if ($table->asta_pnt == 61 && $pro == 60) { // PATTA !
    $table->points[$table->points_n % MAX_POINTS] = array();
    for ($i = 0 ; $i < PLAYERS_N ; $i++) 
      $table->points[$table->points_n % MAX_POINTS][$i] = 0;
    $table->points_n++;
    $table->old_pnt = $pro;
    $table->mult *= 2;

    return;
  }

  if ($pro >= $table->asta_pnt) 
    $sig = 1;
  else
    $sig = -1;

  $table->points[$table->points_n % MAX_POINTS] = array();
  for ($i = 0 ; $i < 5 ; $i++) {
    if ($i == $table->asta_win) 
      $pt = ($i == $table->friend ? 4 : 2);
    else if ($i == $table->friend) 
      $pt = 1;
    else
      $pt = -1;

    log_wr(sprintf("PRO: pt[%d][%d] = %d", $table->points_n % MAX_POINTS, $i, $pt));

    $pt = $pt * $sig * $table->mult * ($pro == 120 ? 2 : 1);

    log_wr(sprintf("PRO:[%d][%d][%d]", $sig, $table->mult, ($pro == 120 ? 2 : 1)));
    
    $table->points[$table->points_n % MAX_POINTS][$i] = $pt;
    $table->total[$i] += $pt;
  }
  $table->points_n++;
  $table->old_pnt = $pro;
  $table->mult = 1;
}

/* show table 
is_transition (is from room to table ?)
is_again      (is another game)

Examples                    of $is_transition, $is_again:
  from reload of the page:              FALSE, FALSE
  from sitdown in room:                  TRUE, FALSE
  from table: asta cmd e tutti passano:  TRUE, TRUE
  from table: fine partita:              TRUE, TRUE
 */
function show_table(&$room, &$user, $sendstep, $is_transition, $is_again)
{
  $table_idx = $user->table;
  $table = &$room->table[$table_idx];
  $table_pos = $user->table_pos;

  $ret = "table_init();";
  $ret .= $table->exitlock_show(&$room->user, $table_pos);
  if (!$is_again) {
    /* GENERAL STATUS */
    $ret .= sprintf( 'gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;',
		     $sendstep, $user->stat, $user->subst, $table_pos);

    log_rd(sprintf( 'SHOW_TABLE: gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;', $sendstep, $user->stat, $user->subst, $table_pos));

    /* BACKGROUND */
    $ret .= "background_set();";
    
    /* USERS INFO */
    $itin = ($user->flags & USER_FLAG_AUTH ? "<i>" : "");
    $itou = ($user->flags & USER_FLAG_AUTH ? "</i>" : "");

    $ret .= sprintf('$("myname").innerHTML = "<b>%s%s%s</b>";', $itin, xcape($user->name), $itou);
    $ret .= sprintf('set_names([%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"]); ',
		    $room->user[$table->player[($table_pos)%PLAYERS_N]]->flags,
		    xcape($room->user[$table->player[($table_pos)%PLAYERS_N]]->name),

		    $room->user[$table->player[($table_pos+1)%PLAYERS_N]]->flags,
		    xcape($room->user[$table->player[($table_pos+1)%PLAYERS_N]]->name),

		    $room->user[$table->player[($table_pos+2)%PLAYERS_N]]->flags,
		    xcape($room->user[$table->player[($table_pos+2)%PLAYERS_N]]->name),

		    (PLAYERS_N == 3 ? 0 : $room->user[$table->player[($table_pos+3)%PLAYERS_N]]->flags),
		    (PLAYERS_N == 3 ? "" :  xcape($room->user[$table->player[($table_pos+3)%PLAYERS_N]]->name)),

		    (PLAYERS_N == 3 ? 0 : $room->user[$table->player[($table_pos+4)%PLAYERS_N]]->flags),
		    (PLAYERS_N == 3 ? "" :  xcape($room->user[$table->player[($table_pos+4)%PLAYERS_N]]->name)));
  }
  /* NOTIFY FOR THE CARD MAKER */
  if ($is_transition) { //  && $user->subst ==  "asta" superfluo
    $ret .= show_table_info(&$room, &$table, $table_pos);
  }
  if (!$is_again) 
    $ret .= table_wellcome($user);

  if ($is_transition && !$is_again) { // appena seduti al tavolo, play della mucca
    $ret .= playsound("cow.mp3");
  }


  /* CARDS */
  if ($is_transition) { //  && $user->subst ==  "asta" superfluo
    $ret .= "|";
    
    for ($i = 0 ; $i < 8 ; $i++) {
      for ($e = 0 ; $e < PLAYERS_N ; $e++) {
	$ct = 0;
	for ($o = 0 ; $o < 40 && $ct < $i+1 ; $o++) {
	  if ($table->card[$o]->owner == (($e + $table->gstart) % PLAYERS_N)) {
	    $ct++;
	    if ($ct == $i+1)
	      break;
	  }
	}
	log_rd("O ".$o." VAL ".$table->card[$o]->value." Owner: ".$table->card[$o]->owner);
	
	$ret .= sprintf( ' card_send(%d,%d,%d,%8.2f,%d);|', ($table->gstart + $e) % PLAYERS_N, 
			 $i, ((($e + PLAYERS_N - $table_pos + $table->gstart) % PLAYERS_N) == 0 ?
			      $table->card[$o]->value : -1), 
			 ($i == 7 && $e == (PLAYERS_N - 1) ? 1 : 0.5),$i+1);
      }
    }    
  }
  else {
    $taked  = array(0,0,0,0,0);
    $inhand = array(0,0,0,0,0);
    $ontabl  = array(-1,-1,-1,-1,-1);
    $cards  = array();

    for ($i = 0 ; $i < 40 ; $i++) {
      if ($table->card[$i]->stat == 'hand') {
	if ($table->card[$i]->owner == $table_pos) {
	  $cards[$inhand[$table->card[$i]->owner]] = $table->card[$i]->value;
	}
	$inhand[$table->card[$i]->owner]++;
      }
      else if ($table->card[$i]->stat == 'take') {
	log_main("Card taked: ".$table->card[$i]->value."OWN: ".$table->card[$i]->owner);
	$taked[$table->card[$i]->owner]++;
      }
      else if ($table->card[$i]->stat == 'table') {
	$ontabl[$table->card[$i]->owner] = $i;
      }
    }
    $logg = "\n";
    for ($i = 0 ; $i < PLAYERS_N ; $i++) {
      $logg .= sprintf("INHAND: %d   IN TABLE %d   TAKED %d\n", $inhand[$i], $ontabl[$i], $taked[$i]);
    }
    log_main("Stat table: ".$logg);

    /* Set ours cards. */
    $oursarg = "";
    for ($i = 0 ; $i < $inhand[$table_pos] ; $i++) 
      $oursarg .= ($i == 0 ? "" : ", ").$cards[$i];
    for ($i = $inhand[$table_pos] ; $i < 8 ; $i++) 
      $oursarg .= ($i == 0 ? "" : ", ")."-1";
    $ret .= sprintf('card_setours(%s);', $oursarg);

    /* Dispose all cards */
    for ($i = 0 ; $i < PLAYERS_N ; $i++) {
      /* Qui sotto al posto di + 1 c'era + ->gstart ... credo in modo errato */
      $ret .= sprintf('cards_dispose(%d,%d,%d);', $i,
		      $inhand[$i], $taked[$i]);

      if ($ontabl[$i] != -1) {
	$ret .= sprintf('card_place(%d,%d,%d,%d,%d);',$i, $inhand[$i], 
			$table->card[$ontabl[$i]]->value, 
			$table->card[$ontabl[$i]]->x, $table->card[$ontabl[$i]]->y);
      }
    }
  }

  /* Show auction */
  if ($user->subst == 'asta') {

    /* show users auction status */
    $showst = "";
    for ($i = 0 ; $i < PLAYERS_N ; $i++) {
      $user_cur = &$room->user[$table->player[$i]];
      $showst .= sprintf("%s%d", ($i == 0 ? "" : ", "), 
			 ($user_cur->asta_card < 9 ? $user_cur->asta_card : $user_cur->asta_pnt));
    }
    if (PLAYERS_N == 3)
    	$showst .= ",-2,-2";
    $ret .= sprintf('show_astat(%s);', $showst);

    if ($table->asta_win != -1 && $table->asta_win == $table_pos) {
      /* show card chooser */
      $ret .= sprintf('choose_seed(%s); $("astalascio").style.visibility = ""; $("asta").style.visibility = "hidden";',
		      $table->asta_card);
    }
    else {
      /* show auction */
      if ($table_pos == ($table->gstart % PLAYERS_N) &&
	  $table->asta_win == -1) 
	$ret .= sprintf('dispose_asta(%d,%d, %s);', 
			$table->asta_card + 1, $table->asta_pnt+1, ($user->handpt <= 2 ? "true" : "false"));
      else
	$ret .= sprintf('dispose_asta(%d,%d, %s);',
			$table->asta_card + 1, -($table->asta_pnt+1), ($user->handpt <= 2 ?  "true" : "false"));
    }

    /* Remark */
    if ($table->asta_win == -1) { // auction case
      if ($table_pos == ($table->gstart % PLAYERS_N)) 
	$ret .= "remark_on();";
      else
	$ret .= "remark_off();";
    }
    else { // chooseed case
      if ($table_pos == $table->asta_win) 
	$ret .= "remark_on();";
      else
	$ret .= "remark_off();";
    }
  }
  else if ($user->subst == 'game') {
    /* HIGHLIGHT */
    if (($table->gstart + $table->turn) % PLAYERS_N == $table_pos) 
      $ret .= "is_my_time = true; remark_on();";
    else
      $ret .= "remark_off();";
    
    /* WHO CALL AND WATH */
    $ret .= briscola_show($room, $table, $user);
    
  }
  return ($ret);
} // end function show_table(...

function calculate_winner(&$table)
{
  $briontab = FALSE;
  $ontab = array();
  $ontid = array();
  $cur_win  =  -1;
  $cur_val  = 100;
  $cur_seed = $table->briscola - ($table->briscola % 10);

  for ($i = 0 ; $i < 40 ; $i++) {
    if ($table->card[$i]->stat != "table")
      continue;

    log_wr(sprintf("Card On table: [%d]", $i));

    $v = $table->card[$i]->value; 
    $ontab[$table->card[$i]->owner] = $v;
    $ontid[$table->card[$i]->owner] = $i;
    /* se briscola setto il flag */
    if (($v - ($v % 10)) == $cur_seed)
      $briontab = TRUE;
  }

  if ($briontab == FALSE) {
    $cur_win  = $table->gstart;
    $cur_val  = $ontab[$cur_win];
    $cur_seed = $cur_val - ($cur_val % 10);
  }

  for ($i = 0 ; $i < PLAYERS_N ; $i++) {
    if (($ontab[$i] - ($ontab[$i] % 10)) == $cur_seed) {
      if ($ontab[$i] < $cur_val) {
	$cur_val = $ontab[$i];
	$cur_win = $i;
      }
    }
  }

  for ($i = 0 ; $i < PLAYERS_N ; $i++) {
    $table->card[$ontid[$i]]->owner = $cur_win;
    $table->card[$ontid[$i]]->stat =  "take"; // Card stat
  }
  return ($cur_win);
}

function show_table_info(&$room, &$table, $table_pos)
{
  $ret = "";
  $user = &$room->user[$table->player[$table_pos]];

  $pnt_min = $table->points_n - MAX_POINTS < 0 ? 0 : $table->points_n - MAX_POINTS;
  $noty = sprintf('<table class=\"points\"><tr><th></th>');
  
  // Names.
  for ($i = 0 ; $i < PLAYERS_N ; $i++) 
    $noty .= sprintf('<th class=\"td_points\">%s</th>', xcape($room->user[$table->player[$i]]->name));
  $noty .= sprintf("</tr>");

  // Points.
  log_main("show_table_info: pnt_min: ".$pnt_min."   Points_n: ".$table->points_n);

  for ($i = $pnt_min ; $i < $table->points_n ; $i++) {
    $noty .= sprintf('<tr><th class=\"td_points\">%d</th>', $i+1);
    for ($e = 0 ; $e < PLAYERS_N ; $e++) 
      $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->points[$i % MAX_POINTS][$e]);
    $noty .= "</tr>";
  }

  // Total points.
  $noty .= '<tr><th class=\"td_points\">Tot.</th>';
  for ($e = 0 ; $e < PLAYERS_N ; $e++) 
    $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->total[$e]);
  $noty .= "</tr></table>";

  if ($table->old_reason != "") {
    $noty .= sprintf("<hr><b>%s</b><br>", xcape($table->old_reason));
  }

  if ($table->old_win != -1) {
    $win = $table->player[$table->old_win];
    $fri = $table->player[$table->old_friend];

    $wol = game_result($table->old_asta_pnt, $table->old_pnt);

    if ($win != $fri) {
      /* MLANG: "<hr>Nell'ultima mano ha chiamato <b>%s</b>, il socio era <b>%s</b>,<br>", "hanno fatto <b>cappotto</b> EBBRAVI!.<hr>", "dovevano fare <b>%s</b> punti e ne hanno fatti <b>%d</b>: hanno <b>%s</b>.<hr>", "<hr>Nell'ultima mano <b>%s</b> si &egrave; chiamato in mano,<br>", "ha fatto <b>cappotto</b> EBBRAVO!.<hr>", "doveva fare <b>%s</b> punti e ne ha fatti <b>%d</b>: ha <b>%s</b>.<hr>", ($table->old_asta_pnt > 61 ? "almeno ".$table->old_asta_pnt : 'pi&ugrave; di 60'), $table->old_pnt, ($wol == 1 ? "vinto" : ($wol == 0 ? "pareggiato" : "perso" */
      $noty .= sprintf("<hr>Nell'ultima mano ha chiamato <b>%s</b>, il socio era <b>%s</b>,<br>", 
		       xcape($room->user[$win]->name),
		       xcape($room->user[$fri]->name));
      if ($table->old_pnt == 120) {
	$noty .= sprintf("hanno fatto <b>cappotto</b> EBBRAVI!.<hr>");
      }
      else {
	$noty .= sprintf("dovevano fare <b>%s</b> punti e ne hanno fatti <b>%d</b>: hanno <b>%s</b>.<hr>",
			 ($table->old_asta_pnt > 61 ? "almeno ".$table->old_asta_pnt :
			  'pi&ugrave; di 60'), $table->old_pnt,
			 ($wol == 1 ? "vinto" : ($wol == 0 ? "pareggiato" : "perso")));
      }
    }
    else {
      $noty .= sprintf("<hr>Nell'ultima mano <b>%s</b> si &egrave; chiamato in mano,<br>", 
		       xcape($room->user[$win]->name));
      if ($table->old_pnt == 120) {
	$noty .= sprintf("ha fatto <b>cappotto</b> EBBRAVO!.<hr>");
      }
      else {
	$noty .= sprintf("doveva fare <b>%s</b> punti e ne ha fatti <b>%d</b>: ha <b>%s</b>.<hr>",
			 ($table->old_asta_pnt > 61 ? "almeno ".$table->old_asta_pnt :
			  'pi&ugrave; di 60'), $table->old_pnt,
			 ($wol == 1 ? "vinto" : ($wol == 0 ? "pareggiato" : "perso")));
      }
    }
  }
  /* MLANG: "Fai <b>tu</b> il mazzo,", "Il mazzo a <b>$unam</b>," */
  if ($table->mazzo == $table_pos) 
    $noty .= "Fai <b>tu</b> il mazzo,";
  else {
    $unam = xcape($room->user[$table->player[$table->mazzo]]->name);
    $noty .= "Il mazzo a <b>$unam</b>,";
  }

  if ($user->subst == 'asta') {
    if ($table->asta_win == -1)  // auction case
      $curplayer = $table->gstart % PLAYERS_N;
    else 
      $curplayer = $table->asta_win;
  }
  else if ($user->subst == 'game') {
    $curplayer = ($table->gstart + $table->turn) % PLAYERS_N;
  }

  /* MLANG: " tocca a <b>te</b> giocare.", " tocca a <b>$unam</b> giocare.", " La partita vale <b>%s</b>.", "torna alla partita" */
  if ($curplayer == $table_pos) {
    $noty .= " tocca a <b>te</b> giocare.";
  }
  else {
    $unam = xcape($room->user[$table->player[$curplayer]]->name);
    $noty .= " tocca a <b>$unam</b> giocare.";
  }
  
  if ($table->mult > 1) {
    $noty .= sprintf(" La partita vale <b>%s</b>.", multoval($table->mult));
  }
  $noty .= "<hr><br>";
  $ret .= show_notify($noty, 3000, "torna alla partita", 500, 400);
  /* NOTE: show_notify($noty, 3000, "torna alla partita", 500, 
   *                   130 + ($table->points_n > 0 ? 50 : 0) + 
   *                   (120 * ($table->points_n / MAX_POINTS)));
   *       will be used when we refact notify js function following 
   *       photoo class logic 
   */ 
  
  return ($ret);
}

function table_wellcome($user)
{
  GLOBAL $table_wellarr;
  $ret = "";

  for ($i = 0 ; $i < count($table_wellarr) ; $i++)
    $ret .= sprintf('chatt_sub("%s", [2, "ChanServ: "],"%s");', "", str_replace('"', '\"', $table_wellarr[$i]));

  return ($ret);
}


function briscola_show($room, $table, $user)
{
  $ptnadd = "";
  $ret = "";

  if ($table->asta_card == 9) 
    $ptnadd = sprintf("<br>con %d punti", $table->asta_pnt);
  
  /* text of caller cell */
  if ($user->table_pos == $table->asta_win) 
    $ret .= sprintf('$("callerinfo").innerHTML = "Chiami%s:";', $ptnadd);
  else 
    $ret .= sprintf('$("callerinfo").innerHTML = "Chiama %s%s:";', 
		    xcape($room->user[$table->player[$table->asta_win]]->name), $ptnadd);

  $ret .= sprintf('$("caller").style.backgroundImage = \'url("img/brisk_caller_sand%d.png")\';',
		  $table->asta_win);
  $ret .= sprintf('$("callerimg").src = "img/%02d.png";', $table->briscola);
  $ret .= sprintf('$("caller").style.visibility = "visible";');
  $ret .= sprintf('$("chooseed").style.visibility = "hidden";');
  $ret .= sprintf('$("astalascio").style.visibility = "";');
  $ret .= sprintf('$("asta").style.visibility = "hidden";');
  $ret .= sprintf('show_astat(-2,-2,-2,-2,-2);');
  
  return ($ret);
}


function game_result($asta_pnt, $pnt)
{
  if ($asta_pnt == 61) {
    if ($pnt > 60)
      return (1);
    else if ($pnt == 60)
      return (0);
    else
      return (-1);
  }
  else {
    if ($pnt >= $asta_pnt)
      return (1);
    else
      return (-1);
  }
}

?>
