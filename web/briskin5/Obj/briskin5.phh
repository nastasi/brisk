<?php
/*
 *  brisk - briskin5.phh
 *
 *  Copyright (C) 2006-2012 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it 
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */
define('BIN5_PLAYERS_N', 3);
define('BIN5_MAX_PLAYERS', BIN5_PLAYERS_N);
// define(BIN5_SHM_MIN', (50000 * BIN5_MAX_PLAYERS));
define('BIN5_SHM_MIN', 32768);
define('BIN5_SHM_MAX', (BIN5_SHM_MIN + 1048576));
define('BIN5_SHM_DLT', 32768);
define('BIN5_PROXY_PATH', PROXY_PATH."/bin5");

$mlang_bin5_bin5 = array( 
                         'info_part' => array( 'it' => '<hr>Nell\'ultima mano ha chiamato <b>%s</b>, il socio era <b>%s</b>,<br>',
                                               'en' => '<hr>In the last hand the declarer was <b>%s</b>, the partner was <b>%s</b>,<br>'),
                         'info_capp' => array( 'it' => 'hanno fatto <b>cappotto</b> EBBRAVI!.<br>',
                                               'en' => 'and they made <b>capot</b> WELL DONE!.<br>'),
                         'info_pnt'  => array( 'it' => 'dovevano fare <b>%s</b> punti e ne hanno fatti <b>%d</b>: hanno %s.<br>',
                                               'en' => 'they had to do <b>%s</b> points and they had made <b>%d</b>: they have %s.<br>'),
                         'info_alea' => array( 'it' => 'almeno ',
                                               'en' => 'at least '),
                         'info_more' => array( 'it' => 'pi&ugrave; di 60',
                                               'en' => 'over 60'),
                         'info_win'  => array( 'it' => '<b>vinto</b>',
                                               'en' => '<b>win</b>'),
                         'info_peer' => array( 'it' => '<b>pareggiato</b>',
                                               'en' => '<b>drew</b>'),
                         'info_lost' => array( 'it' => '<b>perso</b>',
                                               'en' => '<b>lost</b>'),

                         'info_alon' => array( 'it' => '<hr>Nell\'ultima partita <b>%s</b> si &egrave; chiamato in mano,<br>',
                                               'en' => '<hr>In the last hand <b>%s</b> play alone against each other,<br>'),
                         'info_apnt' => array( 'it' => 'doveva fare <b>%s</b> punti e ne ha fatti <b>%d</b>: ha %s.<br>',
                                               'en' => 'he/she had to do <b>%s</b> points and they had made <b>%d</b>: he/she had %s.<br>'),
                         'info_acap' => array( 'it' => 'ha fatto <b>cappotto</b> EBBRAVO!.<hr>',
                                               'en' => 'and he/she made <b>capot</b> WELL DONE!.<hr>'),
                         
                         'info_omul' => array( 'it' => ' La partita valeva <b>%s</b>.',
                                               'en' => ' EN: The game was worth <b>%s</b>.' ),

                         'info_yturn'=> array( 'it' => ' tocca a <b>te</b> giocare.',
                                               'en' => ' it\'s <b>your</b> turn.'),
                         'info_turn' => array( 'it' => 'tocca a <b>%s</b> giocare.',
                                               'en' => 'it\'s the <b>%s</b>\'s turn.'),
                         'info_mult' => array( 'it' => ' La partita vale <b>%s</b>.',
                                               'en' => ' The game worth <b>%s</b>.' ),
                         'info_yshuf'=> array( 'it' => 'Fai <b>tu</b> il mazzo, ',
                                               'en' => 'It\'s <b>your</b> shuffled the cards, '),
                         'info_shuf' => array( 'it' => 'Il mazzo a <b>%s</b>, ',
                                               'en' => '<b>%s</b> shuffled the cards, '),
                         'btn_bkgame'=> array( 'it' => 'torna alla partita',
                                               'en' => 'back to the game'),
                         'call_wptn' => array( 'it' => '<br>con %d punti',
                                               'en' => '<br>with %d points'),
                         'call_ycall'=> array( 'it' => 'Chiami%s:',
                                               'en' => 'Call%s:'),
                         'call_call' => array( 'it' => 'Chiama %s%s:',
                                               'en' => 'The declarer is %s%s:')

                         
                          );

// MLANG
$table_wellarr = Array( 'it' => Array ( 'Benvenuto al tavolo. Se almeno tre giocatori non sbloccano l\'uscita cliccando il lucchetto, chi esce non pu&ograve; risedersi a un qualunque tavolo per '.floor(BAN_TIME/60).' minuti.'),
                        'en' => Array ( 'EN Benvenuto al tavolo. Se almeno tre giocatori non sbloccano l\'uscita cliccando il lucchetto, chi esce non pu&ograve; risedersi a un qualunque tavolo per '.floor(BAN_TIME/60).' minuti.') );

function multoval($mult)
{
    GLOBAL $G_lang;

    if ($mult == 2)
        return ($G_lang == 'en' ? 'double' : 'doppio');
    if ($mult == 3)
        return ($G_lang == 'en' ? 'triple' : 'triplo');
    else if ($mult == 4)
        return ($G_lang == 'en' ? 'quadruple' : 'quadruplo');
    else
        return (sprintf(($G_lang == 'en' ? "%d-ple" : "%d-plo"), $mult));
}


class Card {
    var $value; /* 0 - 39 card value */
    var $stat;  /* 'bunch', 'hand', 'table', 'take' */
    var $owner; /* (table position 0-4) */
    // var $pos;   /* Pos in hand. */
    var $x;     /* When played the X position on the table of the owner. */
    var $y;     /* When played the Y position on the table of the owner. */

    function Card($value, $stat, $owner)
    {
        $this->value = $value;
        $this->stat  = $stat; // Card stat
        $this->owner = $owner;
    }

    function assign($stat,$owner)
    {
        $this->stat  = $stat; // Card stat
        $this->owner = $owner;
    }

    function setpos($pos)
    {
        $this->pos   = $pos;
    }

    function play($x,$y)
    {
        $this->stat = 'table'; // Card stat
        $this->x = $x;
        $this->y = $y;
    }

    function take($newown)
    {
        $this->stat = 'take'; // Card stat
        $this->owner = $newown;
    }
} // end class Card

class Bin5_table extends Table {
    var $card;       // il mazzo di carte
    var $mazzo;      // chi e' di mazzo
    var $gstart;
    var $turn;

    var $asta_pla;
    var $asta_pla_n;
    var $asta_card;
    var $asta_pnt;
  
    var $mult;
    var $points;    // points array
    var $points_n;  // number of row of points
    var $total;

    var $asta_win;
    var $briscola;
    var $friend;
  
    var $old_reason;
    var $old_asta_pnt;
    var $old_mult;
    var $old_pnt;
    var $old_win;
    var $old_friend;

    function Bin5_table() 
    {
    }


    /* CREATE() NOT USED
       function create($idx) 
       {
       if (($thiz =& new Bin5_table()) == FALSE)
       return (FALSE);

       $thiz->create($idx);

       $thiz->card      =   FALSE;
       $thiz->asta_pla  =   array(); // TRUE: in auction, FALSE: out of the auction
       $thiz->asta_pla_n=  -1;
       $thiz->asta_card =  -1;
       $thiz->asta_pnt  =  -1;
       $thiz->mult      =   0;
    
       $thiz->points    =   array( );
       $thiz->points_n  =   0;
       $thiz->total     =   array( 0, 0, 0, 0, 0);
       $thiz->asta_win  =  -1;
       $thiz->briscola  =  -1;
       $thiz->friend    =  -1;
       $thiz->turn      =   0;

       $thiz->old_reason   = "";
       $thiz->old_asta_pnt = -1;
       $thiz->old_mult     = -1;
       $thiz->old_pnt      = -1;
       $thiz->old_win      = -1;
       $thiz->old_friend   = -1;

       return ($thiz);
       }
    */

    /* CLONE() NOT USED
       function myclone(&$from)
       {
       if (($thiz =& new Bin5_table()) == FALSE)
       return (FALSE);
    
       parent::copy($from);

       $thiz->card = $from->card;
       $thiz->mazzo = $from->mazzo; // REVIEW
       $thiz->gstart = $from->gstart;
       $thiz->turn = $from->turn;

       $thiz->asta_pla = $from->asta_pla;
       $thiz->asta_pla_n = $from->asta_pla_n;
       $thiz->asta_card = $from->asta_card;
       $thiz->asta_pnt = $from->asta_pnt;
    
       $thiz->mult = $from->mult;
       $thiz->points = $from->points;
       $thiz->points_n = $from->points_n;
       $thiz->total = $from->total;
    
       $thiz->asta_win = $from->asta_win;
       $thiz->briscola = $from->briscola;
       $thiz->friend = $from->friend;
    
       $thiz->old_reason = $from->old_reason;
       $thiz->old_asta_pnt = $from->old_asta_pnt;
       $thiz->old_mult = $from->mult;
       $thiz->old_pnt = $from->old_pnt;
       $thiz->old_win = $from->old_win;
       $thiz->old_friend = $from->old_friend;

       return ($thiz);
       }
    */

    function parentcopy(&$from)
    {
        parent::copy($from);
    }

    function spawn(&$from)
    {
        if (($thiz =& new Bin5_table()) == FALSE)
            return (FALSE);
    
        $thiz->parentcopy($from);

        log_main("PLAYER_N - spawn.".$thiz->player_n);

        $thiz->card = array();
        $thiz->bunch_create();
        $thiz->mazzo    = rand(0,PLAYERS_N-1);
        $thiz->points_n = 0;
        $thiz->mult     = 0;
        $thiz->old_win    = -1;
        $thiz->old_reason = "";

        // players are rearranged in an dedicated array
        $thiz->player = array();
        for ($i = 0 ; $i < $from->player_n ; $i++)
            $thiz->player[$i] = $i;

        log_main("TABLE_OLD_WIN - spawn:".$thiz->old_win);

        return ($thiz);
    }

    function asta2mult($asta_pnt)
    {
        if ($asta_pnt > 110)
            return (6);
        else if ($asta_pnt > 100)
            return (5);
        else if ($asta_pnt > 90)
            return (4);
        else if ($asta_pnt > 80)
            return (3);
        else if ($asta_pnt > 70)
            return (2);
        else
            return (1);
    }

    function multer($is_new)
    {
        if ($is_new) {
            return (pow(2, $this->mult) * $this->asta2mult($this->asta_pnt));
        }
        else {
            return (pow(2, $this->old_mult) * $this->asta2mult($this->old_asta_pnt));
        }
    }


    //   function bunch_create_old() function AND 
    //   {
    //     $ret = array();
    // 
    //     for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
    //       // for ($i = 0 ; $i < 40 ; $i++) {
    //       $ret[$i] =& new Card($i, 'bunch', 'no_owner');
    //     }
    // 
    //     $oret = &$ret;
    //     return ($oret);
    //   }

    function bunch_create()
    {
        $ret = array();
      
        for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
            $this->card[$i] = new Card($i, 'bunch', 'no_owner');
        }
    }

    function bunch_make()
    {
        log_main("bunch_make start");
        $ct = array(0,0,0,0,0);
    
        mt_srand(make_seed());
    
        for ($i = (BIN5_PLAYERS_N == 5 ? 40 : 24) - 1 ; $i >= 0 ; $i--) 
            $rest[$i] = $i;

        for ($i = (BIN5_PLAYERS_N == 5 ? 40 : 24) - 1 ; $i >= 0 ; $i--) {
            $rn = rand(0, $i);
      
            if ($rn == 0)
                log_main("RND ZERO");
      
            $id = $rest[$rn];

            $owner = $i % BIN5_PLAYERS_N;
            $this->card[$id]->assign('hand', $owner);

            $rest[$rn] = $rest[$i];
            // $pubbpos[$rn2] = $pubbpos[$i];
        }
        log_main("bunch_make end");
    }

    function init($userarr)
    {
        /* MOVED INTO SPAWN
           $this->mazzo    =  rand(0,PLAYERS_N-1);
           $this->points_n =  0;
           $this->mult     =  0;
           $this->old_win  = -1;
           $this->old_reason = "";
        */
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $this->total[$i] = 0;
            $user_cur = $userarr[$this->player[$i]];
            $user_cur->exitislock = TRUE;
        }

        log_main("table::init: ci siamo");
    }

    function game_init($userarr)
    {
        log_rd2("GSTART 4");

        $this->gstart = ($this->mazzo+1) % BIN5_PLAYERS_N;
        $this->bunch_make();
    
    
        $this->asta_pla_n = BIN5_PLAYERS_N;
        $this->asta_card = -1;
        $this->asta_pnt  = 60;
        $this->asta_win  = -1;
        $this->briscola  = -1;
        $this->friend    = -1;
        $this->turn      =  0;
    
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $this->asta_pla[$i] = TRUE;
            $user_cur = $userarr[$this->player[$i]];
            $user_cur->subst = 'asta';
            $user_cur->asta_card = -2;
            $user_cur->asta_pnt  = -1;
            $user_cur->handpt = $this->hand_points($i);
            // SEE function calculate_points(&$table)
        }
        log_rd2("GEND 4");
    }

    function game_next()
    {
        $this->mazzo  = ($this->mazzo + 1) % BIN5_PLAYERS_N;
    }


    function hand_points($idx)
    {
        GLOBAL $G_all_points; 
    
        $tot = 0;
    
        for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
            // for ($i = 0 ; $i < 40 ; $i++) {
            if ($this->card[$i]->owner != $idx)
                continue;

            $ctt = $this->card[$i]->value % 10;
            $tot += $G_all_points[$ctt];
        }

        return ($tot);
    }


    function exitlock_show($userarr, $table_pos)
    {
        $ct = $this->exitlock_calc($userarr, $table_pos);

        $ret = sprintf('exitlock_show(%d, %s);', $ct, 
                       ($userarr[$this->player[$table_pos]]->exitislock ? 'true' : 'false'));
        return ($ret);
    }

    function exitlock_calc(&$userarr, $table_pos)
    {
        $ct = 0;

        for ($i = 0 , $ct = 0 ; $i < PLAYERS_N ; $i++) {	
            if ($userarr[$this->player[$i]]->exitislock == FALSE)
                $ct++;
        }

        return ($ct);
    }
} // end class Bin5_table




define('BIN5_USER_FLAG_RING_ENDAUCT', 0x01);

class Bin5_user extends User {
    var $asta_card;  // 
    var $asta_pnt;   //
    var $handpt;     // Total card points at the beginning of the current hand.
    var $exitislock; // Player can exit from the table ?
    var $privflags;  // Flags for briskin5 only 

    const BASE = "../";
    
    function User() {
    }
    
    /* CREATE NOT USED
       function create($name, $sess, $stat = "", $subst = "", $table = -1, $ip="0.0.0.0") {
       if (($thiz =& new User()) == FALSE)
       return (FALSE);
     
       $thiz->asta_card = -2;
       $thiz->asta_pnt  = -1;
       $thiz->handpt = -1;
       $thiz->exitislock = TRUE;
       $thiz->privflags = 0;
     
       return ($thiz);
       }
    */
    
    function parentcopy(&$from)
    {
        parent::copy($from);
    }
    
    function copy(&$from)
    {
        $this->parentcopy($from);
        
        $this->asta_card  = $from->asta_card;
        $this->asta_pnt   = $from->asta_pnt;
        $this->handpt     = $from->handpt;
        $this->exitislock = $from->exitislock;
        $this->privflags  = $from->privflags;
    }
    
    /* CLONE NOT USED
       function myclone(&$from)
       {
       if (($thiz =& new User()) == FALSE)
       return (FALSE);
     
       $thiz->copy($from);
     
       return ($thiz);
       } 
    */
    
    static function spawn($from, &$bri, $table, $table_pos, $get, $post, $cookie)
    {
        if (($thiz = new Bin5_user()) == FALSE)
            return (FALSE);

        if (($CO_bin5_pref_ring_endauct = gpcs_var("CO_bin5_pref_ring_endauct", $get, $post, $cookie)) === FALSE) {
            $CO_bin5_pref_ring_endauct = "";
        }

        $thiz->parentcopy($from);
        
        /* NOTE: at this moment idx and table_pos fields have the same value 
           but diffentent functions, we keep them separated for a while */
        $thiz->room       = $bri;
        $thiz->idx        = $table_pos;
        $thiz->asta_card  = -2;
        $thiz->asta_pnt   = -1;
        $thiz->handpt     = -1;
        $thiz->exitislock = TRUE;
        
        log_wr("Bin5 constructor");
        
        $thiz->privflags  = ($CO_bin5_pref_ring_endauct == "true" ? BIN5_USER_FLAG_RING_ENDAUCT : 0) | 0;

        $thiz->table_orig = $table;
        $thiz->table      = 0;
        $thiz->table_pos  = $table_pos;
        
        $thiz->step_inc();

        return ($thiz);
    }

    function step_set($step) 
    {
        $this->step = $step & 0x7fffffff;
        
        return TRUE;
    }
    
    function step_inc($delta = 1) {
        $this->step += $delta;
        /* modularization because unpack() not manage unsigned 32bit int correctly */
        $this->step &= 0x7fffffff;
        
        return (TRUE);
    }

    static function load_step($tab_id, $sess)
    {
        $fp = FALSE;
        do {
            if (validate_sess($sess) == FALSE)
                break;
            
            if (file_exists(BIN5_PROXY_PATH."/table".$tab_id) == FALSE)
                mkdir(BIN5_PROXY_PATH."/table".$tab_id, 0775, TRUE);
            if (($fp = @fopen(BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step", 'rb')) == FALSE)
                break;
            if (($s = fread($fp, 8)) == FALSE)
                break;
            if (mb_strlen($s, "ASCII") != 8)
                break;
            $arr = unpack('Ls/Li', $s);
            fclose($fp);
            
            // log_rd2("A0: ".$arr[0]."  A1: ".$arr[1]);
            return ($arr);
        } while (0);
        
        if ($fp != FALSE)
            fclose($fp);
        
        log_rd2("STEP_GET [".$sess."]: return false ");
        
        return (FALSE);
    }

    function save_step() 
    {
        do {
            if (validate_sess($this->sess) == FALSE)
                break;
            if (file_exists(BIN5_PROXY_PATH."/table".$this->table_orig) == FALSE)
                mkdir(BIN5_PROXY_PATH."/table".$this->table_orig, 0775, TRUE);
            if (($fp = @fopen(BIN5_PROXY_PATH."/table".$this->table_orig."/".$this->sess.".step", 'w')) == FALSE)
                break;
            fwrite($fp, pack("LL",$this->step, $this->idx));
            fclose($fp);
            
            log_main("step_set [".$this->sess. "] [".$this->step."]"); 
            
            return (TRUE);
        } while (0);
        
        return (FALSE);
    }
    
    static function unproxy_step($tab_id, $sess)
    {
        log_rd2("UNPROXY: ".BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step");
        if (file_exists(BIN5_PROXY_PATH."/table".$tab_id) == FALSE)
            return;

        @unlink(BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step");
    }
    
    function destroy_data($tab_id) 
    {
        do {
            if (($tok = @ftok(FTOK_PATH."/bin5/table".$tab_id."/user".$this->table_pos, "B")) == -1) {
                log_crit("BIN5 USER DATA REMOVE FAILED 1 [".FTOK_PATH."/bin5/table".$tab_id."/user".$this->table_pos."]");
                break;
            }
          
            if (($shm = @shmop_open($tok, 'a', 0, 0)) == FALSE) {
                log_crit("BIN5 USER DATA REMOVE FAILED 2");
                break;
            }
            if (shmop_delete($shm) == 0) {
                log_crit("BIN5 USER DATA REMOVE FAILED 3");
                break;
            }
            $shm = FALSE;

            log_main("BIN5 USER DATA DESTROY SUCCESS");
          
            // log_main("QUI CI ARRIVA [".$bri->user[0]->name."]");
            $ret = TRUE;
        } while (0);
      
        if ($shm)
            shm_detach($shm);
      
        return ($ret);
    }

    static function blocking_error($is_unrecoverable)
    {
        log_crit("BLOCKING_ERROR UNREC: ".($is_unrecoverable ? "TRUE" : "FALSE"));
        return (sprintf(($is_unrecoverable ? 'xstm.stop(); ' : '').'window.onbeforeunload = null; window.onunload = null; document.location.assign("../index.php");'));
    }
    
    protected function page_sync($sess, $page)
    {
        log_rd2("PAGE_SYNC");
        printf("xXx BIN5_USER::PAGE_SYNC\n");
        return (sprintf('xstm.stop(); window.onbeforeunload = null; window.onunload = null; document.location.assign("%s");', $page));
    }

    protected function maincheck($cur_stat, $cur_subst, $cur_step, &$new_stat, &$new_subst, &$new_step, $splashdate, $table_idx, $table_token)
    {
        GLOBAL $G_lang, $mlang_indrd;
        GLOBAL $G_with_splash, $G_splash_content, $G_splash_interval, $G_splash_idx;
        GLOBAL $G_splash_w, $G_splash_h, $G_splash_timeout;
        $CO_splashdate = "CO_splashdate".$G_splash_idx;
        $$CO_splashdate = $splashdate;
        
        GLOBAL $S_load_stat;
        
        log_rd("maincheck begin");
        
        $ret = FALSE;
        $curtime = time();
        
      /* Nothing changed, return. */
      if ($cur_step == $this->step) 
          return (FALSE);
      
      log_rd2("do other cur_stat[".$cur_stat."] user->stat[".$this->stat."] cur_step[".$cur_step."] user_step[".$this->step."]");
      
      if ($cur_step == -1) {
          /*
           *  if $cur_step == -1 load the current state from the main struct
           */
          
          $S_load_stat['wR_minusone']++;
          
          // if ($this->the_end == TRUE) {
          // log_rd2("main_check: the end".var_export(debug_backtrace()));
          // }
          
          if ($this->trans_step != -1) {
              log_rd2("TRANS USATO ".$this->trans_step);
              $cur_step = $this->trans_step;
              $this->trans_step = -1;
          }
          else {
              log_rd2("TRANS NON ATTIVATO");
          }
      }
      
      
      /* this part I suppose is read only on $this->room structure */
      if ($cur_step == -1) {
          log_rd2("PRE-NEWSTAT");
              
          /***************
           *             *
           *    TABLE    *
           *             *
           ***************/
          if ($this->stat == 'table') {
              log_load("RESYNC");
              /* NOTE: $this->room is associated with the current $bri object */
              printf("xXx CLASS NAME [%s]\n", get_class($this->room));
              $ret = show_table(&$this->room, $this, $this->step, FALSE, FALSE);
          }
          log_rd2("NEWSTAT: ".$this->stat);

          $new_stat =  $this->stat;
          $new_subst = $this->subst;
          $new_step =  $this->step;
      } /* if ($cur_step == -1) { */
      else {
          /* $sem = Room::lock_data(FALSE); */
          $S_load_stat['rU_heavy']++;
          
          if ($cur_step < $this->step) {
              do {
                  if ($cur_step + COMM_N < $this->step) {
                      if (($cur_stat != $this->stat)) {
                          $to_stat = $this->stat;
                          /* Room::unlock_data($sem); */
                          log_load("RESYNC");
                          printf("xXx BIN5_USER::MAINCHECK\n");
                          return ($this->page_sync($this->sess, ($to_stat == "table" ? "index.php" : "../index.php"), $this->table, $this->table_token));
                      }
                      log_rd2("lost history, refresh from scratch");
                      printf("xXx LOST HISTORY!\n");
                      $new_step = -1;
                      break;
                  } 
                  for ($i = $cur_step ; $i < $this->step ; $i++) {
                      $ii = $i % COMM_N;
                      log_rd2("ADDED TO THE STREAM: ".$this->comm[$ii]);
                      $ret .= $this->comm[$ii];
                  }
                  $new_stat =  $this->stat;
                  $new_subst = $this->subst;
                  $new_step =  $this->step;
              } while (0);
              
              log_rd2($this->step, 'index_rd.php: after ret set');
              
              if ($this->the_end == TRUE) {
                  log_rd2("LOGOUT BYE BYE!!");
                  log_auth($this->sess, "Explicit logout.");
                  
                  if ($this->the_end == TRUE) {
                      $this->reset();
                      
                      // FIXME !!! 
                      /* if ($this->subst == 'sitdown') { */
                      /*     log_load("ROOM WAKEUP"); */
                      /*     $this->room->room_wakeup($this); */
                      /* } */
                      /* else if ($this->subst == 'standup') */
                      /*     $this->room->room_outstandup($this); */
                      /* else */
                      /*     log_rd2("LOGOUT FROM WHAT ???"); */
                      
                  } /* if ($this->the_end == TRUE) { ... */
              } /* if ($this->the_end == TRUE) { ... */
          } /* if ($cur_step < $this->step) { */
          
          /* Room::unlock_data($sem); */
      }  /* else of if ($cur_step == -1) { */
      
    
      return ($ret);
  }  //   function maincheck (...






} // end class Bin5_user



class Bin5 {
    static $delta_t = array();

    var $user;
    var $table;
    var $comm; // commands for many people
    var $step; // current step of the comm array
    var $garbage_timeout;
    var $shm_sz;
    
    var $table_idx;
    var $table_token;
    
    var $the_end;
    var $tok;

    var $delay_mgr;

    function Bin5 ($room, $table_idx, $table_token, $get, $post, $cookie) {
        $this->user = array();
        $this->table = array();
        
        $this->the_end = FALSE;
        $this->shm_sz = BIN5_SHM_MIN;
        if (($this->tok = @ftok(FTOK_PATH."/bin5/table".$table_idx."/table", "B")) == -1) {
            echo "FTOK FAILED";
            exit;
        }
        
        $user  = $room->user;
        $table = $room->table[$table_idx];
        
        log_wr("Bin5 constructor");
        
        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user[$table->player[$i]]->table_token = $table_token;
            $this->user[$i] = Bin5_user::spawn($user[$table->player[$i]], $this, $table_idx, $i, $get, $post, $cookie);
        }
        $this->table[0] = Bin5_table::spawn(&$table);
        
        log_main("TABLE_OLD_WIN - Bin5:".$this->table[0]->old_win);
        
        $this->table_idx = $table_idx;
        $this->table_token = $table_token;
        $this->garbage_timeout = 0;
        
        $this->delay_mgr = new Delay_Manager((GARBAGE_TIMEOUT *3.0) / 2.0);

        log_wr("Bin5 constructor end");
    }
    

    function get_user($sess, &$idx)
    {
        GLOBAL $PHP_SELF;
        
        if (validate_sess($sess)) {
            for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                if (strcmp($sess, $this->user[$i]->sess) == 0) {
                    // find it
                    $idx = $i;
                    $ret = &$this->user[$i];
                    return ($ret);
                }
            }
            log_main(sprintf("get_user: Wrong sess from page [%s]",$PHP_SELF));
            // for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) 
            // log_main(sprintf("get_user: Wrong sess compared with [%s]",$this->user[$i]->sess));
        }
        else {
            log_main(sprintf("get_user: Wrong strlen [%s]",$sess));
        }
        
        return (FALSE);
    }
    
    
    function garbage_manager($force)
    {
        GLOBAL $G_base;
        
        /* Garbage collector degli utenti in timeout */
        $ismod = FALSE;
        $curtime = time();

        $delta = $this->delay_mgr->delta_get($curtime);

        if ($force || $this->garbage_timeout < $curtime) {
            for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                $user_cur = $this->user[$i];
                if ($user_cur->sess == "" || 
                    ($user_cur->stat == 'table' && ($user_cur->subst == 'shutdowned' || $user_cur->subst == 'shutdowner')))
                    continue;
                
                if ($user_cur->lacc + EXPIRE_TIME_RD < ($curtime - $delta)) { // Auto logout dell'utente
                    log_rd2($user_cur->sess." bin5 AUTO LOGOUT.");
                    
                    if ($user_cur->stat == 'table') {
                        log_auth($user_cur->sess," bin5 Autologout session.");
                        
                        /* SI DELEGA AL garbage_manager principale LA RIMOZIONE DELL'UTENTE 
                           
                           $tmp_sess = $user_cur->sess;
                           $user_cur->sess = "";
                           Bin5_user::step_unproxy($tmp_sess);
                           $user_cur->name = "";
                           $user_cur->the_end = FALSE;
                           
                        */
                        
                        /* se gli altri utenti non erano d'accordo questo utente viene bannato */
                        $remcalc = $this->table[0]->exitlock_calc(&$this->user, $user_cur->table_pos);
                        if ($remcalc < 3) {
                            require_once("${G_base}Obj/hardban.phh");
                            Hardbans::add(($user_cur->flags & USER_FLAG_AUTH ? $user_cur->name : FALSE),
                                          $user_cur->ip, $user_cur->sess, $user_cur->laccwr + BAN_TIME);
                        }
                        //      $user->bantime = $user->laccwr + BAN_TIME;
                        
                        $this->table_wakeup($user_cur);
                    }
                }
            }
            log_rd2($user_cur->sess." GARBAGE UPDATED!");
            
            $this->garbage_timeout = $curtime + GARBAGE_TIMEOUT;
            
            $ismod = TRUE;
        }
        
        $this->delay_mgr->lastcheck_set($curtime);
        return ($ismod);
    }
    

    function destroy_data() 
    {
        GLOBAL $sess;

        $ret =   FALSE;
        $shm =   FALSE;
        log_main("DESTROY BRISKIN5 DATA");
    
        do {
            log_main("DESTROY2 BRISKIN5 DATA [".$this->table_idx."]");
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                $this->user[$i]->destroy_data($this->table_idx);
                Bin5_user::unproxy_step($this->table_idx, $this->user[$i]->sess);
            }
            if (($tok = @ftok(FTOK_PATH."/bin5/table".$this->table_idx."/table", "B")) == -1) 
                break;

            if (($shm = @shmop_open($tok, 'a', 0, 0)) == FALSE)
                break;
      
            if (shmop_delete($shm) == 0) {
                log_only("REMOVE FALLITA ");
                break;
            }
   
            $shm = FALSE;
            log_main("DESTROY2 BRISKIN5 DATA SUCCESS");
      
            // log_main("QUI CI ARRIVA [".$bri->user[0]->name."]");
            $ret = TRUE;
        } while (0);
    
        if ($shm)
            shm_detach($shm);
    
        return ($ret);
    }

    static function lock_data($is_exclusive, $table_idx)
    {
        if (($res = file_lock(FTOK_PATH."/bin5/table".$table_idx."/table", $is_exclusive)) != FALSE) {
            self::$delta_t = microtime(TRUE);
            log_lock("LOCK   table [".$table_idx."]         [".self::$delta_t[$table_idx]."]");
          
            return (new Vect(array('res' => $res, 'tab' => $table_idx)));
        }
      
        return (FALSE);
    }

  
    static function unlock_data($res_vect)
    {
        GLOBAL $sess; 

        $res = $res_vect->getbyid('res');
        $tab = $res_vect->getbyid('tab');

        log_lock("UNLOCK table [".$tab."]         [".(microtime(TRUE) - (self::$delta_t[$tab]))."]");

        file_unlock($res);
    }


    function chatt_send($user, $mesg)
    {
        GLOBAL $mlang_brisk, $G_lang;

        if ($user->stat == 'table') {
            $table = &$this->table[$user->table];
        }
    
        $user_mesg = substr($mesg,6);
    
        $curtime = time();
    
        $dt = date("H:i ", $curtime);
        if (strncmp($user_mesg, "/nick ", 6) == 0) {
            log_main($user->sess." chatt_send BEGIN");

            if (($name_new = validate_name(substr($user_mesg, 6))) == FALSE) {
                $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";
                $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $mlang_brisk['nickmust'][$G_lang]);
                $user->step_inc();

                return;
            }
            $user_mesg = "COMMAND ".$user_mesg;
            // Search dup name
            // change
            // update local graph
            // update remote graphs
            for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                $user_cur = $this->user[$i];
                // 	if ($user_cur->sess == '' || $user_cur->stat != 'room')
                if ($user_cur->sess == '')
                    continue;
                if (strcasecmp($user_cur->name, $name_new) == 0) {
                    $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";

                    $premsg = sprintf($mlang_brisk['nickdupl'][$G_lang], xcape($name_new));
                    $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"%s");', $dt, NICKSERV, $premsg);
                    $user->step_inc();
                    break;
                }
            }
            if ($i == BIN5_MAX_PLAYERS) {
                if ($user->flags & USER_FLAG_AUTH && strcasecmp($user->name,$name_new) != 0) {
                    if ($this->table[$user->table]->auth_only == TRUE) {
                        $user->comm[$user->step % COMM_N] = "gst.st = ".($user->step+1)."; ";
                        $user->comm[$user->step % COMM_N] .= sprintf('chatt_sub("%s", [2, "%s"],"<b>%s</b>");', $dt, NICKSERV, $mlang_brisk['authchan'][$G_lang]);
                        $user->step_inc();
                        return;
                    }
                    else {
                        $user->flags &= ~USER_FLAG_AUTH; // Remove auth if name changed
                    }
                }
    
                $user->name = $name_new;

                log_main($user->sess." chatt_send start set");
	

                for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                    log_main($user->sess." chatt_send set loop");
	  
                    $user_cur = &$this->user[$i];
                    if ($user_cur->sess == '')
                        continue;
          
                    if ($user_cur->stat == 'table' && $user_cur->table == $user->table) {
                        $table = &$this->table[$user->table];
	    
                        $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
                        $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('set_names([%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"]); ',
                                                                             $this->user[$table->player[($user_cur->table_pos) % BIN5_PLAYERS_N]]->flags,
                                                                             xcape($this->user[$table->player[($user_cur->table_pos) % BIN5_PLAYERS_N]]->name),

                                                                             $this->user[$table->player[($user_cur->table_pos+1) % BIN5_PLAYERS_N]]->flags,
                                                                             xcape($this->user[$table->player[($user_cur->table_pos+1) % BIN5_PLAYERS_N]]->name),

                                                                             $this->user[$table->player[($user_cur->table_pos+2) % BIN5_PLAYERS_N]]->flags,
                                                                             xcape($this->user[$table->player[($user_cur->table_pos+2) % BIN5_PLAYERS_N]]->name),

                                                                             (BIN5_PLAYERS_N == 3 ? 0:  $this->user[$table->player[($user_cur->table_pos+3) % BIN5_PLAYERS_N]]->flags),
                                                                             (BIN5_PLAYERS_N == 3 ? "" :  xcape($this->user[$table->player[($user_cur->table_pos+3) % BIN5_PLAYERS_N]]->name)),

                                                                             (BIN5_PLAYERS_N == 3 ? 0:  $this->user[$table->player[($user_cur->table_pos+4) % BIN5_PLAYERS_N]]->flags),
                                                                             (BIN5_PLAYERS_N == 3 ? "" :  xcape($this->user[$table->player[($user_cur->table_pos+4) % BIN5_PLAYERS_N]]->name)));
                        if ($user_cur == $user) {
                            $user_cur->comm[$user_cur->step % COMM_N] .= $user_cur->myname_innerHTML();
                        }
                        $user_cur->step_inc();
                    }
                }
            }
        }
        else {
            for ($i = 0 ; $i < ($user->stat == 'room' ? BIN5_MAX_PLAYERS : BIN5_PLAYERS_N) ; $i++) {
                if ($user->stat == 'room') {
                    $user_cur = &$this->user[$i];
                    if ($user_cur->sess == '' || $user_cur->stat != 'room')
                        continue;
                }
                else {
                    $user_cur = &$this->user[$table->player[$i]];
                }
	
                $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
                $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('chatt_sub("%s", [%d, "%s"],"%s");',
                                                                     $dt, $user->flags, xcape($user->name), xcape($user_mesg));
                $user_cur->step_inc();
            }
            log_legal($curtime, $user->ip, $user, ($user->stat == 'room' ? 'room' : 'table '.$user->table_orig),$user_mesg);
        }
    }

    function table_wakeup($user)
    {
        $table = &$this->table[0];

        log_main("BIN5_WAKEUP begin function table  stat: ".$user->stat."  subst: ".$user->subst);

        $curtime = time();

        log_main("BIN5_WAKEUP from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);
    
        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user_cur = &$this->user[$i];
            log_main("PREIMPOST INLOOP name: ".$user_cur->name);
      
            if ($user_cur == $user)
                $user_cur->subst = "shutdowner";
            else
                $user_cur->subst = "shutdowned";
            $user_cur->laccwr = $curtime;

            $ret = "gst.st = ".($user_cur->step+1)."; ";
            $ret .= 'gst.st_loc++; xstm.stop(); window.onbeforeunload = null; window.onunload = null; document.location.assign("../index.php");|';

            log_wr($user_cur->sess." BIN5_WAKEUP: ".$ret);
            $user_cur->comm[$user_cur->step % COMM_N] = $ret;
            $user_cur->step_inc();
        }

        $this->the_end = TRUE;
    }
  
    /*
     *  If all players are freezed the room garbage_manager clean up table and users.
     */ 
    function is_abandoned() 
    {
        $is_ab = TRUE;
        $curtime = time();

        $table = &$this->table[0];

        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user_cur = &$this->user[$i];

            if ($user_cur->lacc + (EXPIRE_TIME_RD * 2) >= $curtime) { 
                $is_ab = FALSE;
                break;
            }
        }

        return ($is_ab);
    }

    static function request_mgr(&$s_a_p, $header, &$header_out, &$new_socket, $path, $addr, $get, $post, $cookie)
    {
        GLOBAL $G_black_list;

        printf("NEW_SOCKET (root): %d\n", intval($new_socket));
        
        $enc = get_encoding($header);
        if (isset($header['User-Agent'])) {
            if (strstr($header['User-Agent'], "MSIE")) {
                $transp_type = "htmlfile";
            }
            else {
                $transp_type = "xhr";
            }
        }
        else {
            $transp_type = "iframe";
        }
        force_no_cache($header_out);

        if (($table_idx = gpcs_var('table_idx', $get, $post, $cookie)) === FALSE) 
            unset($table_idx);
        
        if (($table_token = gpcs_var('table_token', $get, $post, $cookie)) === FALSE) 
            unset($table_token);


        switch ($path) {
        case "":
        case "index.php":
            ob_start();
            bin5_index_main($transp_type, $header_out, $addr, $get, $post, $cookie);
            $content = ob_get_contents();
            ob_end_clean();
        
            $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
            return TRUE;
        
        break;
        case "index_wr.php":
            // FIXME $content can be unset
            if (isset($table_idx) && isset($table_token)) {
                if (($bri = $s_a_p->app->match_get($table_idx, $table_token)) != FALSE) {
                    ob_start();
                    bin5_index_wr_main($bri, $addr, $get, $post, $cookie);
                    $content = ob_get_contents();
                    ob_end_clean();
                }
                else {
                    $content = "Bin5 Load data error";
                }
            }
            else {
                $content = "Bin5 Load data error";
            }
            $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
            return TRUE;
            
            break;
        case "index_rd_ifra.php":
            do {
                if (!isset($table_idx)
                    || !isset($table_token)
                    || !isset($cookie['sess'])
                    || ($bri = $s_a_p->app->match_get($table_idx, $table_token)) == NULL
                    || (($user = $bri->get_user($cookie['sess'], $idx)) == FALSE)) {

                    $content = Bin5_user::stream_fini($transp_type, $s_a_p->rndstr, TRUE);
                    $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);

                    return TRUE;
                    break;
                }
                // close a previous opened index_read_ifra socket, if exists
                if (($prev = $user->rd_socket_get()) != NULL) {
                    $s_a_p->socks_unset($user->rd_socket_get());
                    fclose($user->rd_socket_get());
                    printf("CLOSE AND OPEN AGAIN ON IFRA2\n");
                    $user->rd_socket_set(NULL);
                }
                
                $content = "";
                $user->stream_init($s_a_p->rndstr, $enc, $header_out, $content, $get, $post, $cookie);
                $response = headers_render($header_out, -1).chunked_content($user->rd_zls_get(), $content);
                $response_l = mb_strlen($response, "ASCII");
                
                $wret = @fwrite($new_socket, $response, $response_l);
                if ($wret < $response_l) {
                    printf("TROUBLES WITH FWRITE: %d\n", $wret);
                    $user->rd_cache_set(mb_substr($content, $wret, $response_l - $wret, "ASCII"));
                }
                else {
                    $user->rd_cache_set("");
                }
                fflush($new_socket);
                
                
                $s_a_p->socks_set($new_socket, $user, NULL);
                $user->rd_socket_set($new_socket);
                printf(" - qui ci siamo - ");
                return TRUE;
            } while (FALSE);
            
            return FALSE;
            break;
            
        default:
            return FALSE;
            break;
      }

      return (FALSE);
  }



} // end class Bin5

function locshm_exists($tok)
{
    // return (TRUE);

    if (($id = @shmop_open($tok,"a", 0, 0)) == FALSE) {
        log_main($tok." SHM NOT exists");

        return (FALSE);
    }
    else {
        shmop_close($id);
        log_main($tok." SHM exists");

        return (TRUE);
    }
    
}


// rendiamo qui l'elenco dei punti come return della func
function calculate_points(&$table)
{
    GLOBAL $G_all_points; 

    $ret = array();
    $pro = 0;

    if ($table->asta_pnt == 60)
        $table->asta_pnt = 61;

    $table->old_reason = "";
    $table->old_win = $table->asta_win;
    $table->old_friend = $table->friend;
    $table->old_asta_pnt = $table->asta_pnt;
    $table->old_mult = $table->mult;

    // count points for the temporary 2 teams
    for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
        // for ($i = 0 ; $i < 40 ; $i++) {
        $ctt = $table->card[$i]->value % 10;
        $own = $table->card[$i]->owner;
        if ($own == $table->asta_win || $own == $table->friend) 
            $pro += $G_all_points[$ctt];
    }

    log_wr(sprintf("PRO: [%d]", $pro));

    // PATTA case !
    if ($table->asta_pnt == 61 && $pro == 60) {
        $table->points[$table->points_n % MAX_POINTS] = array();
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $table->points[$table->points_n % MAX_POINTS][$i] = 0;
            $ret[$i] = 0;
        }
        $table->points_n++;
        $table->old_pnt = $pro;
        $table->mult += 1;

        return($ret);
    }

    if ($pro >= $table->asta_pnt) 
        $sig = 1;
    else
        $sig = -1;

    $table->points[$table->points_n % MAX_POINTS] = array();
    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
        if ($i == $table->asta_win) 
            $pt = ($i == $table->friend ? 4 : 2);
        else if ($i == $table->friend) 
            $pt = 1;
        else
            $pt = -1;
    
    

        log_wr(sprintf("PRO: pt[%d][%d] = %d", $table->points_n % MAX_POINTS, $i, $pt));

        $pt = $pt * $sig * $table->multer(TRUE) * ($pro == 120 ? 2 : 1);

        log_wr(sprintf("PRO:[%d][%d][%d]", $sig, $table->multer(TRUE), ($pro == 120 ? 2 : 1)));
    
        $table->points[$table->points_n % MAX_POINTS][$i] = $pt;
        $table->total[$i] += $pt;
        $ret[$i] = $pt;
    }
    $table->points_n++;
    $table->old_pnt = $pro;
    $table->mult = 0;
  
    return($ret);
}

/* show table 
   is_transition (is from room to table ?)
   is_again      (is another game)

   Examples                    of $is_transition, $is_again:
   from reload of the page:              FALSE, FALSE
   from sitdown in room:                  TRUE, FALSE
   from table: asta cmd e tutti passano:  TRUE, TRUE
   from table: fine partita:              TRUE, TRUE
*/
function show_table(&$bri, &$user, $sendstep, $is_transition, $is_again)
{
    $table_idx = $user->table;
    $table     = $bri->table[$table_idx];
    $table_pos = $user->table_pos;

    $ret = "table_init();";
    $ret .= $table->exitlock_show(&$bri->user, $table_pos);
    if (!$is_again) {
        /* GENERAL STATUS */
        $ret .= sprintf( 'gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;',
                         $sendstep, $user->stat, $user->subst, $table_pos);

        log_rd(sprintf( 'SHOW_TABLE: gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;', $sendstep, $user->stat, $user->subst, $table_pos));

        /* BACKGROUND */
        $ret .= "background_set();";
    
        /* USERS INFO */
        $ret .= $user->myname_innerHTML();
        $ret .= sprintf('set_names([%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"]); ',
                        $bri->user[$table->player[($table_pos) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos) % BIN5_PLAYERS_N]]->name),

                        $bri->user[$table->player[($table_pos+1) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos+1) % BIN5_PLAYERS_N]]->name),

                        $bri->user[$table->player[($table_pos+2) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos+2) % BIN5_PLAYERS_N]]->name),

                        (BIN5_PLAYERS_N == 3 ? 0 : $bri->user[$table->player[($table_pos+3) % BIN5_PLAYERS_N]]->flags),
                        (BIN5_PLAYERS_N == 3 ? "" :  xcape($bri->user[$table->player[($table_pos+3) % BIN5_PLAYERS_N]]->name)),

                        (BIN5_PLAYERS_N == 3 ? 0 : $bri->user[$table->player[($table_pos+4) % BIN5_PLAYERS_N]]->flags),
                        (BIN5_PLAYERS_N == 3 ? "" :  xcape($bri->user[$table->player[($table_pos+4) % BIN5_PLAYERS_N]]->name)));
    }
    /* NOTIFY FOR THE CARD MAKER */
    if ($is_transition) { //  && $user->subst ==  "asta" superfluo
        $ret .= show_table_info(&$bri, &$table, $table_pos);
        $ret .= "setTimeout(preload_images, 500, g_preload_img_arr, g_imgct);";
    }
    if (!$is_again) 
        $ret .= table_welcome($user);

    if ($is_transition && !$is_again) { // appena seduti al tavolo, play della mucca
        $ret .= playsound("cow.mp3");
    }


    /* CARDS */
    if ($is_transition) { //  && $user->subst ==  "asta" superfluo
        $ret .= "|";
    
        for ($i = 0 ; $i < 8 ; $i++) {
            for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++) {
                $ct = 0;
                for ($o = 0 ; $o < (BIN5_PLAYERS_N == 5 ? 40 : 24) && $ct < $i+1 ; $o++) {
                    // for ($o = 0 ; $o < 40 && $ct < $i+1 ; $o++) {
                    if ($table->card[$o]->owner == (($e + $table->gstart) % BIN5_PLAYERS_N)) {
                        $ct++;
                        if ($ct == $i+1)
                            break;
                    }
                }
                log_rd("O ".$o." VAL ".$table->card[$o]->value." Owner: ".$table->card[$o]->owner);
	
                $ret .= sprintf( ' card_send(%d,%d,%d,%8.2f,%d);|', ($table->gstart + $e) % BIN5_PLAYERS_N, 
                                 $i, ((($e + BIN5_PLAYERS_N - $table_pos + $table->gstart) % BIN5_PLAYERS_N) == 0 ?
                                      $table->card[$o]->value : -1), 
                                 ($i == 7 && $e == (BIN5_PLAYERS_N - 1) ? 1 : 0.5),$i+1);
            }
        }    
    }
    else {
        $taked  = array(0,0,0,0,0);
        $inhand = array(0,0,0,0,0);
        $ontabl  = array(-1,-1,-1,-1,-1);
        $cards  = array();

        for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
            // for ($i = 0 ; $i < 40 ; $i++) {
            if ($table->card[$i]->stat == 'hand') {
                if ($table->card[$i]->owner == $table_pos) {
                    $cards[$inhand[$table->card[$i]->owner]] = $table->card[$i]->value;
                }
                $inhand[$table->card[$i]->owner]++;
            }
            else if ($table->card[$i]->stat == 'take') {
                log_main("Card taked: ".$table->card[$i]->value."OWN: ".$table->card[$i]->owner);
                $taked[$table->card[$i]->owner]++;
            }
            else if ($table->card[$i]->stat == 'table') {
                $ontabl[$table->card[$i]->owner] = $i;
            }
        }
        $logg = "\n";
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $logg .= sprintf("INHAND: %d   IN TABLE %d   TAKED %d\n", $inhand[$i], $ontabl[$i], $taked[$i]);
        }
        log_main("Stat table: ".$logg);

        /* Set ours cards. */
        $oursarg = "";
        for ($i = 0 ; $i < $inhand[$table_pos] ; $i++) 
            $oursarg .= ($i == 0 ? "" : ", ").$cards[$i];
        for ($i = $inhand[$table_pos] ; $i < 8 ; $i++) 
            $oursarg .= ($i == 0 ? "" : ", ")."-1";
        $ret .= sprintf('card_setours(%s);', $oursarg);

        /* Dispose all cards */
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            /* Qui sotto al posto di + 1 c'era + ->gstart ... credo in modo errato */
            $ret .= sprintf('cards_dispose(%d,%d,%d);', $i,
                            ($inhand[$i] <= 8 ? $inhand[$i] : 8)  , $taked[$i]);

            if ($ontabl[$i] != -1) {
                $ret .= sprintf('card_place(%d,%d,%d,%d,%d);',$i, $inhand[$i], 
                                $table->card[$ontabl[$i]]->value, 
                                $table->card[$ontabl[$i]]->x, $table->card[$ontabl[$i]]->y);
            }
        }
    }

    /* Show auction */
    if ($user->subst == 'asta') {

        /* show users auction status */
        $showst = "";
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $user_cur = &$bri->user[$table->player[$i]];
            $showst .= sprintf("%s%d", ($i == 0 ? "" : ", "), 
                               ($user_cur->asta_card < 9 ? $user_cur->asta_card : $user_cur->asta_pnt));
        }
        if (BIN5_PLAYERS_N == 3)
            $showst .= ",-2,-2";
        $ret .= sprintf('document.title = "Brisk - Tavolo %d (asta)";', $user->table_orig);
        $ret .= sprintf('show_astat(%s);', $showst);

        if ($table->asta_win != -1 && $table->asta_win == $table_pos) {
            /* show card chooser */
            $ret .= sprintf('choose_seed(%s); $("astalascio").style.visibility = ""; $("asta").style.visibility = "hidden";',
                            $table->asta_card);
        }
        else {
            /* show auction */
            if ($table_pos == ($table->gstart % BIN5_PLAYERS_N) &&
                $table->asta_win == -1) 
                $ret .= sprintf('dispose_asta(%d,%d, %s);', 
                                $table->asta_card + 1, $table->asta_pnt+1, ($user->handpt <= 2 ? "true" : "false"));
            else
                $ret .= sprintf('dispose_asta(%d,%d, %s);',
                                $table->asta_card + 1, -($table->asta_pnt+1), ($user->handpt <= 2 ?  "true" : "false"));
        }

        /* Remark */
        if ($table->asta_win == -1) { // auction case
            if ($table_pos == ($table->gstart % BIN5_PLAYERS_N)) 
                $ret .= "remark_on();";
            else
                $ret .= "remark_off();";
        }
        else { // chooseed case
            if ($table_pos == $table->asta_win) 
                $ret .= "remark_on();";
            else
                $ret .= "remark_off();";
        }
    }
    else if ($user->subst == 'game') {
        /* HIGHLIGHT */
        if (($table->gstart + $table->turn) % BIN5_PLAYERS_N == $table_pos) 
            $ret .= "is_my_time = true; remark_on();";
        else
            $ret .= "remark_off();";
    
        /* WHO CALL AND WHAT */
        $ret .= briscola_show($bri, $table, $user);
    
    }
    return ($ret);
} // end function show_table(...

function calculate_winner(&$table)
{
    $briontab = FALSE;
    $ontab = array();
    $ontid = array();
    $cur_win  =  -1;
    $cur_val  = 100;
    $cur_seed = $table->briscola - ($table->briscola % 10);

    for ($i = 0 ; $i < (BIN5_PLAYERS_N == 5 ? 40 : 24) ; $i++) {
        // for ($i = 0 ; $i < 40 ; $i++) {
        if ($table->card[$i]->stat != "table")
            continue;

        log_wr(sprintf("Card On table: [%d]", $i));

        $v = $table->card[$i]->value; 
        $ontab[$table->card[$i]->owner] = $v;
        $ontid[$table->card[$i]->owner] = $i;
        /* se briscola setto il flag */
        if (($v - ($v % 10)) == $cur_seed)
            $briontab = TRUE;
    }

    if ($briontab == FALSE) {
        $cur_win  = $table->gstart;
        $cur_val  = $ontab[$cur_win];
        $cur_seed = $cur_val - ($cur_val % 10);
    }

    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
        if (($ontab[$i] - ($ontab[$i] % 10)) == $cur_seed) {
            if ($ontab[$i] < $cur_val) {
                $cur_val = $ontab[$i];
                $cur_win = $i;
            }
        }
    }

    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
        $table->card[$ontid[$i]]->owner = $cur_win;
        $table->card[$ontid[$i]]->stat =  "take"; // Card stat
    }
    return ($cur_win);
}

function show_table_info(&$bri, &$table, $table_pos)
{
    GLOBAL $G_lang, $mlang_bin5_bin5;

    $ret = "";
    $user = $bri->user[$table->player[$table_pos]];

    $pnt_min = $table->points_n - MAX_POINTS < 0 ? 0 : $table->points_n - MAX_POINTS;
    $noty = sprintf('<table class=\"points\"><tr><th></th>');
  
    // Names.
    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) 
        $noty .= sprintf('<th class=\"td_points\">%s</th>', xcape($bri->user[$table->player[$i]]->name));
    $noty .= sprintf("</tr>");

    // Points.
    log_main("show_table_info: pnt_min: ".$pnt_min."   Points_n: ".$table->points_n);

    for ($i = $pnt_min ; $i < $table->points_n ; $i++) {
        $noty .= sprintf('<tr><th class=\"td_points\">%d</th>', $i+1);
        for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++) 
            $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->points[$i % MAX_POINTS][$e]);
        $noty .= "</tr>";
    }

    // Total points.
    $noty .= '<tr><th class=\"td_points\">Tot.</th>';
    for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++) 
        $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->total[$e]);
    $noty .= "</tr></table>";

    if ($table->old_reason != "") {
        $noty .= sprintf("<hr><b>%s</b><br>", xcape($table->old_reason));
    }

    if ($table->old_win != -1) {
        log_main("TABLE_OLD_WIN:".$table->old_win);
        $win = $table->player[$table->old_win];
        log_main("TABLE_OLD_FRIEND:".$table->old_friend);
        $fri = $table->player[$table->old_friend];

        $wol = game_result($table->old_asta_pnt, $table->old_pnt);

        if ($win != $fri) {
            /* MLANG: "<hr>Nell'ultima mano ha chiamato <b>%s</b>, il socio era <b>%s</b>,<br>", "hanno fatto <b>cappotto</b> EBBRAVI!.<hr>", "dovevano fare <b>%s</b> punti e ne hanno fatti <b>%d</b>: hanno <b>%s</b>.<hr>", "<hr>Nell'ultima mano <b>%s</b> si &egrave; chiamato in mano,<br>", "ha fatto <b>cappotto</b> EBBRAVO!.<hr>", "doveva fare <b>%s</b> punti e ne ha fatti <b>%d</b>: ha <b>%s</b>.<hr>", ($table->old_asta_pnt > 61 ? "almeno ".$table->old_asta_pnt : 'pi&ugrave; di 60'), $table->old_pnt, ($wol == 1 ? "vinto" : ($wol == 0 ? "pareggiato" : "perso" */
      
            $noty .= sprintf($mlang_bin5_bin5['info_part'][$G_lang], 
                             xcape($bri->user[$win]->name),
                             xcape($bri->user[$fri]->name));
            if ($table->old_pnt == 120) {
                $noty .= sprintf($mlang_bin5_bin5['info_capp'][$G_lang]);
            }
            else {
                $noty .= sprintf($mlang_bin5_bin5['info_pnt'][$G_lang],
                                 ($table->old_asta_pnt > 61 ? $mlang_bin5_bin5['info_alea'][$G_lang].$table->old_asta_pnt :
                                  $mlang_bin5_bin5['info_more'][$G_lang]), $table->old_pnt,
                                 ($wol == 1 ? $mlang_bin5_bin5['info_win'][$G_lang] : ($wol == 0 ? $mlang_bin5_bin5['info_peer'][$G_lang] : $mlang_bin5_bin5['info_lost'][$G_lang])));
            }
        }
        else {
            $noty .= sprintf($mlang_bin5_bin5['info_alon'][$G_lang],
                             xcape($bri->user[$win]->name));
            if ($table->old_pnt == 120) {
                $noty .= sprintf($mlang_bin5_bin5['info_acap'][$G_lang]);
            }
            else {
                $noty .= sprintf($mlang_bin5_bin5['info_apnt'][$G_lang],

                                 ($table->old_asta_pnt > 61 ? $mlang_bin5_bin5['info_alea'][$G_lang].$table->old_asta_pnt :
                                  $mlang_bin5_bin5['info_more'][$G_lang]), $table->old_pnt,

                                 ($wol == 1 ? $mlang_bin5_bin5['info_win'][$G_lang] : ($wol == 0 ? $mlang_bin5_bin5['info_peer'][$G_lang] : $mlang_bin5_bin5['info_lost'][$G_lang])));
            }
        }
        $old_multer = $table->multer(FALSE);
        if ($old_multer > 1) {
            $noty .= sprintf($mlang_bin5_bin5['info_omul'][$G_lang], multoval($old_multer));
        }
        $noty .= "<hr><br>";
    }
    /* MLANG: "Fai <b>tu</b> il mazzo,", "Il mazzo a <b>$unam</b>," */
    if ($table->mazzo == $table_pos) 
        $noty .= $mlang_bin5_bin5['info_yshuf'][$G_lang];
    else {
        $unam = xcape($bri->user[$table->player[$table->mazzo]]->name);
        $noty .= sprintf($mlang_bin5_bin5['info_shuf'][$G_lang], $unam);
    }

    if ($user->subst == 'asta') {
        if ($table->asta_win == -1)  // auction case
            $curplayer = $table->gstart % BIN5_PLAYERS_N;
        else 
            $curplayer = $table->asta_win;
    }
    else if ($user->subst == 'game') {
        $curplayer = ($table->gstart + $table->turn) % BIN5_PLAYERS_N;
    }

    /* MLANG: " tocca a <b>te</b> giocare.", " tocca a <b>$unam</b> giocare.", " La partita vale <b>%s</b>.", "torna alla partita" */
    if ($curplayer == $table_pos) {
        $noty .= $mlang_bin5_bin5['info_yturn'][$G_lang];
    }
    else {
        $unam = xcape($bri->user[$table->player[$curplayer]]->name);
        $noty .= sprintf($mlang_bin5_bin5['info_turn'][$G_lang], $unam);
    }
  
    $multer = $table->multer(TRUE);
    if ($multer > 1) {
        $noty .= sprintf($mlang_bin5_bin5['info_mult'][$G_lang], multoval($multer) );
    }
    $noty .= "<hr><br>";
    $ret .= show_notify($noty, 3000, $mlang_bin5_bin5['btn_bkgame'][$G_lang], 500, 400);
    /* NOTE: show_notify($noty, 3000, "torna alla partita", 500, 
     *                   130 + ($table->points_n > 0 ? 50 : 0) + 
     *                   (120 * ($table->points_n / MAX_POINTS)));
     *       will be used when we refact notify js function following 
     *       photoo class logic 
     */ 
  
    return ($ret);
}

function table_welcome($user)
{
    GLOBAL $table_wellarr, $G_lang;
    $ret = "";

    for ($i = 0 ; $i < count($table_wellarr[$G_lang]) ; $i++)
        $ret .= sprintf('chatt_sub("%s", [2, "ChanServ: "],"%s");', "", str_replace('"', '\"', $table_wellarr[$G_lang][$i]));

    return ($ret);
}


function briscola_show($bri, $table, $user)
{
    GLOBAL $G_lang, $mlang_bin5_bin5;
    $ptnadd = "";
    $ret = "";

    if ($table->asta_card == 9) 
        $ptnadd = sprintf($mlang_bin5_bin5['call_wptn'][$G_lang], $table->asta_pnt);
  
    /* text of caller cell */
    if ($user->table_pos == $table->asta_win) {
        $prestr = sprintf('$("callerinfo").innerHTML = "%s";', $mlang_bin5_bin5['call_ycall'][$G_lang]);
        $ret .= sprintf($prestr, $ptnadd);
    }
    else {
        $prestr = sprintf('$("callerinfo").innerHTML = "%s";', $mlang_bin5_bin5['call_call'][$G_lang]);
        $ret .= sprintf($prestr, 
                        xcape($bri->user[$table->player[$table->asta_win]]->name), $ptnadd);
    }
    $ret .= sprintf('set_iscalling(%d);', ($table->asta_win - $user->table_pos + BIN5_PLAYERS_N) % BIN5_PLAYERS_N);

    $ret .= sprintf('$("caller").style.backgroundImage = \'url("img/brisk_caller_sand%d.png")\';',
                    $table->asta_win);
    $ret .= sprintf('$("callerimg").src = "img/%02d.png";', $table->briscola);
    $ret .= sprintf('$("caller").style.visibility = "visible";');
    $ret .= sprintf('$("chooseed").style.visibility = "hidden";');
    $ret .= sprintf('$("astalascio").style.visibility = "";');
    $ret .= sprintf('$("asta").style.visibility = "hidden";');
    $ret .= sprintf('show_astat(-2,-2,-2,-2,-2);');
  
    return ($ret);
}


function game_result($asta_pnt, $pnt)
{
    if ($asta_pnt == 61) {
        if ($pnt > 60)
            return (1);
        else if ($pnt == 60)
            return (0);
        else
            return (-1);
    }
    else {
        if ($pnt >= $asta_pnt)
            return (1);
        else
            return (-1);
    }
}

function log_points($remote_addr, $curtime, $user, $where, $mesg) 
{
    if (($fp = @fopen(LEGAL_PATH."/points.log", 'a')) != FALSE) {
        /* Unix time | session | nickname | IP | where was | mesg */
        fwrite($fp, sprintf("%ld|%s|%s|%s|%s|%s|%s|\n", $curtime, $user->sess,
                            ($user->flags & USER_FLAG_AUTH ? 'A' : 'N'),
                            $user->name, $remote_addr, $where , $mesg));
        fclose($fp);
    }
}

?>
