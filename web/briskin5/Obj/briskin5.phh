<?php
/*
 *  brisk - briskin5.phh
 *
 *  Copyright (C) 2006-2013 Matteo Nastasi
 *                          mailto: nastasi@alternativeoutput.it
 *                                  matteo.nastasi@milug.org
 *                          web: http://www.alternativeoutput.it
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABLILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details. You should have received a
 * copy of the GNU General Public License along with this program; if
 * not, write to the Free Software Foundation, Inc, 59 Temple Place -
 * Suite 330, Boston, MA 02111-1307, USA.
 *
 */
define('BIN5_PLAYERS_N', 3);
define('BIN5_CARD_HAND', 3); // normal value 8
define('BIN5_MAX_PLAYERS', BIN5_PLAYERS_N);
// define(BIN5_SHM_MIN', (50000 * BIN5_MAX_PLAYERS));
define('BIN5_SHM_MIN', 32768);
define('BIN5_SHM_MAX', (BIN5_SHM_MIN + 1048576));
define('BIN5_SHM_DLT', 32768);
define('BIN5_PROXY_PATH', PROXY_PATH."/bin5");

require_once('rules.phh');

define('BIN5_TOURNAMENT_CURRENT', BIN5_TOURNAMENT_NO_DRAW);

$mlang_bin5_bin5 = array(
                         // br, hr, b, /b, win, fri
                         'info_last' => array( 'it' => '%3$sultima mano%4$s',
                                               'en' => '%3$slast hand%4$s'),
                         'info_curr' => array( 'it' => '%3$smano corrente%4$s',
                                               'en' => '%3$scurrent hand%4$s'),
                         'info_yshuf'=> array( 'it' => 'Fai <b>tu</b> il mazzo, ',
                                               'en' => 'It\'s <b>your</b> shuffled the cards, '),
                         'info_shuf' => array( 'it' => 'Il mazzo a <b>%s</b>, ',
                                               'en' => '<b>%s</b> shuffled the cards, '),
                         'info_yturn'=> array( 'it' => ' tocca a <b>te</b> giocare.',
                                               'en' => ' it\'s <b>your</b> turn.'),
                         'info_turn' => array( 'it' => 'tocca a <b>%s</b> giocare.',
                                               'en' => 'it\'s the <b>%s</b>\'s turn.'),
                         'info_mult' => array( 'it' => ' La partita vale <b>%s</b>.',
                                               'en' => ' The game worth <b>%s</b>.' ),
                         'info_match'=> array( 'it' => 'Il codice della partita è <b>%d</b>.',
                                               'en' => 'Match code is <b>%d</b>.'),



                         // br, hr, b, /b, win, fri
                         'info_part' => array( 'it' => 'Ha chiamato %3$s%5$s%4$s (punti torneo %7$d), il socio era %3$s%6$s%4$s,%1$s',
                                               'en' => 'The declarer was %3$s%5$s%4$s (tournment points %7$d), the partner was %3$s%6$s%4$s,%1$s'),
                         // br, hr, b, /b
                         'info_capp' => array( 'it' => 'hanno fatto %3$scappotto%4$s EBBRAVI!.%1$s',
                                               'en' => 'and they made %3Dscapot%4$s WELL DONE!.%1$s'),

                         // br, hr, b, /b, old_asta_pnt, old_pnt, winornot
                         'info_alea' => array( 'it' => 'dovevano fare %3$salmeno %5$d%4$s punti e ne hanno fatti %3$s%6$d%4$s: hanno %7$s.%1$s',
                                               'en' => 'they had to do %3$sat least %5$d%4$s points and they had made %3$s%6$d%4$s: they have %7$s.%1$s'),
                         // br, hr, b, /b, old_pnt, winornot
                         'info_more' => array( 'it' => 'dovevano fare %3$spiù di 60%4$s punti e ne hanno fatti %3$s%5$d%4$s: hanno %6$s.%1$s',
                                               'en' => 'they had to do %3$sover 60%4$s points and they had made %3$s%5$d%4$s: they have %3$s%6$s%4$s.%1$s'),
                         'info_win'  => array( 'it' => 'vinto',
                                               'en' => 'win'),
                         'info_peer' => array( 'it' => 'pareggiato',
                                               'en' => 'drew'),
                         'info_lost' => array( 'it' => 'perso',
                                               'en' => 'lost'),

                         // br, hr, b, /b, win_name
                         'info_alon' => array( 'it' => '%3$s%5$s%4$s si è chiamato in mano (punti torneo %6$d),%1$s',
                                               'en' => '%3$s%5$s%4$s play alone against each other (tournment points %6$d),%1$s'),
                         // br, hr, b, /b, old_asta_pnt, old_pnt, winornot
                         'info_aleaa' => array( 'it' => 'doveva fare %3$salmeno %5$d%4$s punti e ne ha fatti %3$s%6$d%4$s: ha %3$s%7$s%4$s.%1$s',
                                               'en' => 'he/she had to do %3$sat least %5$d%4$s points and they had made %3$s%6$d%4$s: he/she had %3$s%7$s%4$s.%1$s'),
                         // br, hr, b, /b, old_pnt, winornot
                         'info_morea' => array( 'it' => 'doveva fare %3$spiù di 60%4$s punti e ne ha fatti %3$s%5$d%4$s: ha %3$s%6$s%4$s.%1$s',
                                                'en' => 'he/she had to do %3$smore than 60%4$s points and they had made %3$s%5$d%4$s: he/she had %3$s%6$s%4$s.%1$s'),
                         // br, hr, b, /b
                         'info_acap' => array( 'it' => 'ha fatto %3$scappotto%4$s EBBRAVO!.%1$s',
                                               'en' => 'and he/she made %3$scapot%4$s WELL DONE!.%1$s'),

                         // br, hr, b, /b
                         'info_omul' => array( 'it' => '%1$sLa partita valeva %3$s%5$s%4$s.%1$s',
                                               'en' => '%1$sEN: The game was worth %3$s%5$s%4$s.%1$s' ),

                         // br, hr, b, /b
                         'info_alpa' => array( 'it' => '%1$sHanno passato %3$stutti%4$s.%1$s',
                                               'en' => '%1$sEN: Hanno passato %3$stutti%4$s.%1$s' ),

                         // br, hr, b, /b, aband-name
                         'info_aban' => array( 'it' => ' Ha lasciato %3$s%5$s%4$s perché aveva al massimo %3$s2 punti%4$s.',
                                               'en' => ' EN: Ha lasciato %3$s%5$s%4$s perché aveva al massimo %3$s2 punti%4$s.'),

                         'btn_bkgame'=> array( 'it' => 'torna alla partita',
                                               'en' => 'back to the game'),
                         'call_wptn' => array( 'it' => '<br>con %d punti',
                                               'en' => '<br>with %d points'),
                         'call_ycall'=> array( 'it' => 'Chiami%s:',
                                               'en' => 'Call%s:'),
                         'call_call' => array( 'it' => 'Chiama %s%s:',
                                               'en' => 'The declarer is %s%s:')
                          );

// MLANG
$table_wellarr = Array( 'it' => Array ( 'Benvenuto al tavolo. Se almeno tre giocatori non sbloccano l\'uscita cliccando il lucchetto, chi esce non pu&ograve; risedersi a un qualunque tavolo per '.floor(BAN_TIME/60).' minuti.'),
                        'en' => Array ( 'EN Benvenuto al tavolo. Se almeno tre giocatori non sbloccano l\'uscita cliccando il lucchetto, chi esce non pu&ograve; risedersi a un qualunque tavolo per '.floor(BAN_TIME/60).' minuti.') );

function multoval($mult)
{
    GLOBAL $G_lang;

    if ($mult == 2)
        return ($G_lang == 'en' ? 'double' : 'doppio');
    if ($mult == 3)
        return ($G_lang == 'en' ? 'triple' : 'triplo');
    else if ($mult == 4)
        return ($G_lang == 'en' ? 'quadruple' : 'quadruplo');
    else
        return (sprintf(($G_lang == 'en' ? "%d-ple" : "%d-plo"), $mult));
}

function dom_select_rules()
{
    printf("<select id='select_rules'><option value='1'>Vecchie regole: con pareggio</option><option value='2'>Nuove regole: senza pareggio</option><option value='4'>torneo \"insieme per gioco\"</option></select>");
}

class Card {
    var $value; /* 0 - 39 card value */
    var $stat;  /* 'bunch', 'hand', 'table', 'take' */
    var $owner; /* (table position 0-4) */
    // var $pos;   /* Pos in hand. */
    var $x;     /* When played the X position on the table of the owner. */
    var $y;     /* When played the Y position on the table of the owner. */

    function Card($value, $stat, $owner)
    {
        $this->value = $value;
        $this->stat  = $stat; // Card stat
        $this->owner = $owner;
    }

    function assign($stat,$owner)
    {
        $this->stat  = $stat; // Card stat
        $this->owner = $owner;
    }

    function setpos($pos)
    {
        $this->pos   = $pos;
    }

    function play($x,$y)
    {
        $this->stat = 'table'; // Card stat
        $this->x = $x;
        $this->y = $y;
    }

    function take($newown)
    {
        $this->stat = 'take'; // Card stat
        $this->owner = $newown;
    }
} // end class Card

class Bin5_table extends Table {
    var $card;       // il mazzo di carte
    var $mazzo;      // chi e' di mazzo
    var $gstart;
    var $turn;

    var $asta_pla;
    var $asta_pla_n;
    var $asta_card;
    var $asta_pnt;

    var $mult;
    var $points;    // points array
    var $points_n;  // number of row of points
    var $total;

    var $asta_win;          // the caller idx position at table
    var $briscola;
    var $tourn_pts;         // points in the caller hand
    var $friend;            // the callee idx position at table

    var $match_id;          // the id of the match on the database (-1 == just not saved)

    var $old_act;           // last action that trigs the end of the game
    var $old_mazzo;
    var $old_reason;
    var $old_asta_pnt;
    var $old_mult;
    var $old_pnt;           // points made by caller and callee
    var $old_asta_win;      // the old caller idx position at table
    var $old_friend;        // the old callee idx position at table

    var $old_tourn_pts;     // the old tournment computed points in the hand of caller
    var $rules;

    function Bin5_table()
    {
    }


    /* CREATE() NOT USED
       function create($idx)
       {
       if (($thiz =& new Bin5_table()) == FALSE)
       return (FALSE);

       $thiz->create($idx);

       $thiz->card      =   FALSE;
       $thiz->asta_pla  =   array(); // TRUE: in auction, FALSE: out of the auction
       $thiz->asta_pla_n=  -1;
       $thiz->asta_card =  -1;
       $thiz->asta_pnt  =  -1;
       $thiz->mult      =   0;

       $thiz->points    =   array( );
       $thiz->points_n  =   0;
       $thiz->total     =   array( 0, 0, 0, 0, 0);
       $thiz->asta_win  =  -1;
       $thiz->briscola  =  -1;
       $thiz->tourn_pts =  -1;
       $thiz->friend    =  -1;
       $thiz->turn      =   0;

       $thiz->match_id     = -1;

       $thiz->old_act      = -1;
       $thiz->old_mazzo    = -1;
       $thiz->old_reason   = "";
       $thiz->old_asta_pnt = -1;
       $thiz->old_mult     = -1;
       $thiz->old_pnt      = -1;
       $thiz->old_asta_win = -1;
       $thiz->old_friend   = -1;

       return ($thiz);
       }
    */

    /* CLONE() NOT USED
       function myclone(&$from)
       {
       if (($thiz =& new Bin5_table()) == FALSE)
       return (FALSE);

       parent::copy($from);

       $thiz->card         = $from->card;
       $thiz->mazzo        = $from->mazzo; // REVIEW
       $thiz->gstart       = $from->gstart;
       $thiz->turn         = $from->turn;

       $thiz->asta_pla     = $from->asta_pla;
       $thiz->asta_pla_n   = $from->asta_pla_n;
       $thiz->asta_card    = $from->asta_card;
       $thiz->asta_pnt     = $from->asta_pnt;

       $thiz->mult         = $from->mult;
       $thiz->points       = $from->points;
       $thiz->points_n     = $from->points_n;
       $thiz->total        = $from->total;

       $thiz->asta_win     = $from->asta_win;
       $thiz->briscola     = $from->briscola;
       $thiz->tourn_pts    = $from->tourn_pts;
       $thiz->friend       = $from->friend;

       $thiz->match_id     = $from->match_id;

       $thiz->old_act      = $from->old_act;
       $thiz->old_mazzo    = $from->old_mazzo;
       $thiz->old_reason   = $from->old_reason;
       $thiz->old_asta_pnt = $from->old_asta_pnt;
       $thiz->old_mult     = $from->mult;
       $thiz->old_pnt      = $from->old_pnt;
       $thiz->old_asta_win = $from->old_asta_win;
       $thiz->old_friend   = $from->old_friend;

       return ($thiz);
       }
    */

    function parentcopy(&$from)
    {
        parent::copy($from);
    }

    function spawn(&$from)
    {
        if (($thiz =& new Bin5_table()) == FALSE)
            return (FALSE);

        $thiz->parentcopy($from);

        log_main("PLAYER_N - spawn.".$thiz->player_n);

        $thiz->card = array();
        $thiz->bunch_create();
        $thiz->mazzo  = rand(0,PLAYERS_N-1);
        $thiz->points = array();
        $thiz->total  = array();
        $thiz->points_n = 0;
        $thiz->mult     = 0;

        $thiz->match_id     = -1;

        $thiz->old_asta_win = -1;
        $thiz->old_reason = "";

        $rules_name = rules_id2name(BIN5_TOURNAMENT_CURRENT);
        $thiz->rules = new $rules_name($thiz);
        // players are rearranged in an dedicated array
        $thiz->player = array();
        for ($i = 0 ; $i < $from->player_n ; $i++)
            $thiz->player[$i] = $i;

        log_main("TABLE_OLD_WIN - spawn:".$thiz->old_asta_win);

        return ($thiz);
    }


    //   function bunch_create_old() function AND
    //   {
    //     $ret = array();
    //
    //     for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
    //       // for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
    //       $ret[$i] =& new Card($i, 'bunch', 'no_owner');
    //     }
    //
    //     $oret = &$ret;
    //     return ($oret);
    //   }

    function bunch_create()
    {
        $ret = array();

        for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
            $this->card[$i] = new Card($i, 'bunch', 'no_owner');
        }
    }

    function bunch_make()
    {
        log_main("bunch_make start");
        $ct = array(0,0,0,0,0);

        mt_srand(make_seed());

        for ($i = (BIN5_CARD_HAND * BIN5_PLAYERS_N) - 1 ; $i >= 0 ; $i--)
            $rest[$i] = $i;

        for ($i = (BIN5_CARD_HAND * BIN5_PLAYERS_N) - 1 ; $i >= 0 ; $i--) {
            $rn = rand(0, $i);

            if ($rn == 0)
                log_main("RND ZERO");

            $id = $rest[$rn];

            $owner = $i % BIN5_PLAYERS_N;
            $this->card[$id]->assign('hand', $owner);

            $rest[$rn] = $rest[$i];
            // $pubbpos[$rn2] = $pubbpos[$i];
        }
        log_main("bunch_make end");
    }

    function init($userarr)
    {
        /* MOVED INTO SPAWN
           $this->mazzo    =  rand(0,PLAYERS_N-1);
           $this->points_n =  0;
           $this->mult     =  0;
           $this->old_asta_win  = -1;
           $this->old_reason = "";
        */
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $this->total[$i] = 0;
            $user_cur = $userarr[$this->player[$i]];
            $user_cur->stat_set('table');
            $user_cur->exitislock = TRUE;
        }

        log_main("table::init: ci siamo");
    }

    function game_init($userarr)
    {
        log_rd2("GSTART 4");

        $this->gstart = ($this->mazzo+1) % BIN5_PLAYERS_N;
        $this->bunch_make();

        $this->asta_pla_n = BIN5_PLAYERS_N;
        $this->asta_card = -1;
        $this->asta_pnt  = 60;
        $this->asta_win  = -1;
        $this->briscola  = -1;
        $this->tourn_pts = -1;
        $this->friend    = -1;
        $this->turn      =  0;

        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $this->asta_pla[$i] = TRUE;
            $user_cur = $userarr[$this->player[$i]];
            $user_cur->subst = 'asta';
            $user_cur->asta_card = -2;
            $user_cur->asta_pnt  = -1;
            $user_cur->handpt = $this->hand_points($i);
        }
        log_rd2("GEND 4");
    }

    function game_next($delta)
    {
        $this->old_mazzo = $this->mazzo;
        $this->mazzo  = ($this->mazzo + $delta) % BIN5_PLAYERS_N;
    }

    function mult_inc($val)
    {
        $this->old_mult = $this->mult;
        $this->mult += $val;
    }

    function mult_set($val)
    {
        $this->old_mult = $this->mult;
        $this->mult = $val;
    }

    function hand_points($idx)
    {
        GLOBAL $G_all_points;

        $tot = 0;

        for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
            // for ($i = 0 ; $i < 40 ; $i++) {
            if ($this->card[$i]->owner != $idx)
                continue;

            $ctt = $this->card[$i]->value % 10;
            $tot += $G_all_points[$ctt];
        }

        return ($tot);
    }


    function exitlock_show($userarr, $table_pos)
    {
        $ct = $this->exitlock_calc($userarr, $table_pos);

        $ret = sprintf('exitlock_show(%d, %s);', $ct,
                       ($userarr[$this->player[$table_pos]]->exitislock ? 'true' : 'false'));
        return ($ret);
    }

    function exitlock_calc(&$userarr, $table_pos)
    {
        $ct = 0;

        for ($i = 0 , $ct = 0 ; $i < PLAYERS_N ; $i++) {
            if ($userarr[$this->player[$i]]->exitislock == FALSE)
                $ct++;
        }

        return ($ct);
    }

    function match_continue(&$bri, $user, $match_id_s)
    {
        //
        //  Rules: update version following loaded tcode
        //
        $ret = FALSE;
        $curtime = time();

        do {
            if ($this->match_id != -1) {
                $msg = sprintf("Stai già giocando la partita con codice %d.", $this->match_id);
                break;
            }

            /* - verify if match_id and user are both valid to accept
               the match_continue request - */
            $match_id = (int)$match_id_s;
            if ($match_id <= 0) {
                $msg = "questa partita non esiste";
                break;
            }

            if ($user->continue_get() == $match_id) {
                $msg = "Hai già richiesto di continuare questa partita.";
                break;
            }
            // retrieves users list for this match
            $match_data = array();
            if (($bdb = BriskDB::create()) != FALSE) {
                // match_order_get return FALSE for old matches
                $ucodes = $bdb->match_order_get($match_data, $match_id, BIN5_PLAYERS_N);
                unset($bdb);
            }
            if ($ucodes == FALSE) {
                $msg = "questa partita non è stata memorizzata correttamente";
                break;
            }

            // if current user code must be in the users list
            if (array_search($user->code, $ucodes) === FALSE) {
                $msg = sprintf("Questo utente non compare nella partita che si vuole continuare [%d].", $user->code);
                break;
            }

            /* - the user is in the list, add the match_id to his profile
               and check if he is the N'th to require continue - */

            $continue_tot = 0;
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                $user_cur = &$bri->user[$this->player[$i]];

                if ($user == $user_cur) {
                    $continue_tot += 1;
                    continue;
                }

                if ($user_cur->continue_get() == BIN5_USER_CONTINUE_INIT)
                    continue;

                if ($user_cur->continue_get() != $match_id)
                    break;
                $continue_tot += 1;
            }
            if ($i < BIN5_PLAYERS_N) {
                $msg = sprintf("<b>L'utente <i>%s</i> voleva già continuare la partita n° %d.</b>",
                               xcape($user_cur->name), $user_cur->continue_get());
                break;
            }

            // set the match_id for the current user
            $user->continue_set($match_id);

            $ret = TRUE;
            // not all players set the continue match than we exit
            if ($continue_tot < BIN5_PLAYERS_N) {
                $msg = sprintf("<b>L'utente <i>%s</i> vorrebbe continuare la partita n° %d.</b>",
                               xcape($user->name), $match_id);
                break;
            }

            /* - all users decide to continue the same match, update all infos and rearrange users
               to the right positions on the table - */

            /*  reset users table order */
            for ($i = 0 ; $i < BIN5_PLAYERS_N - 1 ; $i++) {
                if ($bri->user[$this->player[$i]]->code == $ucodes[$i]) {
                    continue;
                }
                for ($e = $i + 1 ; $e < BIN5_PLAYERS_N ; $e++) {
                    if ($bri->user[$this->player[$e]]->code == $ucodes[$i]) {
                        $swap = $this->player[$i];
                        $this->player[$i] = $this->player[$e];
                        $this->player[$e] = $swap;
                        $bri->user[$this->player[$i]]->table_pos = $i;
                        $bri->user[$this->player[$e]]->table_pos = $e;
                    }
                }
            }
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                fprintf(STDERR, "USERZ: [%s]\n", $bri->user[$this->player[$i]]->name);
            }

            // update database info to be aligned with current table (ttok and table_idx
            if (($bdb = BriskDB::create()) != FALSE) {
                if ($bdb->match_continue($match_id, $this, $user->table_orig) == FALSE) {
                    unset($bdb);
                    $msg = "aggiornamento dei dati della partita fallito";
                    break;
                }
                unset($bdb);
            }

            /* update rules engine */
            $rules_name = rules_id2name($match_data['tcode']);
            $this->rules = new $rules_name($this);

            /* bunch and multiplier status set */
            $this->mazzo = $match_data['mazzo_next'];
            $this->mult  = $match_data['mult_next'];
            $this->match_id = $match_id;
            $this->game_init(&$bri->user);

            /* reload of the page with the new layout */
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                $user_cur = &$bri->user[$this->player[$i]];
                $user_cur->continue_set(BIN5_USER_CONTINUE_INIT);

                $user_cur->trans_step = $user_cur->step + 1;
                $user_cur->comm[$user_cur->step % COMM_N] = sprintf('gst.st_loc++; gst.st=%d; xstm.stop(); window.onunload = null ; window.onbeforeunload = null ; document.location.assign("index.php");|', $user_cur->step+1);
                $user_cur->step_inc();

                // a void command force xynt-streamer to flush all data to client
                $user_cur->trans_step = $user_cur->step + 1;
                $user_cur->comm[$user_cur->step % COMM_N] = "";
                $user_cur->step_inc();

                $user_cur->comm[$user_cur->step % COMM_N] = show_table(&$bri, &$user_cur, $user_cur->step+1, TRUE, FALSE);
                $user_cur->step_inc();
            }
            return (TRUE);
        } while (FALSE);

        $dt = date("H:i ", $curtime);
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            if ($ret == FALSE && $this->player[$i] != $user->idx)
                continue;
            $user_cur = &$bri->user[$this->player[$i]];
            $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
            $user_cur->comm[$user_cur->step % COMM_N] .= nickserv_msg($dt, $msg);
            $user_cur->step_inc();
        }
    }

    function rules_change(&$bri, $user, $rules_code_s)
    {
        //
        //  Rules: update version following loaded tcode
        //
        $ret = FALSE;
        $curtime = time();

        do {
            /* - verify if match_id and user are both valid to accept
               the match_continue request - */
            $rules_id = (int)$match_code_s;
            // FIXME: from dynamic rules list
            if ($rules_id != 1 && $rules_id != 2 && $rules_id != 4) {
                $msg = "queste regole non esistono o non sono attive";
                break;
            }

            if ($this->match_id != -1) {
                $msg = "Non si possono cambiare regole dopo che si è già ultimata una mano.";
                break;
            }

            // set the match_id for the current user
            $user->rules_set($rules_id);

            // XXXXXXXXXXX
            $tot_sel_rules = 0;
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                if ($bri->user[$this->player[$i]]->rules_get() == BIN5_USER_RULES_INIT) {
                    continue;
                }

                if ($bri->user[$this->player[$i]]->rules_get() != $rules_id) {
                    break;
                }
                $tot_sel_rules++;
            }
            $ret = TRUE;
            // not all players set the continue match than we exit
            if ($i < BIN5_PLAYERS_N) {
                $msg = sprintf("<b>L'utente <i>%s</i> vorrebbe utilizzare le %s.</b>",
                               xcape($user->name), xcape(rules_id2descr($rules_id)));
                break;
            }

            /* - all users decide to continue the same match, update all infos and rearrange users
               to the right positions on the table - */

            /*  reset users table order */
            for ($i = 0 ; $i < BIN5_PLAYERS_N - 1 ; $i++) {
                if ($bri->user[$this->player[$i]]->code == $ucodes[$i]) {
                    continue;
                }
                for ($e = $i + 1 ; $e < BIN5_PLAYERS_N ; $e++) {
                    if ($bri->user[$this->player[$e]]->code == $ucodes[$i]) {
                        $swap = $this->player[$i];
                        $this->player[$i] = $this->player[$e];
                        $this->player[$e] = $swap;
                        $bri->user[$this->player[$i]]->table_pos = $i;
                        $bri->user[$this->player[$e]]->table_pos = $e;
                    }
                }
            }
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                fprintf(STDERR, "USERZ: [%s]\n", $bri->user[$this->player[$i]]->name);
            }

            // update database info to be aligned with current table (ttok and table_idx
            if (($bdb = BriskDB::create()) != FALSE) {
                if ($bdb->match_continue($match_id, $this, $user->table_orig) == FALSE) {
                    unset($bdb);
                    $msg = "aggiornamento dei dati della partita fallito";
                    break;
                }
                unset($bdb);
            }

            /* update rules engine */
            $rules_name = rules_id2name($match_data['tcode']);
            $this->rules = new $rules_name($this);

            /* bunch and multiplier status set */
            $this->mazzo = $match_data['mazzo_next'];
            $this->mult  = $match_data['mult_next'];
            $this->match_id = $match_id;
            $this->game_init(&$bri->user);

            /* reload of the page with the new layout */
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                $user_cur = &$bri->user[$this->player[$i]];
                $user_cur->continue_set(BIN5_USER_CONTINUE_INIT);

                $user_cur->trans_step = $user_cur->step + 1;
                $user_cur->comm[$user_cur->step % COMM_N] = sprintf('gst.st_loc++; gst.st=%d; xstm.stop(); window.onunload = null ; window.onbeforeunload = null ; document.location.assign("index.php");|', $user_cur->step+1);
                $user_cur->step_inc();

                // a void command force xynt-streamer to flush all data to client
                $user_cur->trans_step = $user_cur->step + 1;
                $user_cur->comm[$user_cur->step % COMM_N] = "";
                $user_cur->step_inc();

                $user_cur->comm[$user_cur->step % COMM_N] = show_table(&$bri, &$user_cur, $user_cur->step+1, TRUE, FALSE);
                $user_cur->step_inc();
            }
            return (TRUE);
        } while (FALSE);

        $dt = date("H:i ", $curtime);
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            if ($ret == FALSE && $this->player[$i] != $user->idx)
                continue;
            $user_cur = &$bri->user[$this->player[$i]];
            $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
            $user_cur->comm[$user_cur->step % COMM_N] .= nickserv_msg($dt, $msg);
            $user_cur->step_inc();
        }
    }

} // end class Bin5_table




define('BIN5_USER_FLAG_RING_ENDAUCT', 0x01);
define('BIN5_USER_CONTINUE_INIT', -1);

define('BIN5_USER_RULES_INIT', -1);
class Bin5_user extends User {
    var $asta_card;  //
    var $asta_pnt;   //
    var $handpt;     // Total card points at the beginning of the current hand.
    var $exitislock; // Player can exit from the table ?
    var $privflags;  // Flags for briskin5 only

    var $continue;   // Id of the match that the user would continue
    var $rules;      // Id of rules required by user
    const BASE = "../";

    function User() {
    }

    /* CREATE NOT USED
       function create($name, $sess, $stat = "", $subst = "", $table = -1, $ip="0.0.0.0") {
       if (($thiz =& new User()) == FALSE)
       return (FALSE);

       $thiz->asta_card = -2;
       $thiz->asta_pnt  = -1;
       $thiz->handpt = -1;
       $thiz->exitislock = TRUE;
       $thiz->privflags = 0;
       $thiz->continue = BIN5_USER_CONTINUE_INIT;
       $thiz->rules = BIN5_USER_RULES_INIT;

       return ($thiz);
       }
    */

    function parentcopy(&$from)
    {
        parent::copy($from);
    }

    function copy(&$from)
    {
        $this->parentcopy($from);

        $this->asta_card  = $from->asta_card;
        $this->asta_pnt   = $from->asta_pnt;
        $this->handpt     = $from->handpt;
        $this->exitislock = $from->exitislock;
        $this->privflags  = $from->privflags;
        $this->continue   = $from->continue;
        $this->rules      = $from->rules;
    }

    /* CLONE NOT USED
       function myclone(&$from)
       {
       if (($thiz =& new User()) == FALSE)
       return (FALSE);

       $thiz->copy($from);

       return ($thiz);
       }
    */

    static function spawn($from, &$bri, $table, $table_pos, $get, $post, $cookie)
    {
        if (($thiz = new Bin5_user()) == FALSE)
            return (FALSE);

        if (($CO_bin5_pref_ring_endauct = gpcs_var("CO_bin5_pref_ring_endauct", $get, $post, $cookie)) === FALSE) {
            $CO_bin5_pref_ring_endauct = "";
        }

        $thiz->parentcopy($from);

        /* NOTE: at this moment idx and table_pos fields have the same value
           but diffentent functions, we keep them separated for a while */
        $thiz->room       = $bri;
        $thiz->idx        = $table_pos; // it is the position in the mini-room,
                                        // not related to table pos (see below)
        $thiz->asta_card  = -2;
        $thiz->asta_pnt   = -1;
        $thiz->handpt     = -1;
        $thiz->exitislock = TRUE;
        $thiz->continue   = BIN5_USER_CONTINUE_INIT;
        $thiz->rules      = BIN5_USER_RULES_INIT;

        log_wr("Bin5 constructor");

        $thiz->privflags  = ($CO_bin5_pref_ring_endauct == "true" ? BIN5_USER_FLAG_RING_ENDAUCT : 0) | 0;

        $thiz->table_orig = $table;
        $thiz->table      = 0;
        $thiz->table_pos  = $table_pos;

        $thiz->step_inc();

        return ($thiz);
    }

    function step_set($step)
    {
        $this->step = $step & 0x7fffffff;

        return TRUE;
    }

    function step_inc($delta = 1) {
        $this->step += $delta;
        /* modularization because unpack() not manage unsigned 32bit int correctly */
        $this->step &= 0x7fffffff;

        return (TRUE);
    }

    static function load_step($tab_id, $sess)
    {
        $fp = FALSE;
        do {
            if (validate_sess($sess) == FALSE)
                break;

            if (file_exists(BIN5_PROXY_PATH."/table".$tab_id) == FALSE)
                mkdir(BIN5_PROXY_PATH."/table".$tab_id, 0775, TRUE);
            if (($fp = @fopen(BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step", 'rb')) == FALSE)
                break;
            if (($s = fread($fp, 8)) == FALSE)
                break;
            if (mb_strlen($s, "ASCII") != 8)
                break;
            $arr = unpack('Ls/Li', $s);
            fclose($fp);

            // log_rd2("A0: ".$arr[0]."  A1: ".$arr[1]);
            return ($arr);
        } while (0);

        if ($fp != FALSE)
            fclose($fp);

        log_rd2("STEP_GET [".$sess."]: return false ");

        return (FALSE);
    }

    function save_step()
    {
        do {
            if (validate_sess($this->sess) == FALSE)
                break;
            if (file_exists(BIN5_PROXY_PATH."/table".$this->table_orig) == FALSE)
                mkdir(BIN5_PROXY_PATH."/table".$this->table_orig, 0775, TRUE);
            if (($fp = @fopen(BIN5_PROXY_PATH."/table".$this->table_orig."/".$this->sess.".step", 'w')) == FALSE)
                break;
            fwrite($fp, pack("LL",$this->step, $this->idx));
            fclose($fp);

            log_main("step_set [".$this->sess. "] [".$this->step."]");

            return (TRUE);
        } while (0);

        return (FALSE);
    }

    static function unproxy_step($tab_id, $sess)
    {
        log_rd2("UNPROXY: ".BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step");
        if (file_exists(BIN5_PROXY_PATH."/table".$tab_id) == FALSE)
            return;

        @unlink(BIN5_PROXY_PATH."/table".$tab_id."/".$sess.".step");
    }

    function destroy_data($tab_id)
    {
        do {
            if (($tok = @ftok(FTOK_PATH."/bin5/table".$tab_id."/user".$this->table_pos, "B")) == -1) {
                log_crit("BIN5 USER DATA REMOVE FAILED 1 [".FTOK_PATH."/bin5/table".$tab_id."/user".$this->table_pos."]");
                break;
            }

            if (($shm = @shmop_open($tok, 'a', 0, 0)) == FALSE) {
                log_crit("BIN5 USER DATA REMOVE FAILED 2");
                break;
            }
            if (shmop_delete($shm) == 0) {
                log_crit("BIN5 USER DATA REMOVE FAILED 3");
                break;
            }
            $shm = FALSE;

            log_main("BIN5 USER DATA DESTROY SUCCESS");

            // log_main("QUI CI ARRIVA [".$bri->user[0]->name."]");
            $ret = TRUE;
        } while (0);

        if ($shm)
            shm_detach($shm);

        return ($ret);
    }

    static function blocking_error($is_unrecoverable)
    {
        log_crit("BLOCKING_ERROR UNREC: ".($is_unrecoverable ? "TRUE" : "FALSE"));
        return (sprintf(($is_unrecoverable ? 'xstm.stop(); ' : '').'window.onbeforeunload = null; window.onunload = null; document.location.assign("../index.php");'));
    }

    protected function page_sync($sess, $page)
    {
        log_rd2("PAGE_SYNC");
        printf("xXx BIN5_USER::PAGE_SYNC\n");
        return (sprintf('xstm.stop(); window.onbeforeunload = null; window.onunload = null; document.location.assign("%s");', $page));
    }

    protected function maincheck($get, $post, $cookie)
    {
        GLOBAL $G_lang;
        GLOBAL $G_with_splash, $G_splash_content, $G_splash_interval, $G_splash_idx;
        GLOBAL $G_splash_w, $G_splash_h, $G_splash_timeout;

        GLOBAL $S_load_stat;

        log_rd("maincheck begin");

        $ret = FALSE;
        $curtime = time();

      /* Nothing changed, return. */
      if ($this->rd_step == $this->step)
          return (FALSE);

      log_rd2("do other cur_stat[".$this->rd_stat."] user->stat[".$this->stat."] cur_step[".$this->rd_step."] user_step[".$this->step."]");

      if ($this->rd_step == -1) {
          /*
           *  if $this->rd_step == -1 load the current state from the main struct
           */

          $S_load_stat['wR_minusone']++;

          // if ($this->the_end == TRUE) {
          // log_rd2("main_check: the end".var_export(debug_backtrace()));
          // }

          if ($this->trans_step != -1) {
              log_rd2("TRANS USATO ".$this->trans_step);
              $this->rd_step = $this->trans_step;
              $this->trans_step = -1;
          }
          else {
              log_rd2("TRANS NON ATTIVATO");
          }
      }


      /* this part I suppose is read only on $this->room structure */
      if ($this->rd_step == -1) {
          log_rd2("PRE-NEWSTAT");

          /***************
           *             *
           *    TABLE    *
           *             *
           ***************/
          if ($this->stat == 'table') {
              log_load("RESYNC");
              /* NOTE: $this->room is associated with the current $bri object */
              printf("xXx CLASS NAME [%s]\n", get_class($this->room));
              $ret = show_table(&$this->room, $this, $this->step, FALSE, FALSE);
          }
          log_rd2("NEWSTAT: ".$this->stat);

          $this->rd_stat  = $this->stat;
          $this->rd_subst = $this->subst;
          $this->rd_step  = $this->step;
      } /* if ($this->rd_step == -1) { */
      else {
          $S_load_stat['rU_heavy']++;

          if ($this->rd_step < $this->step) {
              do {
                  if ($this->rd_step + COMM_N < $this->step) {
                      if ($this->rd_stat != $this->stat) {
                          $to_stat = $this->stat;
                          log_load("RESYNC");
                          printf("xXx BIN5_USER::MAINCHECK\n");
                          return ($this->page_sync($this->sess, ($to_stat == "table" ? "index.php" : "../index.php"), $this->table, $this->table_token));
                      }
                      log_rd2("lost history, refresh from scratch");
                      printf("xXx LOST HISTORY!\n");
                      $this->rd_step = -1;
                      break;
                  }
                  for ($i = $this->rd_step ; $i < $this->step ; $i++) {
                      $ii = $i % COMM_N;
                      if ($this->comm[$ii] == "") {
                          if ($i == $this->rd_step)
                              continue;
                          else
                              break;
                      }
                      log_rd2("ADDED TO THE STREAM: ".$this->comm[$ii]);
                      $ret .= $this->comm[$ii];
                  }
                  $this->rd_stat  = $this->stat;
                  $this->rd_subst = $this->subst;
                  $this->rd_step  = $this->step;
              } while (0);

              log_rd2($this->step, 'index_rd.php: after ret set');

              // if ($this->the_end == TRUE) { management is moved
              // in the spush scope
          } /* if ($this->rd_step < $this->step) { */
      }  /* else of if ($this->rd_step == -1) { */


      return ($ret);
    }  //   function maincheck(...

    function continue_set($match_code)
    {
        $this->continue = $match_code;
    }

    function continue_get() {
        return ($this->continue);
    }

    function rules_set($rules_id)
    {
        $this->rules = $rules_id;
    }

    function rules_get() {
        return ($this->rules);
    }

} // end class Bin5_user


class Bin5 {
    static $delta_t = array();
    var $brisk;// room object reference

    var $user;
    var $table;
    var $comm; // commands for many people
    var $step; // current step of the comm array
    var $garbage_timeout;
    var $shm_sz;

    var $table_idx;
    var $table_token;

    var $the_end;
    var $tok;

    var $delay_mgr;

    function Bin5($brisk, $table_idx, $table_token, $get, $post, $cookie) {
        $this->user = array();
        $this->table = array();

        $this->the_end = FALSE;
        $this->shm_sz = BIN5_SHM_MIN;
        if (($this->tok = @ftok(FTOK_PATH."/bin5/table".$table_idx."/table", "B")) == -1) {
            echo "FTOK FAILED";
            exit;
        }

        $this->brisk = $brisk;
        $user  = $brisk->user;
        $table = $brisk->table[$table_idx];
        log_wr("Bin5 constructor");

        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user[$table->player[$i]]->table_token = $table_token;
            $this->user[$i] = Bin5_user::spawn($user[$table->player[$i]], $this, $table_idx, $i, $get, $post, $cookie);
        }
        $this->table[0] = Bin5_table::spawn(&$table);

        log_main("TABLE_OLD_WIN - Bin5:".$this->table[0]->old_asta_win);

        $this->table_idx = $table_idx;
        $this->table_token = $table_token;
        $this->garbage_timeout = 0;

        $this->delay_mgr = new Delay_Manager((GARBAGE_TIMEOUT *3.0) / 2.0);

        log_wr("Bin5 constructor end");
    }


    function get_user($sess, &$idx)
    {
        GLOBAL $PHP_SELF;

        if (validate_sess($sess)) {
            for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                if ($this->user[$i]->is_empty())
                    continue;
                if (strcmp($sess, $this->user[$i]->sess) == 0) {
                    // find it
                    $idx = $i;
                    $ret = &$this->user[$i];
                    return ($ret);
                }
            }
            log_main(sprintf("get_user: Wrong sess from page [%s]",$PHP_SELF));
            // for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++)
            // log_main(sprintf("get_user: Wrong sess compared with [%s]",$this->user[$i]->sess));
        }
        else {
            log_main(sprintf("get_user: Wrong strlen [%s]",$sess));
        }

        return (FALSE);
    }
    function banned_kickoff()
    {
        $is_ban = FALSE;

        for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
            $user_cur = $this->user[$i];

            // check if the IP is blacklisted
            if ($this->brisk->black_check($user_cur->ip)) {
                $user_cur->lacc = 0;
                $is_ban = TRUE;
                continue;
            }

            // if authorized not check if banlisted
            if ($user_cur->is_auth()) {
                continue;
            }

            if ($this->brisk->ban_check($user_cur->ip)) {
                $user_cur->lacc = 0;
                $is_ban = TRUE;
            }
        }
        return ($is_ban);
    }

    function garbage_manager($force)
    {
        GLOBAL $G_base;

        /* Garbage collector degli utenti in timeout */
        $ismod = FALSE;
        $curtime = time();

        $delta = $this->delay_mgr->delta_get($curtime);

        if ($force || $this->garbage_timeout < $curtime) {
            for ($i = 0 ; $i < BIN5_MAX_PLAYERS ; $i++) {
                $user_cur = $this->user[$i];
                if ($user_cur->is_active() == FALSE || // is not active user or
                    ($user_cur->stat == 'table' && ($user_cur->subst == 'shutdowned' || $user_cur->subst == 'shutdowner')))
                    continue;

                if ($user_cur->lacc + EXPIRE_TIME_RD < ($curtime - $delta)) { // Auto logout dell'utente
                    log_rd2($user_cur->sess." bin5 AUTO LOGOUT.");

                    if ($user_cur->stat == 'table') {
                        log_auth($user_cur->sess," bin5 Autologout session.");

                        /* main garbage_manager is delegate as autologout management */
                        $user_cur->the_end = TRUE;

                        /* se gli altri utenti non erano d'accordo questo utente viene bannato */
                        $remcalc = $this->table[0]->exitlock_calc(&$this->user, $user_cur->table_pos);
                        if ($remcalc < 3) {
                            require_once("${G_base}Obj/hardban.phh");
                            Hardbans::add(($user_cur->is_auth() ? $user_cur->name : FALSE),
                                          $user_cur->ip, $user_cur->sess, $user_cur->laccwr + BAN_TIME);
                        }
                        //      $user->bantime = $user->laccwr + BAN_TIME;

                        $this->table_wakeup($user_cur);
                    }
                }
            }
            log_rd2($user_cur->sess." GARBAGE UPDATED!");

            $this->garbage_timeout = $curtime + GARBAGE_TIMEOUT;

            $ismod = TRUE;
        }

        $this->delay_mgr->lastcheck_set($curtime);
        return ($ismod);
    }


    function destroy_data()
    {
        GLOBAL $sess;

        $ret =   FALSE;
        $shm =   FALSE;
        log_main("DESTROY BRISKIN5 DATA");

        do {
            log_main("DESTROY2 BRISKIN5 DATA [".$this->table_idx."]");
            for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
                $this->user[$i]->destroy_data($this->table_idx);
                Bin5_user::unproxy_step($this->table_idx, $this->user[$i]->sess);
            }
            if (($tok = @ftok(FTOK_PATH."/bin5/table".$this->table_idx."/table", "B")) == -1)
                break;

            if (($shm = @shmop_open($tok, 'a', 0, 0)) == FALSE)
                break;

            if (shmop_delete($shm) == 0) {
                log_only("REMOVE FALLITA ");
                break;
            }

            $shm = FALSE;
            log_main("DESTROY2 BRISKIN5 DATA SUCCESS");

            // log_main("QUI CI ARRIVA [".$bri->user[0]->name."]");
            $ret = TRUE;
        } while (0);

        if ($shm)
            shm_detach($shm);

        return ($ret);
    }

    static function lock_data($is_exclusive, $table_idx)
    {
        if (($res = file_lock(FTOK_PATH."/bin5/table".$table_idx."/table", $is_exclusive)) != FALSE) {
            self::$delta_t = microtime(TRUE);
            log_lock("LOCK   table [".$table_idx."]         [".self::$delta_t[$table_idx]."]");

            return (new Vect(array('res' => $res, 'tab' => $table_idx)));
        }

        return (FALSE);
    }


    static function unlock_data($res_vect)
    {
        GLOBAL $sess;

        $res = $res_vect->getbyid('res');
        $tab = $res_vect->getbyid('tab');

        log_lock("UNLOCK table [".$tab."]         [".(microtime(TRUE) - (self::$delta_t[$tab]))."]");

        file_unlock($res);
    }


    function chatt_send($user, $mesg, $mlang_indwr = NULL)
    {
        GLOBAL $mlang_brisk, $G_lang;

        if ($user->stat != 'table') {
            return;
        }
        $curtime = time();

        $table = &$this->table[$user->table];
        $user_mesg = substr($mesg,6);

        $ret = FALSE;
        $mesg = "";

        $dt = date("H:i ", $curtime);
        if (strncmp($user_mesg, "/cont ", 6) == 0) {
            log_main($user->sess." chatt_send BEGIN");

            $match_id = substr($user_mesg, 6);
            $table->match_continue($this, $user, $match_id);
        }
        else if (strncmp($user_mesg, "/rules ", 7) == 0) {
            log_main($user->sess." chatt_send BEGIN");

            $rules_id = substr($user_mesg, 7);
            $table->rules_change($this, $user, $rules_id);
        }
        else {
            for ($i = 0 ; $i < ($user->stat == 'room' ? BIN5_MAX_PLAYERS : BIN5_PLAYERS_N) ; $i++) {
                if ($user->stat == 'room') {
                    $user_cur = &$this->user[$i];
                    if ($user_cur->is_active() == FALSE || $user_cur->stat != 'room') // is not active user or stat isn't 'room'
                        continue;
                }
                else {
                    $user_cur = &$this->user[$table->player[$i]];
                }

                $user_cur->comm[$user_cur->step % COMM_N] = "gst.st = ".($user_cur->step+1)."; ";
                $user_cur->comm[$user_cur->step % COMM_N] .= sprintf('chatt_sub("%s", [%d, "%s"],"%s");',
                                                                     $dt, $user->flags, xcape($user->name), xcape($user_mesg));
                $user_cur->step_inc();
            }
            log_legal($curtime, $user->ip, $user, ($user->stat == 'room' ? 'room' : 'table '.$user->table_orig),$user_mesg);
        }
    }

    function table_wakeup($user)
    {
        $table = &$this->table[0];

        log_main("BIN5_WAKEUP begin function table  stat: ".$user->stat."  subst: ".$user->subst);

        $curtime = time();

        log_main("BIN5_WAKEUP from table [".$user->table."] nplayers_n: ".$this->table[$user->table]->player_n);

        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user_cur = &$this->user[$i];
            log_main("PREIMPOST INLOOP name: ".$user_cur->name);

            if ($user_cur == $user)
                $user_cur->subst = "shutdowner";
            else
                $user_cur->subst = "shutdowned";
            $user_cur->laccwr = $curtime;

            $ret = "gst.st = ".($user_cur->step+1)."; ";
            $ret .= 'gst.st_loc++; xstm.stop(); window.onbeforeunload = null; window.onunload = null; document.location.assign("../index.php");|';

            log_wr($user_cur->sess." BIN5_WAKEUP: ".$ret);
            $user_cur->comm[$user_cur->step % COMM_N] = $ret;
            $user_cur->step_inc();
        }

        $this->the_end = TRUE;
    }

    /*
     *  If all players are freezed the room garbage_manager clean up table and users.
     */
    function is_abandoned()
    {
        $is_ab = TRUE;
        $curtime = time();

        $table = &$this->table[0];

        for ($i = 0 ; $i < $table->player_n ; $i++) {
            $user_cur = &$this->user[$i];

            if ($user_cur->lacc + (EXPIRE_TIME_RD * 2) >= $curtime) {
                $is_ab = FALSE;
                break;
            }
        }

        return ($is_ab);
    }

    static function request_mgr(&$s_a_p, $header, &$header_out, &$new_socket, $path, $addr, $get, $post, $cookie)
    {
        GLOBAL $G_ban_list, $G_black_list;

        printf("NEW_SOCKET (root): %d\n", intval($new_socket));

        $enc = get_encoding($header);
        if (isset($header['User-Agent'])) {
            if (strstr($header['User-Agent'], "MSIE")) {
                $transp_type = "htmlfile";
            }
            else {
                $transp_type = "xhr";
            }
        }
        else {
            $transp_type = "iframe";
        }
        force_no_cache($header_out);

        if (($table_idx = gpcs_var('table_idx', $get, $post, $cookie)) === FALSE)
            unset($table_idx);

        if (($table_token = gpcs_var('table_token', $get, $post, $cookie)) === FALSE)
            unset($table_token);


        switch ($path) {
        case "":
        case "index.php":
            ob_start();
            bin5_index_main($transp_type, $header_out, $addr, $get, $post, $cookie);
            $content = ob_get_contents();
            ob_end_clean();

            $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
            return TRUE;

        break;
        case "index_wr.php":
            if (isset($table_idx) && isset($table_token)) {
                if (($bri = $s_a_p->app->match_get($table_idx, $table_token)) != FALSE) {
                    ob_start();
                    bin5_index_wr_main($bri, $addr, $get, $post, $cookie);
                    $content = ob_get_contents();
                    ob_end_clean();
                }
                else {
                    $content = "Bin5 Load data error";
                }
            }
            else {
                $content = "Bin5 Load data error";
            }
            $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);
            return TRUE;

            break;
        case "index_rd.php":
            if (($transp  = gpcs_var('transp', $get, $post, $cookie)) === FALSE)
                $transp = "iframe";
            if ($transp == 'websocket')
                $enc = 'plain';

            do {
                if (!isset($table_idx)
                    || !isset($table_token)
                    || !isset($cookie['sess'])
                    || ($bri = $s_a_p->app->match_get($table_idx, $table_token)) == NULL
                    || (($user = $bri->get_user($cookie['sess'], $idx)) == FALSE)) {

                    $content = Bin5_user::stream_fini($transp_type, $s_a_p->rndstr, TRUE);
                    $s_a_p->pendpage_try_addflush($new_socket, 20, $enc, $header_out, $content);

                    return TRUE;
                    break;
                }
                $bri->brisk->sess_cur_set($user->sess);

                // close a previous opened index_read_ifra socket, if exists
                if (($prev = $user->rd_socket_get()) != NULL) {
                    $s_a_p->socks_unset($user->rd_socket_get());
                    fclose($user->rd_socket_get());
                    printf("CLOSE AND OPEN AGAIN ON IFRA2\n");
                    $user->rd_socket_set(NULL);
                }

                $content = "";
                $user->stream_init($s_a_p->rndstr, $enc, $header, $header_out, $content, $get, $post, $cookie);

                $response = headers_render($header_out, -1).$user->chunked_content($content);
                $response_l = mb_strlen($response, "ASCII");

                $wret = @fwrite($new_socket, $response, $response_l);
                if ($wret < $response_l) {
                    printf("TROUBLES WITH FWRITE: %d\n", $wret);
                    $user->rd_cache_set(mb_substr($content, $wret, $response_l - $wret, "ASCII"));
                }
                else {
                    $user->rd_cache_set("");
                }
                fflush($new_socket);


                $s_a_p->socks_set($new_socket, $user, NULL);
                $user->rd_socket_set($new_socket);
                printf(" - qui ci siamo - ");
                return TRUE;
            } while (FALSE);

            return FALSE;
            break;

        default:
            return FALSE;
            break;
      }

      return (FALSE);
  }



} // end class Bin5

function locshm_exists($tok)
{
    // return (TRUE);

    if (($id = @shmop_open($tok,"a", 0, 0)) == FALSE) {
        log_main($tok." SHM NOT exists");

        return (FALSE);
    }
    else {
        shmop_close($id);
        log_main($tok." SHM exists");

        return (TRUE);
    }

}


/* show table
   is_transition (is from room to table ?)
   is_again      (is another game)

   Examples                    of $is_transition, $is_again:
   from reload of the page:              FALSE, FALSE
   from sitdown in room:                  TRUE, FALSE
   from table: asta cmd e tutti passano:  TRUE, TRUE
   from table: fine partita:              TRUE, TRUE
*/
function show_table(&$bri, &$user, $sendstep, $is_transition, $is_again)
{
    $table_idx = $user->table;
    $table     = $bri->table[$table_idx];
    $table_pos = $user->table_pos;

    $ret = "table_init();";
    $ret .= $table->exitlock_show(&$bri->user, $table_pos);
    if (!$is_again) {
        /* GENERAL STATUS */
        $ret .= sprintf( 'gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;',
                         $sendstep, $user->stat, $user->subst, $table_pos);

        log_rd(sprintf( 'SHOW_TABLE: gst.st = %d; stat = "%s"; subst = "%s"; table_pos = %d;', $sendstep, $user->stat, $user->subst, $table_pos));

        /* BACKGROUND */
        $ret .= "background_set();";

        /* USERS INFO */
        $ret .= $user->myname_innerHTML();
        $ret .= sprintf('set_names([%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"], [%d, "%s"]); ',
                        $bri->user[$table->player[($table_pos) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos) % BIN5_PLAYERS_N]]->name),

                        $bri->user[$table->player[($table_pos+1) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos+1) % BIN5_PLAYERS_N]]->name),

                        $bri->user[$table->player[($table_pos+2) % BIN5_PLAYERS_N]]->flags,
                        xcape($bri->user[$table->player[($table_pos+2) % BIN5_PLAYERS_N]]->name),

                        (BIN5_PLAYERS_N == 3 ? 0 : $bri->user[$table->player[($table_pos+3) % BIN5_PLAYERS_N]]->flags),
                        (BIN5_PLAYERS_N == 3 ? "" :  xcape($bri->user[$table->player[($table_pos+3) % BIN5_PLAYERS_N]]->name)),

                        (BIN5_PLAYERS_N == 3 ? 0 : $bri->user[$table->player[($table_pos+4) % BIN5_PLAYERS_N]]->flags),
                        (BIN5_PLAYERS_N == 3 ? "" :  xcape($bri->user[$table->player[($table_pos+4) % BIN5_PLAYERS_N]]->name)));
    }
    /* NOTIFY FOR THE CARD MAKER */
    if ($is_transition) { //  && $user->subst ==  "asta" superfluo
        $ret .= show_table_info(&$bri, &$table, $table_pos);
        $ret .= "setTimeout(preload_images, 500, g_preload_img_arr, g_imgct);";
    }
    else {
        $ret .= "\$('imgct').innerHTML = \$('imgct').innerHTML = mlang_commons['imgload_a'][g_lang]+\"100%.\";";
    }
    if (!$is_again)
        $ret .= table_welcome($user);

    if ($is_transition && !$is_again) { // appena seduti al tavolo, play della mucca
        $ret .= playsound("cow.mp3");
    }


    /* CARDS */
    if ($is_transition) { //  && $user->subst ==  "asta" superfluo
        $ret .= "|";

        for ($i = 0 ; $i < BIN5_CARD_HAND ; $i++) {
            for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++) {
                $ct = 0;
                for ($o = 0 ; $o < (BIN5_CARD_HAND * BIN5_PLAYERS_N) && $ct < $i+1 ; $o++) {
                    // for ($o = 0 ; $o < 40 && $ct < $i+1 ; $o++) {
                    if ($table->card[$o]->owner == (($e + $table->gstart) % BIN5_PLAYERS_N)) {
                        $ct++;
                        if ($ct == $i+1)
                            break;
                    }
                }
                log_rd("O ".$o." VAL ".$table->card[$o]->value." Owner: ".$table->card[$o]->owner);

                $ret .= sprintf( ' card_send(%d,%d,%d,%8.2f,%d);|', ($table->gstart + $e) % BIN5_PLAYERS_N,
                                 $i, ((($e + BIN5_PLAYERS_N - $table_pos + $table->gstart) % BIN5_PLAYERS_N) == 0 ?
                                      $table->card[$o]->value : -1),
                                 ($i == 7 && $e == (BIN5_PLAYERS_N - 1) ? 1 : 0.5),$i+1);
            }
        }
    }
    else {
        $taked  = array(0,0,0,0,0);
        $inhand = array(0,0,0,0,0);
        $ontabl  = array(-1,-1,-1,-1,-1);
        $cards  = array();

        for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
            // for ($i = 0 ; $i < 40 ; $i++) {
            if ($table->card[$i]->stat == 'hand') {
                if ($table->card[$i]->owner == $table_pos) {
                    $cards[$inhand[$table->card[$i]->owner]] = $table->card[$i]->value;
                }
                $inhand[$table->card[$i]->owner]++;
            }
            else if ($table->card[$i]->stat == 'take') {
                log_main("Card taked: ".$table->card[$i]->value."OWN: ".$table->card[$i]->owner);
                $taked[$table->card[$i]->owner]++;
            }
            else if ($table->card[$i]->stat == 'table') {
                $ontabl[$table->card[$i]->owner] = $i;
            }
        }
        $logg = "\n";
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $logg .= sprintf("INHAND: %d   IN TABLE %d   TAKED %d\n", $inhand[$i], $ontabl[$i], $taked[$i]);
        }
        log_main("Stat table: ".$logg);

        /* Set ours cards. */
        $oursarg = "";
        for ($i = 0 ; $i < $inhand[$table_pos] ; $i++)
            $oursarg .= ($i == 0 ? "" : ", ").$cards[$i];
        for ($i = $inhand[$table_pos] ; $i < BIN5_CARD_HAND ; $i++)
            $oursarg .= ($i == 0 ? "" : ", ")."-1";
        $ret .= sprintf('card_setours(%s);', $oursarg);

        /* Dispose all cards */
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            /* Qui sotto al posto di + 1 c'era + ->gstart ... credo in modo errato */
            $ret .= sprintf('cards_dispose(%d,%d,%d);', $i,
                            ($inhand[$i] <= BIN5_CARD_HAND ? $inhand[$i] : BIN5_CARD_HAND), $taked[$i]);

            if ($ontabl[$i] != -1) {
                $ret .= sprintf('card_place(%d,%d,%d,%d,%d);',$i, $inhand[$i],
                                $table->card[$ontabl[$i]]->value,
                                $table->card[$ontabl[$i]]->x, $table->card[$ontabl[$i]]->y);
            }
        }
    }

    /* Show auction */
    if ($user->subst == 'asta') {

        /* show users auction status */
        $showst = "";
        for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
            $user_cur = &$bri->user[$table->player[$i]];
            $showst .= sprintf("%s%d", ($i == 0 ? "" : ", "),
                               ($user_cur->asta_card < 9 ? $user_cur->asta_card : $user_cur->asta_pnt));
        }
        if (BIN5_PLAYERS_N == 3)
            $showst .= ",-2,-2";
        $ret .= sprintf('document.title = "Brisk - Tavolo %d (asta)";', $user->table_orig);
        $ret .= sprintf('show_astat(%s);', $showst);

        if ($table->asta_win != -1 && $table->asta_win == $table_pos) {
            /* show card chooser */
            $ret .= sprintf('choose_seed(%s); $("astalascio").style.visibility = ""; $("asta").style.visibility = "hidden";',
                            $table->asta_card);
        }
        else {
            /* show auction */
            if ($table_pos == ($table->gstart % BIN5_PLAYERS_N) &&
                $table->asta_win == -1)
                $ret .= sprintf('dispose_asta(%d,%d, %s);',
                                $table->asta_card + 1, $table->asta_pnt+1, ($user->handpt <= 2 ? "true" : "false"));
            else
                $ret .= sprintf('dispose_asta(%d,%d, %s);',
                                $table->asta_card + 1, -($table->asta_pnt+1), ($user->handpt <= 2 ?  "true" : "false"));
        }

        /* Remark */
        if ($table->asta_win == -1) { // auction case
            if ($table_pos == ($table->gstart % BIN5_PLAYERS_N))
                $ret .= "remark_on();";
            else
                $ret .= "remark_off();";
        }
        else { // chooseed case
            if ($table_pos == $table->asta_win)
                $ret .= "remark_on();";
            else
                $ret .= "remark_off();";
        }
    }
    else if ($user->subst == 'game') {
        /* HIGHLIGHT */
        if (($table->gstart + $table->turn) % BIN5_PLAYERS_N == $table_pos)
            $ret .= "is_my_time = true; remark_on();";
        else
            $ret .= "remark_off();";

        /* WHO CALL AND WHAT */
        $ret .= briscola_show($bri, $table, $user);

    }
    return ($ret);
} // end function show_table(...

function calculate_winner(&$table)
{
    $briontab = FALSE;
    $ontab = array();
    $ontid = array();
    $cur_win  =  -1;
    $cur_val  = 100;
    $cur_seed = $table->briscola - ($table->briscola % 10);

    for ($i = 0 ; $i < (BIN5_CARD_HAND * BIN5_PLAYERS_N) ; $i++) {
        // for ($i = 0 ; $i < 40 ; $i++) {
        if ($table->card[$i]->stat != "table")
            continue;

        log_wr(sprintf("Card On table: [%d]", $i));

        $v = $table->card[$i]->value;
        $ontab[$table->card[$i]->owner] = $v;
        $ontid[$table->card[$i]->owner] = $i;
        /* se briscola setto il flag */
        if (($v - ($v % 10)) == $cur_seed)
            $briontab = TRUE;
    }

    if ($briontab == FALSE) {
        $cur_win  = $table->gstart;
        $cur_val  = $ontab[$cur_win];
        $cur_seed = $cur_val - ($cur_val % 10);
    }

    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
        if (($ontab[$i] - ($ontab[$i] % 10)) == $cur_seed) {
            if ($ontab[$i] < $cur_val) {
                $cur_val = $ontab[$i];
                $cur_win = $i;
            }
        }
    }

    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++) {
        $table->card[$ontid[$i]]->owner = $cur_win;
        $table->card[$ontid[$i]]->stat =  "take"; // Card stat
    }
    return ($cur_win);
}

function show_table_info(&$bri, &$table, $table_pos)
{
    GLOBAL $G_lang, $mlang_bin5_bin5;

    $tg_br = "<br>";
    $tg_hr = "<hr>";
    $tg_bo = "<b>";
    $tg_bc = "</b>";

    $ret = "";
    $user = $bri->user[$table->player[$table_pos]];

    // TAG: POINTS_MANAGEMENT
    $pnt_min = $table->points_n - MAX_POINTS < 0 ? 0 : $table->points_n - MAX_POINTS;
    $noty = sprintf('<table class=\"points\"><tr><th></th>');

    // Names.
    for ($i = 0 ; $i < BIN5_PLAYERS_N ; $i++)
        $noty .= sprintf('<th class=\"td_points\">%s</th>', xcape($bri->user[$table->player[$i]]->name));
    $noty .= sprintf("</tr>");

    // Points.
    log_main("show_table_info: pnt_min: ".$pnt_min."   Points_n: ".$table->points_n);

    for ($i = $pnt_min ; $i < $table->points_n ; $i++) {
        $noty .= sprintf('<tr><th class=\"td_points\">%d</th>', $i+1);
        for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++)
            $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->points[$i % MAX_POINTS][$e]);
        $noty .= "</tr>";
    }

    // Total points.
    $noty .= '<tr><th class=\"td_points\">Tot.</th>';
    for ($e = 0 ; $e < BIN5_PLAYERS_N ; $e++)
        $noty .= sprintf('<td class=\"td_points\">%d</td>', $table->total[$e]);
    $noty .= "</tr></table>";
    $noty .= "<hr>";
    if ($table->old_reason != "") {
        $noty .= sprintf($mlang_bin5_bin5['info_last'][$G_lang],
                         $tg_br, $tg_hr, $tg_bo, $tg_bc);
        $noty .= '<br>';
        $noty .= $table->old_reason;
    }

    $noty .= sprintf($mlang_bin5_bin5['info_curr'][$G_lang],
                     $tg_br, $tg_hr, $tg_bo, $tg_bc);
    $noty .= '<br>';
    /* MLANG: "Fai <b>tu</b> il mazzo,", "Il mazzo a <b>$unam</b>," */
    if ($table->mazzo == $table_pos)
        $noty .= $mlang_bin5_bin5['info_yshuf'][$G_lang];
    else {
        $unam = xcape($bri->user[$table->player[$table->mazzo]]->name);
        $noty .= sprintf($mlang_bin5_bin5['info_shuf'][$G_lang], $unam);
    }

    if ($user->subst == 'asta') {
        if ($table->asta_win == -1)  // auction case
            $curplayer = $table->gstart % BIN5_PLAYERS_N;
        else
            $curplayer = $table->asta_win;
    }
    else if ($user->subst == 'game') {
        $curplayer = ($table->gstart + $table->turn) % BIN5_PLAYERS_N;
    }

    /* MLANG: " tocca a <b>te</b> giocare.", " tocca a <b>$unam</b> giocare.", " La partita vale <b>%s</b>.", "torna alla partita" */
    if ($curplayer == $table_pos) {
        $noty .= $mlang_bin5_bin5['info_yturn'][$G_lang];
    }
    else {
        $unam = xcape($bri->user[$table->player[$curplayer]]->name);
        $noty .= sprintf($mlang_bin5_bin5['info_turn'][$G_lang], $unam);
    }

    $multer = $table->rules->multer(TRUE);
    if ($multer > 1) {
        $noty .= sprintf($mlang_bin5_bin5['info_mult'][$G_lang], multoval($multer) );
    }
    $noty .= "<hr>";
    if ($table->match_id != -1) {
        $noty .= sprintf($mlang_bin5_bin5['info_match'][$G_lang], $table->match_id);
        $noty .= "<hr>";
    }
    $ret .= show_notify($noty, 3000, $mlang_bin5_bin5['btn_bkgame'][$G_lang], 500, 400);
    /* NOTE: show_notify($noty, 3000, "torna alla partita", 500,
     *                   130 + ($table->points_n > 0 ? 50 : 0) +
     *                   (120 * ($table->points_n / MAX_POINTS)));
     *       will be used when we refact notify js function following
     *       photoo class logic
     */

    return ($ret);
}

function table_welcome($user)
{
    GLOBAL $table_wellarr, $G_lang;
    $ret = "";

    for ($i = 0 ; $i < count($table_wellarr[$G_lang]) ; $i++)
        $ret .= sprintf('chatt_sub("%s", [2, "ChanServ: "],"%s");', "", str_replace('"', '\"', $table_wellarr[$G_lang][$i]));

    return ($ret);
}


function briscola_show($bri, $table, $user)
{
    GLOBAL $G_lang, $mlang_bin5_bin5;
    $ptnadd = "";
    $ret = "";

    if ($table->asta_card == 9)
        $ptnadd = sprintf($mlang_bin5_bin5['call_wptn'][$G_lang], $table->asta_pnt);

    /* text of caller cell */
    if ($user->table_pos == $table->asta_win) {
        $prestr = sprintf('$("callerinfo").innerHTML = "%s";', $mlang_bin5_bin5['call_ycall'][$G_lang]);
        $ret .= sprintf($prestr, $ptnadd);
    }
    else {
        $prestr = sprintf('$("callerinfo").innerHTML = "%s";', $mlang_bin5_bin5['call_call'][$G_lang]);
        $ret .= sprintf($prestr,
                        xcape($bri->user[$table->player[$table->asta_win]]->name), $ptnadd);
    }
    $ret .= sprintf('set_iscalling(%d);', ($table->asta_win - $user->table_pos + BIN5_PLAYERS_N) % BIN5_PLAYERS_N);

    $ret .= sprintf('$("caller").style.backgroundImage = \'url("img/brisk_caller_sand%d.png")\';',
                    $table->asta_win);
    $ret .= sprintf('$("callerimg").src = "img/%02d.png";', $table->briscola);
    $ret .= sprintf('$("caller").style.visibility = "visible";');
    $ret .= sprintf('$("chooseed").style.visibility = "hidden";');
    $ret .= sprintf('$("astalascio").style.visibility = "";');
    $ret .= sprintf('$("asta").style.visibility = "hidden";');
    $ret .= sprintf('show_astat(-2,-2,-2,-2,-2);');

    return ($ret);
}

function log_points($remote_addr, $curtime, $user, $where, $mesg)
{
    if (($fp = @fopen(LEGAL_PATH."/points.log", 'a')) != FALSE) {
        /* Unix time | session | nickname | IP | where was | mesg */
        fwrite($fp, sprintf("%ld|%s|%s|%s|%s|%s|%s|\n", $curtime, $user->sess,
                            ($user->is_auth() ? 'A' : 'N'),
                            $user->name, $remote_addr, $where , $mesg));
        fclose($fp);
    }
}


?>
